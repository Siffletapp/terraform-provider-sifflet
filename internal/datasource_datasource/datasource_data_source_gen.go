// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_datasource

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DatasourceDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"catalog_filters": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"children": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"id": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"results": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: ChildrenType{
									ObjectType: types.ObjectType{
										AttrTypes: ChildrenValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"query": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: CatalogFiltersType{
						ObjectType: types.ObjectType{
							AttrTypes: CatalogFiltersValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"datasource_type": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Filter on given datasource types",
				MarkdownDescription: "Filter on given datasource types",
			},
			"items_per_page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items",
				MarkdownDescription: "The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items",
			},
			"page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The requested page number. Zero-based page index (0..N)",
				MarkdownDescription: "The requested page number. Zero-based page index (0..N)",
			},
			"search_datasources": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"data": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"created_by": schema.StringAttribute{
									Computed: true,
								},
								"created_date": schema.StringAttribute{
									Computed: true,
								},
								"cron_expression": schema.StringAttribute{
									Computed: true,
								},
								"entity_type": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"last_modified_date": schema.StringAttribute{
									Computed: true,
								},
								"modified_by": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"next_execution": schema.StringAttribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: DataType{
								ObjectType: types.ObjectType{
									AttrTypes: DataValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed: true,
					},
					"total_elements": schema.Int64Attribute{
						Computed: true,
					},
				},
				CustomType: SearchDatasourcesType{
					ObjectType: types.ObjectType{
						AttrTypes: SearchDatasourcesValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"sort": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "The resource fields on which to apply the sort, format : property,ASC|DESC",
				MarkdownDescription: "The resource fields on which to apply the sort, format : property,ASC|DESC",
			},
			"tag": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Filter on given tag ids",
				MarkdownDescription: "Filter on given tag ids",
			},
			"text_search": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Global text search",
				MarkdownDescription: "Global text search",
			},
		},
	}
}

type DatasourceModel struct {
	CatalogFilters    types.List             `tfsdk:"catalog_filters"`
	DatasourceType    types.List             `tfsdk:"datasource_type"`
	ItemsPerPage      types.Int64            `tfsdk:"items_per_page"`
	Page              types.Int64            `tfsdk:"page"`
	SearchDatasources SearchDatasourcesValue `tfsdk:"search_datasources"`
	Sort              types.List             `tfsdk:"sort"`
	Tag               types.List             `tfsdk:"tag"`
	TextSearch        types.String           `tfsdk:"text_search"`
}

var _ basetypes.ObjectTypable = CatalogFiltersType{}

type CatalogFiltersType struct {
	basetypes.ObjectType
}

func (t CatalogFiltersType) Equal(o attr.Type) bool {
	other, ok := o.(CatalogFiltersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CatalogFiltersType) String() string {
	return "CatalogFiltersType"
}

func (t CatalogFiltersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	childrenAttribute, ok := attributes["children"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`children is missing from object`)

		return nil, diags
	}

	childrenVal, ok := childrenAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`children expected to be basetypes.ListValue, was: %T`, childrenAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	queryAttribute, ok := attributes["query"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query is missing from object`)

		return nil, diags
	}

	queryVal, ok := queryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query expected to be basetypes.StringValue, was: %T`, queryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CatalogFiltersValue{
		Children: childrenVal,
		Id:       idVal,
		Name:     nameVal,
		Query:    queryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCatalogFiltersValueNull() CatalogFiltersValue {
	return CatalogFiltersValue{
		state: attr.ValueStateNull,
	}
}

func NewCatalogFiltersValueUnknown() CatalogFiltersValue {
	return CatalogFiltersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCatalogFiltersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CatalogFiltersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CatalogFiltersValue Attribute Value",
				"While creating a CatalogFiltersValue value, a missing attribute value was detected. "+
					"A CatalogFiltersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CatalogFiltersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CatalogFiltersValue Attribute Type",
				"While creating a CatalogFiltersValue value, an invalid attribute value was detected. "+
					"A CatalogFiltersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CatalogFiltersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CatalogFiltersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CatalogFiltersValue Attribute Value",
				"While creating a CatalogFiltersValue value, an extra attribute value was detected. "+
					"A CatalogFiltersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CatalogFiltersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCatalogFiltersValueUnknown(), diags
	}

	childrenAttribute, ok := attributes["children"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`children is missing from object`)

		return NewCatalogFiltersValueUnknown(), diags
	}

	childrenVal, ok := childrenAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`children expected to be basetypes.ListValue, was: %T`, childrenAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCatalogFiltersValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCatalogFiltersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	queryAttribute, ok := attributes["query"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query is missing from object`)

		return NewCatalogFiltersValueUnknown(), diags
	}

	queryVal, ok := queryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query expected to be basetypes.StringValue, was: %T`, queryAttribute))
	}

	if diags.HasError() {
		return NewCatalogFiltersValueUnknown(), diags
	}

	return CatalogFiltersValue{
		Children: childrenVal,
		Id:       idVal,
		Name:     nameVal,
		Query:    queryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCatalogFiltersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CatalogFiltersValue {
	object, diags := NewCatalogFiltersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCatalogFiltersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CatalogFiltersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCatalogFiltersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCatalogFiltersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCatalogFiltersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCatalogFiltersValueMust(CatalogFiltersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CatalogFiltersType) ValueType(ctx context.Context) attr.Value {
	return CatalogFiltersValue{}
}

var _ basetypes.ObjectValuable = CatalogFiltersValue{}

type CatalogFiltersValue struct {
	Children basetypes.ListValue   `tfsdk:"children"`
	Id       basetypes.StringValue `tfsdk:"id"`
	Name     basetypes.StringValue `tfsdk:"name"`
	Query    basetypes.StringValue `tfsdk:"query"`
	state    attr.ValueState
}

func (v CatalogFiltersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["children"] = basetypes.ListType{
		ElemType: ChildrenValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["query"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Children.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["children"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Query.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["query"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CatalogFiltersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CatalogFiltersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CatalogFiltersValue) String() string {
	return "CatalogFiltersValue"
}

func (v CatalogFiltersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	children := types.ListValueMust(
		ChildrenType{
			basetypes.ObjectType{
				AttrTypes: ChildrenValue{}.AttributeTypes(ctx),
			},
		},
		v.Children.Elements(),
	)

	if v.Children.IsNull() {
		children = types.ListNull(
			ChildrenType{
				basetypes.ObjectType{
					AttrTypes: ChildrenValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Children.IsUnknown() {
		children = types.ListUnknown(
			ChildrenType{
				basetypes.ObjectType{
					AttrTypes: ChildrenValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"children": basetypes.ListType{
				ElemType: ChildrenValue{}.Type(ctx),
			},
			"id":    basetypes.StringType{},
			"name":  basetypes.StringType{},
			"query": basetypes.StringType{},
		},
		map[string]attr.Value{
			"children": children,
			"id":       v.Id,
			"name":     v.Name,
			"query":    v.Query,
		})

	return objVal, diags
}

func (v CatalogFiltersValue) Equal(o attr.Value) bool {
	other, ok := o.(CatalogFiltersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Children.Equal(other.Children) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Query.Equal(other.Query) {
		return false
	}

	return true
}

func (v CatalogFiltersValue) Type(ctx context.Context) attr.Type {
	return CatalogFiltersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CatalogFiltersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"children": basetypes.ListType{
			ElemType: ChildrenValue{}.Type(ctx),
		},
		"id":    basetypes.StringType{},
		"name":  basetypes.StringType{},
		"query": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ChildrenType{}

type ChildrenType struct {
	basetypes.ObjectType
}

func (t ChildrenType) Equal(o attr.Type) bool {
	other, ok := o.(ChildrenType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ChildrenType) String() string {
	return "ChildrenType"
}

func (t ChildrenType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resultsAttribute, ok := attributes["results"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`results is missing from object`)

		return nil, diags
	}

	resultsVal, ok := resultsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`results expected to be basetypes.Int64Value, was: %T`, resultsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ChildrenValue{
		Id:      idVal,
		Name:    nameVal,
		Results: resultsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewChildrenValueNull() ChildrenValue {
	return ChildrenValue{
		state: attr.ValueStateNull,
	}
}

func NewChildrenValueUnknown() ChildrenValue {
	return ChildrenValue{
		state: attr.ValueStateUnknown,
	}
}

func NewChildrenValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ChildrenValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ChildrenValue Attribute Value",
				"While creating a ChildrenValue value, a missing attribute value was detected. "+
					"A ChildrenValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChildrenValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ChildrenValue Attribute Type",
				"While creating a ChildrenValue value, an invalid attribute value was detected. "+
					"A ChildrenValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChildrenValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ChildrenValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ChildrenValue Attribute Value",
				"While creating a ChildrenValue value, an extra attribute value was detected. "+
					"A ChildrenValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ChildrenValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewChildrenValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewChildrenValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewChildrenValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resultsAttribute, ok := attributes["results"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`results is missing from object`)

		return NewChildrenValueUnknown(), diags
	}

	resultsVal, ok := resultsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`results expected to be basetypes.Int64Value, was: %T`, resultsAttribute))
	}

	if diags.HasError() {
		return NewChildrenValueUnknown(), diags
	}

	return ChildrenValue{
		Id:      idVal,
		Name:    nameVal,
		Results: resultsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewChildrenValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ChildrenValue {
	object, diags := NewChildrenValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewChildrenValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ChildrenType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewChildrenValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewChildrenValueUnknown(), nil
	}

	if in.IsNull() {
		return NewChildrenValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewChildrenValueMust(ChildrenValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ChildrenType) ValueType(ctx context.Context) attr.Value {
	return ChildrenValue{}
}

var _ basetypes.ObjectValuable = ChildrenValue{}

type ChildrenValue struct {
	Id      basetypes.StringValue `tfsdk:"id"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Results basetypes.Int64Value  `tfsdk:"results"`
	state   attr.ValueState
}

func (v ChildrenValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["results"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Results.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["results"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ChildrenValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ChildrenValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ChildrenValue) String() string {
	return "ChildrenValue"
}

func (v ChildrenValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id":      basetypes.StringType{},
			"name":    basetypes.StringType{},
			"results": basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"id":      v.Id,
			"name":    v.Name,
			"results": v.Results,
		})

	return objVal, diags
}

func (v ChildrenValue) Equal(o attr.Value) bool {
	other, ok := o.(ChildrenValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Results.Equal(other.Results) {
		return false
	}

	return true
}

func (v ChildrenValue) Type(ctx context.Context) attr.Type {
	return ChildrenType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ChildrenValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":      basetypes.StringType{},
		"name":    basetypes.StringType{},
		"results": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SearchDatasourcesType{}

type SearchDatasourcesType struct {
	basetypes.ObjectType
}

func (t SearchDatasourcesType) Equal(o attr.Type) bool {
	other, ok := o.(SearchDatasourcesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SearchDatasourcesType) String() string {
	return "SearchDatasourcesType"
}

func (t SearchDatasourcesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	totalElementsAttribute, ok := attributes["total_elements"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_elements is missing from object`)

		return nil, diags
	}

	totalElementsVal, ok := totalElementsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_elements expected to be basetypes.Int64Value, was: %T`, totalElementsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SearchDatasourcesValue{
		Data:          dataVal,
		TotalElements: totalElementsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSearchDatasourcesValueNull() SearchDatasourcesValue {
	return SearchDatasourcesValue{
		state: attr.ValueStateNull,
	}
}

func NewSearchDatasourcesValueUnknown() SearchDatasourcesValue {
	return SearchDatasourcesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSearchDatasourcesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SearchDatasourcesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SearchDatasourcesValue Attribute Value",
				"While creating a SearchDatasourcesValue value, a missing attribute value was detected. "+
					"A SearchDatasourcesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SearchDatasourcesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SearchDatasourcesValue Attribute Type",
				"While creating a SearchDatasourcesValue value, an invalid attribute value was detected. "+
					"A SearchDatasourcesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SearchDatasourcesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SearchDatasourcesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SearchDatasourcesValue Attribute Value",
				"While creating a SearchDatasourcesValue value, an extra attribute value was detected. "+
					"A SearchDatasourcesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SearchDatasourcesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSearchDatasourcesValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewSearchDatasourcesValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	totalElementsAttribute, ok := attributes["total_elements"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_elements is missing from object`)

		return NewSearchDatasourcesValueUnknown(), diags
	}

	totalElementsVal, ok := totalElementsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_elements expected to be basetypes.Int64Value, was: %T`, totalElementsAttribute))
	}

	if diags.HasError() {
		return NewSearchDatasourcesValueUnknown(), diags
	}

	return SearchDatasourcesValue{
		Data:          dataVal,
		TotalElements: totalElementsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSearchDatasourcesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SearchDatasourcesValue {
	object, diags := NewSearchDatasourcesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSearchDatasourcesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SearchDatasourcesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSearchDatasourcesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSearchDatasourcesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSearchDatasourcesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSearchDatasourcesValueMust(SearchDatasourcesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SearchDatasourcesType) ValueType(ctx context.Context) attr.Value {
	return SearchDatasourcesValue{}
}

var _ basetypes.ObjectValuable = SearchDatasourcesValue{}

type SearchDatasourcesValue struct {
	Data          basetypes.ListValue  `tfsdk:"data"`
	TotalElements basetypes.Int64Value `tfsdk:"total_elements"`
	state         attr.ValueState
}

func (v SearchDatasourcesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ListType{
		ElemType: DataValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["total_elements"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		val, err = v.TotalElements.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_elements"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SearchDatasourcesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SearchDatasourcesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SearchDatasourcesValue) String() string {
	return "SearchDatasourcesValue"
}

func (v SearchDatasourcesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	data := types.ListValueMust(
		DataType{
			basetypes.ObjectType{
				AttrTypes: DataValue{}.AttributeTypes(ctx),
			},
		},
		v.Data.Elements(),
	)

	if v.Data.IsNull() {
		data = types.ListNull(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Data.IsUnknown() {
		data = types.ListUnknown(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"data": basetypes.ListType{
				ElemType: DataValue{}.Type(ctx),
			},
			"total_elements": basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"data":           data,
			"total_elements": v.TotalElements,
		})

	return objVal, diags
}

func (v SearchDatasourcesValue) Equal(o attr.Value) bool {
	other, ok := o.(SearchDatasourcesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	if !v.TotalElements.Equal(other.TotalElements) {
		return false
	}

	return true
}

func (v SearchDatasourcesValue) Type(ctx context.Context) attr.Type {
	return SearchDatasourcesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SearchDatasourcesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
		"total_elements": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdByAttribute, ok := attributes["created_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_by is missing from object`)

		return nil, diags
	}

	createdByVal, ok := createdByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_by expected to be basetypes.StringValue, was: %T`, createdByAttribute))
	}

	createdDateAttribute, ok := attributes["created_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_date is missing from object`)

		return nil, diags
	}

	createdDateVal, ok := createdDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_date expected to be basetypes.StringValue, was: %T`, createdDateAttribute))
	}

	cronExpressionAttribute, ok := attributes["cron_expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cron_expression is missing from object`)

		return nil, diags
	}

	cronExpressionVal, ok := cronExpressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cron_expression expected to be basetypes.StringValue, was: %T`, cronExpressionAttribute))
	}

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return nil, diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	lastModifiedDateAttribute, ok := attributes["last_modified_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_modified_date is missing from object`)

		return nil, diags
	}

	lastModifiedDateVal, ok := lastModifiedDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_modified_date expected to be basetypes.StringValue, was: %T`, lastModifiedDateAttribute))
	}

	modifiedByAttribute, ok := attributes["modified_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_by is missing from object`)

		return nil, diags
	}

	modifiedByVal, ok := modifiedByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_by expected to be basetypes.StringValue, was: %T`, modifiedByAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nextExecutionAttribute, ok := attributes["next_execution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_execution is missing from object`)

		return nil, diags
	}

	nextExecutionVal, ok := nextExecutionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_execution expected to be basetypes.StringValue, was: %T`, nextExecutionAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		CreatedBy:        createdByVal,
		CreatedDate:      createdDateVal,
		CronExpression:   cronExpressionVal,
		EntityType:       entityTypeVal,
		Id:               idVal,
		LastModifiedDate: lastModifiedDateVal,
		ModifiedBy:       modifiedByVal,
		Name:             nameVal,
		NextExecution:    nextExecutionVal,
		DataType:         typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	createdByAttribute, ok := attributes["created_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_by is missing from object`)

		return NewDataValueUnknown(), diags
	}

	createdByVal, ok := createdByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_by expected to be basetypes.StringValue, was: %T`, createdByAttribute))
	}

	createdDateAttribute, ok := attributes["created_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_date is missing from object`)

		return NewDataValueUnknown(), diags
	}

	createdDateVal, ok := createdDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_date expected to be basetypes.StringValue, was: %T`, createdDateAttribute))
	}

	cronExpressionAttribute, ok := attributes["cron_expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cron_expression is missing from object`)

		return NewDataValueUnknown(), diags
	}

	cronExpressionVal, ok := cronExpressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cron_expression expected to be basetypes.StringValue, was: %T`, cronExpressionAttribute))
	}

	entityTypeAttribute, ok := attributes["entity_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entity_type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	entityTypeVal, ok := entityTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entity_type expected to be basetypes.StringValue, was: %T`, entityTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	lastModifiedDateAttribute, ok := attributes["last_modified_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_modified_date is missing from object`)

		return NewDataValueUnknown(), diags
	}

	lastModifiedDateVal, ok := lastModifiedDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_modified_date expected to be basetypes.StringValue, was: %T`, lastModifiedDateAttribute))
	}

	modifiedByAttribute, ok := attributes["modified_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_by is missing from object`)

		return NewDataValueUnknown(), diags
	}

	modifiedByVal, ok := modifiedByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_by expected to be basetypes.StringValue, was: %T`, modifiedByAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nextExecutionAttribute, ok := attributes["next_execution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_execution is missing from object`)

		return NewDataValueUnknown(), diags
	}

	nextExecutionVal, ok := nextExecutionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_execution expected to be basetypes.StringValue, was: %T`, nextExecutionAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		CreatedBy:        createdByVal,
		CreatedDate:      createdDateVal,
		CronExpression:   cronExpressionVal,
		EntityType:       entityTypeVal,
		Id:               idVal,
		LastModifiedDate: lastModifiedDateVal,
		ModifiedBy:       modifiedByVal,
		Name:             nameVal,
		NextExecution:    nextExecutionVal,
		DataType:         typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	CreatedBy        basetypes.StringValue `tfsdk:"created_by"`
	CreatedDate      basetypes.StringValue `tfsdk:"created_date"`
	CronExpression   basetypes.StringValue `tfsdk:"cron_expression"`
	EntityType       basetypes.StringValue `tfsdk:"entity_type"`
	Id               basetypes.StringValue `tfsdk:"id"`
	LastModifiedDate basetypes.StringValue `tfsdk:"last_modified_date"`
	ModifiedBy       basetypes.StringValue `tfsdk:"modified_by"`
	Name             basetypes.StringValue `tfsdk:"name"`
	NextExecution    basetypes.StringValue `tfsdk:"next_execution"`
	DataType         basetypes.StringValue `tfsdk:"type"`
	state            attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["created_by"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cron_expression"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["entity_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_modified_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified_by"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["next_execution"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.CreatedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_by"] = val

		val, err = v.CreatedDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_date"] = val

		val, err = v.CronExpression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cron_expression"] = val

		val, err = v.EntityType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entity_type"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.LastModifiedDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_modified_date"] = val

		val, err = v.ModifiedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified_by"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NextExecution.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_execution"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"created_by":         basetypes.StringType{},
			"created_date":       basetypes.StringType{},
			"cron_expression":    basetypes.StringType{},
			"entity_type":        basetypes.StringType{},
			"id":                 basetypes.StringType{},
			"last_modified_date": basetypes.StringType{},
			"modified_by":        basetypes.StringType{},
			"name":               basetypes.StringType{},
			"next_execution":     basetypes.StringType{},
			"type":               basetypes.StringType{},
		},
		map[string]attr.Value{
			"created_by":         v.CreatedBy,
			"created_date":       v.CreatedDate,
			"cron_expression":    v.CronExpression,
			"entity_type":        v.EntityType,
			"id":                 v.Id,
			"last_modified_date": v.LastModifiedDate,
			"modified_by":        v.ModifiedBy,
			"name":               v.Name,
			"next_execution":     v.NextExecution,
			"type":               v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedBy.Equal(other.CreatedBy) {
		return false
	}

	if !v.CreatedDate.Equal(other.CreatedDate) {
		return false
	}

	if !v.CronExpression.Equal(other.CronExpression) {
		return false
	}

	if !v.EntityType.Equal(other.EntityType) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.LastModifiedDate.Equal(other.LastModifiedDate) {
		return false
	}

	if !v.ModifiedBy.Equal(other.ModifiedBy) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NextExecution.Equal(other.NextExecution) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_by":         basetypes.StringType{},
		"created_date":       basetypes.StringType{},
		"cron_expression":    basetypes.StringType{},
		"entity_type":        basetypes.StringType{},
		"id":                 basetypes.StringType{},
		"last_modified_date": basetypes.StringType{},
		"modified_by":        basetypes.StringType{},
		"name":               basetypes.StringType{},
		"next_execution":     basetypes.StringType{},
		"type":               basetypes.StringType{},
	}
}
