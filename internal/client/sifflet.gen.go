// Package example provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package example

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	// "time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JWTScopes = "JWT.Scopes"
)

// Defines values for AlertingHookDtoType.
const (
	MAIL    AlertingHookDtoType = "MAIL"
	MSTEAMS AlertingHookDtoType = "MS_TEAMS"
	SLACK   AlertingHookDtoType = "SLACK"
)

// Defines values for AsCodeWorkspaceDtoKind.
const (
	Monitor   AsCodeWorkspaceDtoKind = "Monitor"
	Workspace AsCodeWorkspaceDtoKind = "Workspace"
)

// Defines values for AssetDataQualityDtoQualityStatus.
const (
	AssetDataQualityDtoQualityStatusATRISK       AssetDataQualityDtoQualityStatus = "AT_RISK"
	AssetDataQualityDtoQualityStatusCRITICAL     AssetDataQualityDtoQualityStatus = "CRITICAL"
	AssetDataQualityDtoQualityStatusHEALTHY      AssetDataQualityDtoQualityStatus = "HEALTHY"
	AssetDataQualityDtoQualityStatusNOTSUPPORTED AssetDataQualityDtoQualityStatus = "NOT_SUPPORTED"
	AssetDataQualityDtoQualityStatusUNMONITORED  AssetDataQualityDtoQualityStatus = "UNMONITORED"
)

// Defines values for AssetDetailsDtoDatasourceType.
const (
	AssetDetailsDtoDatasourceTypeAIRFLOW    AssetDetailsDtoDatasourceType = "AIRFLOW"
	AssetDetailsDtoDatasourceTypeATHENA     AssetDetailsDtoDatasourceType = "ATHENA"
	AssetDetailsDtoDatasourceTypeBIGQUERY   AssetDetailsDtoDatasourceType = "BIGQUERY"
	AssetDetailsDtoDatasourceTypeDATABRICKS AssetDetailsDtoDatasourceType = "DATABRICKS"
	AssetDetailsDtoDatasourceTypeDBT        AssetDetailsDtoDatasourceType = "DBT"
	AssetDetailsDtoDatasourceTypeDBTCLOUD   AssetDetailsDtoDatasourceType = "DBTCLOUD"
	AssetDetailsDtoDatasourceTypeFIREBOLT   AssetDetailsDtoDatasourceType = "FIREBOLT"
	AssetDetailsDtoDatasourceTypeFIVETRAN   AssetDetailsDtoDatasourceType = "FIVETRAN"
	AssetDetailsDtoDatasourceTypeH2         AssetDetailsDtoDatasourceType = "H2"
	AssetDetailsDtoDatasourceTypeHIVE       AssetDetailsDtoDatasourceType = "HIVE"
	AssetDetailsDtoDatasourceTypeLOOKER     AssetDetailsDtoDatasourceType = "LOOKER"
	AssetDetailsDtoDatasourceTypeMSSQL      AssetDetailsDtoDatasourceType = "MSSQL"
	AssetDetailsDtoDatasourceTypeMYSQL      AssetDetailsDtoDatasourceType = "MYSQL"
	AssetDetailsDtoDatasourceTypeORACLE     AssetDetailsDtoDatasourceType = "ORACLE"
	AssetDetailsDtoDatasourceTypePOSTGRES   AssetDetailsDtoDatasourceType = "POSTGRES"
	AssetDetailsDtoDatasourceTypePOWERBI    AssetDetailsDtoDatasourceType = "POWER_BI"
	AssetDetailsDtoDatasourceTypeQUICKSIGHT AssetDetailsDtoDatasourceType = "QUICKSIGHT"
	AssetDetailsDtoDatasourceTypeREDSHIFT   AssetDetailsDtoDatasourceType = "REDSHIFT"
	AssetDetailsDtoDatasourceTypeSNOWFLAKE  AssetDetailsDtoDatasourceType = "SNOWFLAKE"
	AssetDetailsDtoDatasourceTypeTABLEAU    AssetDetailsDtoDatasourceType = "TABLEAU"
	AssetDetailsDtoDatasourceTypeUNKNOWN    AssetDetailsDtoDatasourceType = "_UNKNOWN_"
)

// Defines values for AssetDtoDisplayedTypeEnum.
const (
	AssetDtoDisplayedTypeEnumDAG              AssetDtoDisplayedTypeEnum = "DAG"
	AssetDtoDisplayedTypeEnumDASHBOARD        AssetDtoDisplayedTypeEnum = "DASHBOARD"
	AssetDtoDisplayedTypeEnumDATABASE         AssetDtoDisplayedTypeEnum = "DATABASE"
	AssetDtoDisplayedTypeEnumEXTERNALTABLE    AssetDtoDisplayedTypeEnum = "EXTERNAL_TABLE"
	AssetDtoDisplayedTypeEnumFIELD            AssetDtoDisplayedTypeEnum = "FIELD"
	AssetDtoDisplayedTypeEnumMATERIALIZEDVIEW AssetDtoDisplayedTypeEnum = "MATERIALIZED_VIEW"
	AssetDtoDisplayedTypeEnumMODEL            AssetDtoDisplayedTypeEnum = "MODEL"
	AssetDtoDisplayedTypeEnumMONITOR          AssetDtoDisplayedTypeEnum = "MONITOR"
	AssetDtoDisplayedTypeEnumNONE             AssetDtoDisplayedTypeEnum = "NONE"
	AssetDtoDisplayedTypeEnumORCHESTRATOR     AssetDtoDisplayedTypeEnum = "ORCHESTRATOR"
	AssetDtoDisplayedTypeEnumSCHEMA           AssetDtoDisplayedTypeEnum = "SCHEMA"
	AssetDtoDisplayedTypeEnumSNOWFLAKESTREAM  AssetDtoDisplayedTypeEnum = "SNOWFLAKE_STREAM"
	AssetDtoDisplayedTypeEnumTABLE            AssetDtoDisplayedTypeEnum = "TABLE"
	AssetDtoDisplayedTypeEnumTRANSFORMATION   AssetDtoDisplayedTypeEnum = "TRANSFORMATION"
	AssetDtoDisplayedTypeEnumVIEW             AssetDtoDisplayedTypeEnum = "VIEW"
)

// Defines values for AssetDtoEntityType.
const (
	AssetDtoEntityTypeACCESSTOKEN            AssetDtoEntityType = "ACCESS_TOKEN"
	AssetDtoEntityTypeALERTINGHOOK           AssetDtoEntityType = "ALERTING_HOOK"
	AssetDtoEntityTypeCHART                  AssetDtoEntityType = "CHART"
	AssetDtoEntityTypeCOLLECTION             AssetDtoEntityType = "COLLECTION"
	AssetDtoEntityTypeCONFIG                 AssetDtoEntityType = "CONFIG"
	AssetDtoEntityTypeDAG                    AssetDtoEntityType = "DAG"
	AssetDtoEntityTypeDASHBOARD              AssetDtoEntityType = "DASHBOARD"
	AssetDtoEntityTypeDATASET                AssetDtoEntityType = "DATASET"
	AssetDtoEntityTypeDATASETFIELD           AssetDtoEntityType = "DATASET_FIELD"
	AssetDtoEntityTypeDATASOURCE             AssetDtoEntityType = "DATASOURCE"
	AssetDtoEntityTypeDATASOURCEINGESTIONRUN AssetDtoEntityType = "DATASOURCE_INGESTION_RUN"
	AssetDtoEntityTypeDOMAIN                 AssetDtoEntityType = "DOMAIN"
	AssetDtoEntityTypeINCIDENT               AssetDtoEntityType = "INCIDENT"
	AssetDtoEntityTypeRULERUN                AssetDtoEntityType = "RULE_RUN"
	AssetDtoEntityTypeSIFFLETRULE            AssetDtoEntityType = "SIFFLET_RULE"
	AssetDtoEntityTypeTAG                    AssetDtoEntityType = "TAG"
	AssetDtoEntityTypeUSER                   AssetDtoEntityType = "USER"
)

// Defines values for AssetDtoQualityStatus.
const (
	AssetDtoQualityStatusATRISK       AssetDtoQualityStatus = "AT_RISK"
	AssetDtoQualityStatusCRITICAL     AssetDtoQualityStatus = "CRITICAL"
	AssetDtoQualityStatusHEALTHY      AssetDtoQualityStatus = "HEALTHY"
	AssetDtoQualityStatusNOTSUPPORTED AssetDtoQualityStatus = "NOT_SUPPORTED"
	AssetDtoQualityStatusUNMONITORED  AssetDtoQualityStatus = "UNMONITORED"
)

// Defines values for AssetLightDtoEntityType.
const (
	AssetLightDtoEntityTypeACCESSTOKEN            AssetLightDtoEntityType = "ACCESS_TOKEN"
	AssetLightDtoEntityTypeALERTINGHOOK           AssetLightDtoEntityType = "ALERTING_HOOK"
	AssetLightDtoEntityTypeCHART                  AssetLightDtoEntityType = "CHART"
	AssetLightDtoEntityTypeCOLLECTION             AssetLightDtoEntityType = "COLLECTION"
	AssetLightDtoEntityTypeCONFIG                 AssetLightDtoEntityType = "CONFIG"
	AssetLightDtoEntityTypeDAG                    AssetLightDtoEntityType = "DAG"
	AssetLightDtoEntityTypeDASHBOARD              AssetLightDtoEntityType = "DASHBOARD"
	AssetLightDtoEntityTypeDATASET                AssetLightDtoEntityType = "DATASET"
	AssetLightDtoEntityTypeDATASETFIELD           AssetLightDtoEntityType = "DATASET_FIELD"
	AssetLightDtoEntityTypeDATASOURCE             AssetLightDtoEntityType = "DATASOURCE"
	AssetLightDtoEntityTypeDATASOURCEINGESTIONRUN AssetLightDtoEntityType = "DATASOURCE_INGESTION_RUN"
	AssetLightDtoEntityTypeDOMAIN                 AssetLightDtoEntityType = "DOMAIN"
	AssetLightDtoEntityTypeINCIDENT               AssetLightDtoEntityType = "INCIDENT"
	AssetLightDtoEntityTypeRULERUN                AssetLightDtoEntityType = "RULE_RUN"
	AssetLightDtoEntityTypeSIFFLETRULE            AssetLightDtoEntityType = "SIFFLET_RULE"
	AssetLightDtoEntityTypeTAG                    AssetLightDtoEntityType = "TAG"
	AssetLightDtoEntityTypeUSER                   AssetLightDtoEntityType = "USER"
)

// Defines values for AssetOrchestratorDtoDatasourceType.
const (
	AssetOrchestratorDtoDatasourceTypeAIRFLOW    AssetOrchestratorDtoDatasourceType = "AIRFLOW"
	AssetOrchestratorDtoDatasourceTypeATHENA     AssetOrchestratorDtoDatasourceType = "ATHENA"
	AssetOrchestratorDtoDatasourceTypeBIGQUERY   AssetOrchestratorDtoDatasourceType = "BIGQUERY"
	AssetOrchestratorDtoDatasourceTypeDATABRICKS AssetOrchestratorDtoDatasourceType = "DATABRICKS"
	AssetOrchestratorDtoDatasourceTypeDBT        AssetOrchestratorDtoDatasourceType = "DBT"
	AssetOrchestratorDtoDatasourceTypeDBTCLOUD   AssetOrchestratorDtoDatasourceType = "DBTCLOUD"
	AssetOrchestratorDtoDatasourceTypeFIREBOLT   AssetOrchestratorDtoDatasourceType = "FIREBOLT"
	AssetOrchestratorDtoDatasourceTypeFIVETRAN   AssetOrchestratorDtoDatasourceType = "FIVETRAN"
	AssetOrchestratorDtoDatasourceTypeH2         AssetOrchestratorDtoDatasourceType = "H2"
	AssetOrchestratorDtoDatasourceTypeHIVE       AssetOrchestratorDtoDatasourceType = "HIVE"
	AssetOrchestratorDtoDatasourceTypeLOOKER     AssetOrchestratorDtoDatasourceType = "LOOKER"
	AssetOrchestratorDtoDatasourceTypeMSSQL      AssetOrchestratorDtoDatasourceType = "MSSQL"
	AssetOrchestratorDtoDatasourceTypeMYSQL      AssetOrchestratorDtoDatasourceType = "MYSQL"
	AssetOrchestratorDtoDatasourceTypeORACLE     AssetOrchestratorDtoDatasourceType = "ORACLE"
	AssetOrchestratorDtoDatasourceTypePOSTGRES   AssetOrchestratorDtoDatasourceType = "POSTGRES"
	AssetOrchestratorDtoDatasourceTypePOWERBI    AssetOrchestratorDtoDatasourceType = "POWER_BI"
	AssetOrchestratorDtoDatasourceTypeQUICKSIGHT AssetOrchestratorDtoDatasourceType = "QUICKSIGHT"
	AssetOrchestratorDtoDatasourceTypeREDSHIFT   AssetOrchestratorDtoDatasourceType = "REDSHIFT"
	AssetOrchestratorDtoDatasourceTypeSNOWFLAKE  AssetOrchestratorDtoDatasourceType = "SNOWFLAKE"
	AssetOrchestratorDtoDatasourceTypeTABLEAU    AssetOrchestratorDtoDatasourceType = "TABLEAU"
	AssetOrchestratorDtoDatasourceTypeUNKNOWN    AssetOrchestratorDtoDatasourceType = "_UNKNOWN_"
)

// Defines values for AssetPropertiesType.
const (
	AssetPropertiesTypeBIGQUERYDATASETREF       AssetPropertiesType = "BIGQUERY_DATASET_REF"
	AssetPropertiesTypeBIGQUERYEXTERNALTABLE    AssetPropertiesType = "BIGQUERY_EXTERNAL_TABLE"
	AssetPropertiesTypeBIGQUERYMATERIALIZEDVIEW AssetPropertiesType = "BIGQUERY_MATERIALIZED_VIEW"
	AssetPropertiesTypeBIGQUERYTABLE            AssetPropertiesType = "BIGQUERY_TABLE"
	AssetPropertiesTypeBIGQUERYVIEW             AssetPropertiesType = "BIGQUERY_VIEW"
	AssetPropertiesTypeDATABRICKSSTREAMINGTABLE AssetPropertiesType = "DATABRICKS_STREAMING_TABLE"
	AssetPropertiesTypeDATABRICKSUNKNOWN        AssetPropertiesType = "DATABRICKS_UNKNOWN"
	AssetPropertiesTypeDBTEPHEMERALREF          AssetPropertiesType = "DBT_EPHEMERAL_REF"
	AssetPropertiesTypeDBTMODEL                 AssetPropertiesType = "DBT_MODEL"
	AssetPropertiesTypeDBTSEED                  AssetPropertiesType = "DBT_SEED"
	AssetPropertiesTypeDBTSOURCEDATASETREF      AssetPropertiesType = "DBT_SOURCE_DATASET_REF"
	AssetPropertiesTypeDBTTABLEREF              AssetPropertiesType = "DBT_TABLE_REF"
	AssetPropertiesTypeDBTUNKNOWN               AssetPropertiesType = "DBT_UNKNOWN"
	AssetPropertiesTypeDBTVIEWREF               AssetPropertiesType = "DBT_VIEW_REF"
	AssetPropertiesTypeHIVEDATASETREF           AssetPropertiesType = "HIVE_DATASET_REF"
	AssetPropertiesTypeHIVEEXTERNALTABLE        AssetPropertiesType = "HIVE_EXTERNAL_TABLE"
	AssetPropertiesTypeHIVEHDFSSTORAGE          AssetPropertiesType = "HIVE_HDFS_STORAGE"
	AssetPropertiesTypeHIVEHIVEPROCESS          AssetPropertiesType = "HIVE_HIVE_PROCESS"
	AssetPropertiesTypeHIVEMANAGEDTABLE         AssetPropertiesType = "HIVE_MANAGED_TABLE"
	AssetPropertiesTypeHIVESPARKPROCESS         AssetPropertiesType = "HIVE_SPARK_PROCESS"
	AssetPropertiesTypeHIVEUNKNOWN              AssetPropertiesType = "HIVE_UNKNOWN"
	AssetPropertiesTypeHIVEUNKNOWNPROCESS       AssetPropertiesType = "HIVE_UNKNOWN_PROCESS"
	AssetPropertiesTypeHIVEVIRTUALVIEW          AssetPropertiesType = "HIVE_VIRTUAL_VIEW"
	AssetPropertiesTypeJDBCDATASET              AssetPropertiesType = "JDBC_DATASET"
	AssetPropertiesTypeJDBCDATASETREF           AssetPropertiesType = "JDBC_DATASET_REF"
	AssetPropertiesTypeJDBCEXTERNALTABLE        AssetPropertiesType = "JDBC_EXTERNAL_TABLE"
	AssetPropertiesTypeJDBCSNOWFLAKESTREAM      AssetPropertiesType = "JDBC_SNOWFLAKE_STREAM"
	AssetPropertiesTypeJDBCTABLE                AssetPropertiesType = "JDBC_TABLE"
	AssetPropertiesTypeJDBCVIEW                 AssetPropertiesType = "JDBC_VIEW"
	AssetPropertiesTypeLOOKERQUERY              AssetPropertiesType = "LOOKER_QUERY"
	AssetPropertiesTypeLOOKERSQLTABLE           AssetPropertiesType = "LOOKER_SQL_TABLE"
	AssetPropertiesTypeLOOKERVIEW               AssetPropertiesType = "LOOKER_VIEW"
	AssetPropertiesTypePOWERBITABLEREF          AssetPropertiesType = "POWERBI_TABLE_REF"
	AssetPropertiesTypeQUICKSIGHTTABLEREF       AssetPropertiesType = "QUICKSIGHT_TABLE_REF"
	AssetPropertiesTypeSTORAGEBUCKETGCP         AssetPropertiesType = "STORAGE_BUCKET_GCP"
	AssetPropertiesTypeSTORAGEBUCKETS3          AssetPropertiesType = "STORAGE_BUCKET_S3"
	AssetPropertiesTypeSTORAGEGOOGLEDRIVE       AssetPropertiesType = "STORAGE_GOOGLE_DRIVE"
	AssetPropertiesTypeTABLEAUDATABASETABLE     AssetPropertiesType = "TABLEAU_DATABASE_TABLE"
	AssetPropertiesTypeTABLEAUQUERY             AssetPropertiesType = "TABLEAU_QUERY"
)

// Defines values for AssetSearchFilterElementDtoId.
const (
	AssetSearchFilterElementDtoIdDASHBOARD    AssetSearchFilterElementDtoId = "DASHBOARD"
	AssetSearchFilterElementDtoIdMONITOR      AssetSearchFilterElementDtoId = "MONITOR"
	AssetSearchFilterElementDtoIdPIPELINE     AssetSearchFilterElementDtoId = "PIPELINE"
	AssetSearchFilterElementDtoIdTABLEANDVIEW AssetSearchFilterElementDtoId = "TABLE_AND_VIEW"
)

// Defines values for AssetUsageDtoQualification.
const (
	AssetUsageDtoQualificationHIGH        AssetUsageDtoQualification = "HIGH"
	AssetUsageDtoQualificationLOW         AssetUsageDtoQualification = "LOW"
	AssetUsageDtoQualificationMEDIUM      AssetUsageDtoQualification = "MEDIUM"
	AssetUsageDtoQualificationUNSUPPORTED AssetUsageDtoQualification = "UNSUPPORTED"
)

// Defines values for AssetUsageDtoReadType.
const (
	QUERIES AssetUsageDtoReadType = "QUERIES"
	VIEWS   AssetUsageDtoReadType = "VIEWS"
)

// Defines values for BaseSearchFilterDtoType.
const (
	BaseSearchFilterDtoTypeASSETTYPE    BaseSearchFilterDtoType = "ASSET_TYPE"
	BaseSearchFilterDtoTypeHEALTHSTATUS BaseSearchFilterDtoType = "HEALTH_STATUS"
	BaseSearchFilterDtoTypePLATFORM     BaseSearchFilterDtoType = "PLATFORM"
	BaseSearchFilterDtoTypeTAG          BaseSearchFilterDtoType = "TAG"
	BaseSearchFilterDtoTypeTERM         BaseSearchFilterDtoType = "TERM"
	BaseSearchFilterDtoTypeUSAGE        BaseSearchFilterDtoType = "USAGE"
)

// Defines values for BigQueryPartitionedTablePropertiesType.
const (
	BigQueryPartitionedTablePropertiesTypeBIGQUERYDATASETREF       BigQueryPartitionedTablePropertiesType = "BIGQUERY_DATASET_REF"
	BigQueryPartitionedTablePropertiesTypeBIGQUERYEXTERNALTABLE    BigQueryPartitionedTablePropertiesType = "BIGQUERY_EXTERNAL_TABLE"
	BigQueryPartitionedTablePropertiesTypeBIGQUERYMATERIALIZEDVIEW BigQueryPartitionedTablePropertiesType = "BIGQUERY_MATERIALIZED_VIEW"
	BigQueryPartitionedTablePropertiesTypeBIGQUERYTABLE            BigQueryPartitionedTablePropertiesType = "BIGQUERY_TABLE"
	BigQueryPartitionedTablePropertiesTypeBIGQUERYVIEW             BigQueryPartitionedTablePropertiesType = "BIGQUERY_VIEW"
	BigQueryPartitionedTablePropertiesTypeDATABRICKSSTREAMINGTABLE BigQueryPartitionedTablePropertiesType = "DATABRICKS_STREAMING_TABLE"
	BigQueryPartitionedTablePropertiesTypeDATABRICKSUNKNOWN        BigQueryPartitionedTablePropertiesType = "DATABRICKS_UNKNOWN"
	BigQueryPartitionedTablePropertiesTypeDBTEPHEMERALREF          BigQueryPartitionedTablePropertiesType = "DBT_EPHEMERAL_REF"
	BigQueryPartitionedTablePropertiesTypeDBTMODEL                 BigQueryPartitionedTablePropertiesType = "DBT_MODEL"
	BigQueryPartitionedTablePropertiesTypeDBTSEED                  BigQueryPartitionedTablePropertiesType = "DBT_SEED"
	BigQueryPartitionedTablePropertiesTypeDBTSOURCEDATASETREF      BigQueryPartitionedTablePropertiesType = "DBT_SOURCE_DATASET_REF"
	BigQueryPartitionedTablePropertiesTypeDBTTABLEREF              BigQueryPartitionedTablePropertiesType = "DBT_TABLE_REF"
	BigQueryPartitionedTablePropertiesTypeDBTUNKNOWN               BigQueryPartitionedTablePropertiesType = "DBT_UNKNOWN"
	BigQueryPartitionedTablePropertiesTypeDBTVIEWREF               BigQueryPartitionedTablePropertiesType = "DBT_VIEW_REF"
	BigQueryPartitionedTablePropertiesTypeHIVEDATASETREF           BigQueryPartitionedTablePropertiesType = "HIVE_DATASET_REF"
	BigQueryPartitionedTablePropertiesTypeHIVEEXTERNALTABLE        BigQueryPartitionedTablePropertiesType = "HIVE_EXTERNAL_TABLE"
	BigQueryPartitionedTablePropertiesTypeHIVEHDFSSTORAGE          BigQueryPartitionedTablePropertiesType = "HIVE_HDFS_STORAGE"
	BigQueryPartitionedTablePropertiesTypeHIVEHIVEPROCESS          BigQueryPartitionedTablePropertiesType = "HIVE_HIVE_PROCESS"
	BigQueryPartitionedTablePropertiesTypeHIVEMANAGEDTABLE         BigQueryPartitionedTablePropertiesType = "HIVE_MANAGED_TABLE"
	BigQueryPartitionedTablePropertiesTypeHIVESPARKPROCESS         BigQueryPartitionedTablePropertiesType = "HIVE_SPARK_PROCESS"
	BigQueryPartitionedTablePropertiesTypeHIVEUNKNOWN              BigQueryPartitionedTablePropertiesType = "HIVE_UNKNOWN"
	BigQueryPartitionedTablePropertiesTypeHIVEUNKNOWNPROCESS       BigQueryPartitionedTablePropertiesType = "HIVE_UNKNOWN_PROCESS"
	BigQueryPartitionedTablePropertiesTypeHIVEVIRTUALVIEW          BigQueryPartitionedTablePropertiesType = "HIVE_VIRTUAL_VIEW"
	BigQueryPartitionedTablePropertiesTypeJDBCDATASET              BigQueryPartitionedTablePropertiesType = "JDBC_DATASET"
	BigQueryPartitionedTablePropertiesTypeJDBCDATASETREF           BigQueryPartitionedTablePropertiesType = "JDBC_DATASET_REF"
	BigQueryPartitionedTablePropertiesTypeJDBCEXTERNALTABLE        BigQueryPartitionedTablePropertiesType = "JDBC_EXTERNAL_TABLE"
	BigQueryPartitionedTablePropertiesTypeJDBCSNOWFLAKESTREAM      BigQueryPartitionedTablePropertiesType = "JDBC_SNOWFLAKE_STREAM"
	BigQueryPartitionedTablePropertiesTypeJDBCTABLE                BigQueryPartitionedTablePropertiesType = "JDBC_TABLE"
	BigQueryPartitionedTablePropertiesTypeJDBCVIEW                 BigQueryPartitionedTablePropertiesType = "JDBC_VIEW"
	BigQueryPartitionedTablePropertiesTypeLOOKERQUERY              BigQueryPartitionedTablePropertiesType = "LOOKER_QUERY"
	BigQueryPartitionedTablePropertiesTypeLOOKERSQLTABLE           BigQueryPartitionedTablePropertiesType = "LOOKER_SQL_TABLE"
	BigQueryPartitionedTablePropertiesTypeLOOKERVIEW               BigQueryPartitionedTablePropertiesType = "LOOKER_VIEW"
	BigQueryPartitionedTablePropertiesTypePOWERBITABLEREF          BigQueryPartitionedTablePropertiesType = "POWERBI_TABLE_REF"
	BigQueryPartitionedTablePropertiesTypeQUICKSIGHTTABLEREF       BigQueryPartitionedTablePropertiesType = "QUICKSIGHT_TABLE_REF"
	BigQueryPartitionedTablePropertiesTypeSTORAGEBUCKETGCP         BigQueryPartitionedTablePropertiesType = "STORAGE_BUCKET_GCP"
	BigQueryPartitionedTablePropertiesTypeSTORAGEBUCKETS3          BigQueryPartitionedTablePropertiesType = "STORAGE_BUCKET_S3"
	BigQueryPartitionedTablePropertiesTypeSTORAGEGOOGLEDRIVE       BigQueryPartitionedTablePropertiesType = "STORAGE_GOOGLE_DRIVE"
	BigQueryPartitionedTablePropertiesTypeTABLEAUDATABASETABLE     BigQueryPartitionedTablePropertiesType = "TABLEAU_DATABASE_TABLE"
	BigQueryPartitionedTablePropertiesTypeTABLEAUQUERY             BigQueryPartitionedTablePropertiesType = "TABLEAU_QUERY"
)

// Defines values for BigQueryPartitioningPropertiesPartitioningType.
const (
	INGESTIONTIME  BigQueryPartitioningPropertiesPartitioningType = "INGESTION_TIME"
	INTEGERRANGE   BigQueryPartitioningPropertiesPartitioningType = "INTEGER_RANGE"
	NOPARTITIONING BigQueryPartitioningPropertiesPartitioningType = "NO_PARTITIONING"
	TIMEUNITCOLUMN BigQueryPartitioningPropertiesPartitioningType = "TIME_UNIT_COLUMN"
)

// Defines values for DagAssetOverviewType.
const (
	AIRFLOWDAG    DagAssetOverviewType = "AIRFLOW_DAG"
	AIRFLOWDAGREF DagAssetOverviewType = "AIRFLOW_DAG_REF"
	OTHERREF      DagAssetOverviewType = "OTHER_REF"
)

// Defines values for DagDetailsDtoDatasourceType.
const (
	DagDetailsDtoDatasourceTypeAIRFLOW    DagDetailsDtoDatasourceType = "AIRFLOW"
	DagDetailsDtoDatasourceTypeATHENA     DagDetailsDtoDatasourceType = "ATHENA"
	DagDetailsDtoDatasourceTypeBIGQUERY   DagDetailsDtoDatasourceType = "BIGQUERY"
	DagDetailsDtoDatasourceTypeDATABRICKS DagDetailsDtoDatasourceType = "DATABRICKS"
	DagDetailsDtoDatasourceTypeDBT        DagDetailsDtoDatasourceType = "DBT"
	DagDetailsDtoDatasourceTypeDBTCLOUD   DagDetailsDtoDatasourceType = "DBTCLOUD"
	DagDetailsDtoDatasourceTypeFIREBOLT   DagDetailsDtoDatasourceType = "FIREBOLT"
	DagDetailsDtoDatasourceTypeFIVETRAN   DagDetailsDtoDatasourceType = "FIVETRAN"
	DagDetailsDtoDatasourceTypeH2         DagDetailsDtoDatasourceType = "H2"
	DagDetailsDtoDatasourceTypeHIVE       DagDetailsDtoDatasourceType = "HIVE"
	DagDetailsDtoDatasourceTypeLOOKER     DagDetailsDtoDatasourceType = "LOOKER"
	DagDetailsDtoDatasourceTypeMSSQL      DagDetailsDtoDatasourceType = "MSSQL"
	DagDetailsDtoDatasourceTypeMYSQL      DagDetailsDtoDatasourceType = "MYSQL"
	DagDetailsDtoDatasourceTypeORACLE     DagDetailsDtoDatasourceType = "ORACLE"
	DagDetailsDtoDatasourceTypePOSTGRES   DagDetailsDtoDatasourceType = "POSTGRES"
	DagDetailsDtoDatasourceTypePOWERBI    DagDetailsDtoDatasourceType = "POWER_BI"
	DagDetailsDtoDatasourceTypeQUICKSIGHT DagDetailsDtoDatasourceType = "QUICKSIGHT"
	DagDetailsDtoDatasourceTypeREDSHIFT   DagDetailsDtoDatasourceType = "REDSHIFT"
	DagDetailsDtoDatasourceTypeSNOWFLAKE  DagDetailsDtoDatasourceType = "SNOWFLAKE"
	DagDetailsDtoDatasourceTypeTABLEAU    DagDetailsDtoDatasourceType = "TABLEAU"
	DagDetailsDtoDatasourceTypeUNKNOWN    DagDetailsDtoDatasourceType = "_UNKNOWN_"
)

// Defines values for DashboardAssetOverviewType.
const (
	LOOKERDASHBOARD     DashboardAssetOverviewType = "LOOKER_DASHBOARD"
	POWERBIDASHBOARD    DashboardAssetOverviewType = "POWERBI_DASHBOARD"
	POWERBIREPORT       DashboardAssetOverviewType = "POWERBI_REPORT"
	QUICKSIGHTANALYSIS  DashboardAssetOverviewType = "QUICKSIGHT_ANALYSIS"
	QUICKSIGHTDASHBOARD DashboardAssetOverviewType = "QUICKSIGHT_DASHBOARD"
	TABLEAUDASHBOARD    DashboardAssetOverviewType = "TABLEAU_DASHBOARD"
)

// Defines values for DatasetAssetOverviewType.
const (
	DatasetAssetOverviewTypeBIGQUERYDATASETREF       DatasetAssetOverviewType = "BIGQUERY_DATASET_REF"
	DatasetAssetOverviewTypeBIGQUERYEXTERNALTABLE    DatasetAssetOverviewType = "BIGQUERY_EXTERNAL_TABLE"
	DatasetAssetOverviewTypeBIGQUERYMATERIALIZEDVIEW DatasetAssetOverviewType = "BIGQUERY_MATERIALIZED_VIEW"
	DatasetAssetOverviewTypeBIGQUERYTABLE            DatasetAssetOverviewType = "BIGQUERY_TABLE"
	DatasetAssetOverviewTypeBIGQUERYVIEW             DatasetAssetOverviewType = "BIGQUERY_VIEW"
	DatasetAssetOverviewTypeDATABRICKSSTREAMINGTABLE DatasetAssetOverviewType = "DATABRICKS_STREAMING_TABLE"
	DatasetAssetOverviewTypeDATABRICKSUNKNOWN        DatasetAssetOverviewType = "DATABRICKS_UNKNOWN"
	DatasetAssetOverviewTypeDBTEPHEMERALREF          DatasetAssetOverviewType = "DBT_EPHEMERAL_REF"
	DatasetAssetOverviewTypeDBTMODEL                 DatasetAssetOverviewType = "DBT_MODEL"
	DatasetAssetOverviewTypeDBTSEED                  DatasetAssetOverviewType = "DBT_SEED"
	DatasetAssetOverviewTypeDBTSOURCEDATASETREF      DatasetAssetOverviewType = "DBT_SOURCE_DATASET_REF"
	DatasetAssetOverviewTypeDBTTABLEREF              DatasetAssetOverviewType = "DBT_TABLE_REF"
	DatasetAssetOverviewTypeDBTUNKNOWN               DatasetAssetOverviewType = "DBT_UNKNOWN"
	DatasetAssetOverviewTypeDBTVIEWREF               DatasetAssetOverviewType = "DBT_VIEW_REF"
	DatasetAssetOverviewTypeHIVEDATASETREF           DatasetAssetOverviewType = "HIVE_DATASET_REF"
	DatasetAssetOverviewTypeHIVEEXTERNALTABLE        DatasetAssetOverviewType = "HIVE_EXTERNAL_TABLE"
	DatasetAssetOverviewTypeHIVEHDFSSTORAGE          DatasetAssetOverviewType = "HIVE_HDFS_STORAGE"
	DatasetAssetOverviewTypeHIVEHIVEPROCESS          DatasetAssetOverviewType = "HIVE_HIVE_PROCESS"
	DatasetAssetOverviewTypeHIVEMANAGEDTABLE         DatasetAssetOverviewType = "HIVE_MANAGED_TABLE"
	DatasetAssetOverviewTypeHIVESPARKPROCESS         DatasetAssetOverviewType = "HIVE_SPARK_PROCESS"
	DatasetAssetOverviewTypeHIVEUNKNOWN              DatasetAssetOverviewType = "HIVE_UNKNOWN"
	DatasetAssetOverviewTypeHIVEUNKNOWNPROCESS       DatasetAssetOverviewType = "HIVE_UNKNOWN_PROCESS"
	DatasetAssetOverviewTypeHIVEVIRTUALVIEW          DatasetAssetOverviewType = "HIVE_VIRTUAL_VIEW"
	DatasetAssetOverviewTypeJDBCDATASET              DatasetAssetOverviewType = "JDBC_DATASET"
	DatasetAssetOverviewTypeJDBCDATASETREF           DatasetAssetOverviewType = "JDBC_DATASET_REF"
	DatasetAssetOverviewTypeJDBCEXTERNALTABLE        DatasetAssetOverviewType = "JDBC_EXTERNAL_TABLE"
	DatasetAssetOverviewTypeJDBCSNOWFLAKESTREAM      DatasetAssetOverviewType = "JDBC_SNOWFLAKE_STREAM"
	DatasetAssetOverviewTypeJDBCTABLE                DatasetAssetOverviewType = "JDBC_TABLE"
	DatasetAssetOverviewTypeJDBCVIEW                 DatasetAssetOverviewType = "JDBC_VIEW"
	DatasetAssetOverviewTypeLOOKERQUERY              DatasetAssetOverviewType = "LOOKER_QUERY"
	DatasetAssetOverviewTypeLOOKERSQLTABLE           DatasetAssetOverviewType = "LOOKER_SQL_TABLE"
	DatasetAssetOverviewTypeLOOKERVIEW               DatasetAssetOverviewType = "LOOKER_VIEW"
	DatasetAssetOverviewTypePOWERBITABLEREF          DatasetAssetOverviewType = "POWERBI_TABLE_REF"
	DatasetAssetOverviewTypeQUICKSIGHTTABLEREF       DatasetAssetOverviewType = "QUICKSIGHT_TABLE_REF"
	DatasetAssetOverviewTypeSTORAGEBUCKETGCP         DatasetAssetOverviewType = "STORAGE_BUCKET_GCP"
	DatasetAssetOverviewTypeSTORAGEBUCKETS3          DatasetAssetOverviewType = "STORAGE_BUCKET_S3"
	DatasetAssetOverviewTypeSTORAGEGOOGLEDRIVE       DatasetAssetOverviewType = "STORAGE_GOOGLE_DRIVE"
	DatasetAssetOverviewTypeTABLEAUDATABASETABLE     DatasetAssetOverviewType = "TABLEAU_DATABASE_TABLE"
	DatasetAssetOverviewTypeTABLEAUQUERY             DatasetAssetOverviewType = "TABLEAU_QUERY"
)

// Defines values for DatasetDetailsDtoDatasourceType.
const (
	DatasetDetailsDtoDatasourceTypeAIRFLOW    DatasetDetailsDtoDatasourceType = "AIRFLOW"
	DatasetDetailsDtoDatasourceTypeATHENA     DatasetDetailsDtoDatasourceType = "ATHENA"
	DatasetDetailsDtoDatasourceTypeBIGQUERY   DatasetDetailsDtoDatasourceType = "BIGQUERY"
	DatasetDetailsDtoDatasourceTypeDATABRICKS DatasetDetailsDtoDatasourceType = "DATABRICKS"
	DatasetDetailsDtoDatasourceTypeDBT        DatasetDetailsDtoDatasourceType = "DBT"
	DatasetDetailsDtoDatasourceTypeDBTCLOUD   DatasetDetailsDtoDatasourceType = "DBTCLOUD"
	DatasetDetailsDtoDatasourceTypeFIREBOLT   DatasetDetailsDtoDatasourceType = "FIREBOLT"
	DatasetDetailsDtoDatasourceTypeFIVETRAN   DatasetDetailsDtoDatasourceType = "FIVETRAN"
	DatasetDetailsDtoDatasourceTypeH2         DatasetDetailsDtoDatasourceType = "H2"
	DatasetDetailsDtoDatasourceTypeHIVE       DatasetDetailsDtoDatasourceType = "HIVE"
	DatasetDetailsDtoDatasourceTypeLOOKER     DatasetDetailsDtoDatasourceType = "LOOKER"
	DatasetDetailsDtoDatasourceTypeMSSQL      DatasetDetailsDtoDatasourceType = "MSSQL"
	DatasetDetailsDtoDatasourceTypeMYSQL      DatasetDetailsDtoDatasourceType = "MYSQL"
	DatasetDetailsDtoDatasourceTypeORACLE     DatasetDetailsDtoDatasourceType = "ORACLE"
	DatasetDetailsDtoDatasourceTypePOSTGRES   DatasetDetailsDtoDatasourceType = "POSTGRES"
	DatasetDetailsDtoDatasourceTypePOWERBI    DatasetDetailsDtoDatasourceType = "POWER_BI"
	DatasetDetailsDtoDatasourceTypeQUICKSIGHT DatasetDetailsDtoDatasourceType = "QUICKSIGHT"
	DatasetDetailsDtoDatasourceTypeREDSHIFT   DatasetDetailsDtoDatasourceType = "REDSHIFT"
	DatasetDetailsDtoDatasourceTypeSNOWFLAKE  DatasetDetailsDtoDatasourceType = "SNOWFLAKE"
	DatasetDetailsDtoDatasourceTypeTABLEAU    DatasetDetailsDtoDatasourceType = "TABLEAU"
	DatasetDetailsDtoDatasourceTypeUNKNOWN    DatasetDetailsDtoDatasourceType = "_UNKNOWN_"
)

// Defines values for DatasetDtoEntityType.
const (
	DatasetDtoEntityTypeACCESSTOKEN            DatasetDtoEntityType = "ACCESS_TOKEN"
	DatasetDtoEntityTypeALERTINGHOOK           DatasetDtoEntityType = "ALERTING_HOOK"
	DatasetDtoEntityTypeCHART                  DatasetDtoEntityType = "CHART"
	DatasetDtoEntityTypeCOLLECTION             DatasetDtoEntityType = "COLLECTION"
	DatasetDtoEntityTypeCONFIG                 DatasetDtoEntityType = "CONFIG"
	DatasetDtoEntityTypeDAG                    DatasetDtoEntityType = "DAG"
	DatasetDtoEntityTypeDASHBOARD              DatasetDtoEntityType = "DASHBOARD"
	DatasetDtoEntityTypeDATASET                DatasetDtoEntityType = "DATASET"
	DatasetDtoEntityTypeDATASETFIELD           DatasetDtoEntityType = "DATASET_FIELD"
	DatasetDtoEntityTypeDATASOURCE             DatasetDtoEntityType = "DATASOURCE"
	DatasetDtoEntityTypeDATASOURCEINGESTIONRUN DatasetDtoEntityType = "DATASOURCE_INGESTION_RUN"
	DatasetDtoEntityTypeDOMAIN                 DatasetDtoEntityType = "DOMAIN"
	DatasetDtoEntityTypeINCIDENT               DatasetDtoEntityType = "INCIDENT"
	DatasetDtoEntityTypeRULERUN                DatasetDtoEntityType = "RULE_RUN"
	DatasetDtoEntityTypeSIFFLETRULE            DatasetDtoEntityType = "SIFFLET_RULE"
	DatasetDtoEntityTypeTAG                    DatasetDtoEntityType = "TAG"
	DatasetDtoEntityTypeUSER                   DatasetDtoEntityType = "USER"
)

// Defines values for DatasourceCatalogAssetDtoEntityType.
const (
	DatasourceCatalogAssetDtoEntityTypeACCESSTOKEN            DatasourceCatalogAssetDtoEntityType = "ACCESS_TOKEN"
	DatasourceCatalogAssetDtoEntityTypeALERTINGHOOK           DatasourceCatalogAssetDtoEntityType = "ALERTING_HOOK"
	DatasourceCatalogAssetDtoEntityTypeCHART                  DatasourceCatalogAssetDtoEntityType = "CHART"
	DatasourceCatalogAssetDtoEntityTypeCOLLECTION             DatasourceCatalogAssetDtoEntityType = "COLLECTION"
	DatasourceCatalogAssetDtoEntityTypeCONFIG                 DatasourceCatalogAssetDtoEntityType = "CONFIG"
	DatasourceCatalogAssetDtoEntityTypeDAG                    DatasourceCatalogAssetDtoEntityType = "DAG"
	DatasourceCatalogAssetDtoEntityTypeDASHBOARD              DatasourceCatalogAssetDtoEntityType = "DASHBOARD"
	DatasourceCatalogAssetDtoEntityTypeDATASET                DatasourceCatalogAssetDtoEntityType = "DATASET"
	DatasourceCatalogAssetDtoEntityTypeDATASETFIELD           DatasourceCatalogAssetDtoEntityType = "DATASET_FIELD"
	DatasourceCatalogAssetDtoEntityTypeDATASOURCE             DatasourceCatalogAssetDtoEntityType = "DATASOURCE"
	DatasourceCatalogAssetDtoEntityTypeDATASOURCEINGESTIONRUN DatasourceCatalogAssetDtoEntityType = "DATASOURCE_INGESTION_RUN"
	DatasourceCatalogAssetDtoEntityTypeDOMAIN                 DatasourceCatalogAssetDtoEntityType = "DOMAIN"
	DatasourceCatalogAssetDtoEntityTypeINCIDENT               DatasourceCatalogAssetDtoEntityType = "INCIDENT"
	DatasourceCatalogAssetDtoEntityTypeRULERUN                DatasourceCatalogAssetDtoEntityType = "RULE_RUN"
	DatasourceCatalogAssetDtoEntityTypeSIFFLETRULE            DatasourceCatalogAssetDtoEntityType = "SIFFLET_RULE"
	DatasourceCatalogAssetDtoEntityTypeTAG                    DatasourceCatalogAssetDtoEntityType = "TAG"
	DatasourceCatalogAssetDtoEntityTypeUSER                   DatasourceCatalogAssetDtoEntityType = "USER"
)

// Defines values for DatasourceDtoEntityType.
const (
	DatasourceDtoEntityTypeACCESSTOKEN            DatasourceDtoEntityType = "ACCESS_TOKEN"
	DatasourceDtoEntityTypeALERTINGHOOK           DatasourceDtoEntityType = "ALERTING_HOOK"
	DatasourceDtoEntityTypeCHART                  DatasourceDtoEntityType = "CHART"
	DatasourceDtoEntityTypeCOLLECTION             DatasourceDtoEntityType = "COLLECTION"
	DatasourceDtoEntityTypeCONFIG                 DatasourceDtoEntityType = "CONFIG"
	DatasourceDtoEntityTypeDAG                    DatasourceDtoEntityType = "DAG"
	DatasourceDtoEntityTypeDASHBOARD              DatasourceDtoEntityType = "DASHBOARD"
	DatasourceDtoEntityTypeDATASET                DatasourceDtoEntityType = "DATASET"
	DatasourceDtoEntityTypeDATASETFIELD           DatasourceDtoEntityType = "DATASET_FIELD"
	DatasourceDtoEntityTypeDATASOURCE             DatasourceDtoEntityType = "DATASOURCE"
	DatasourceDtoEntityTypeDATASOURCEINGESTIONRUN DatasourceDtoEntityType = "DATASOURCE_INGESTION_RUN"
	DatasourceDtoEntityTypeDOMAIN                 DatasourceDtoEntityType = "DOMAIN"
	DatasourceDtoEntityTypeINCIDENT               DatasourceDtoEntityType = "INCIDENT"
	DatasourceDtoEntityTypeRULERUN                DatasourceDtoEntityType = "RULE_RUN"
	DatasourceDtoEntityTypeSIFFLETRULE            DatasourceDtoEntityType = "SIFFLET_RULE"
	DatasourceDtoEntityTypeTAG                    DatasourceDtoEntityType = "TAG"
	DatasourceDtoEntityTypeUSER                   DatasourceDtoEntityType = "USER"
)

// Defines values for DatasourceIngestionRunDtoLastStatus.
const (
	DatasourceIngestionRunDtoLastStatusFAILURE                         DatasourceIngestionRunDtoLastStatus = "FAILURE"
	DatasourceIngestionRunDtoLastStatusPENDING                         DatasourceIngestionRunDtoLastStatus = "PENDING"
	DatasourceIngestionRunDtoLastStatusRUNNING                         DatasourceIngestionRunDtoLastStatus = "RUNNING"
	DatasourceIngestionRunDtoLastStatusSKIPPEDDATASOURCEALREADYRUNNING DatasourceIngestionRunDtoLastStatus = "SKIPPED_DATASOURCE_ALREADY_RUNNING"
	DatasourceIngestionRunDtoLastStatusSUCCESS                         DatasourceIngestionRunDtoLastStatus = "SUCCESS"
)

// Defines values for DescriptionDtoSourceType.
const (
	DescriptionDtoSourceTypeAIRFLOW    DescriptionDtoSourceType = "AIRFLOW"
	DescriptionDtoSourceTypeATHENA     DescriptionDtoSourceType = "ATHENA"
	DescriptionDtoSourceTypeBIGQUERY   DescriptionDtoSourceType = "BIGQUERY"
	DescriptionDtoSourceTypeDATABRICKS DescriptionDtoSourceType = "DATABRICKS"
	DescriptionDtoSourceTypeDBT        DescriptionDtoSourceType = "DBT"
	DescriptionDtoSourceTypeDBTCLOUD   DescriptionDtoSourceType = "DBTCLOUD"
	DescriptionDtoSourceTypeFIREBOLT   DescriptionDtoSourceType = "FIREBOLT"
	DescriptionDtoSourceTypeFIVETRAN   DescriptionDtoSourceType = "FIVETRAN"
	DescriptionDtoSourceTypeH2         DescriptionDtoSourceType = "H2"
	DescriptionDtoSourceTypeHIVE       DescriptionDtoSourceType = "HIVE"
	DescriptionDtoSourceTypeLOOKER     DescriptionDtoSourceType = "LOOKER"
	DescriptionDtoSourceTypeMSSQL      DescriptionDtoSourceType = "MSSQL"
	DescriptionDtoSourceTypeMYSQL      DescriptionDtoSourceType = "MYSQL"
	DescriptionDtoSourceTypeORACLE     DescriptionDtoSourceType = "ORACLE"
	DescriptionDtoSourceTypePOSTGRES   DescriptionDtoSourceType = "POSTGRES"
	DescriptionDtoSourceTypePOWERBI    DescriptionDtoSourceType = "POWER_BI"
	DescriptionDtoSourceTypeQUICKSIGHT DescriptionDtoSourceType = "QUICKSIGHT"
	DescriptionDtoSourceTypeREDSHIFT   DescriptionDtoSourceType = "REDSHIFT"
	DescriptionDtoSourceTypeSNOWFLAKE  DescriptionDtoSourceType = "SNOWFLAKE"
	DescriptionDtoSourceTypeTABLEAU    DescriptionDtoSourceType = "TABLEAU"
	DescriptionDtoSourceTypeUNKNOWN    DescriptionDtoSourceType = "_UNKNOWN_"
)

// Defines values for EntityUrnType.
const (
	EntityUrnTypeACCESSTOKEN            EntityUrnType = "ACCESS_TOKEN"
	EntityUrnTypeALERTINGHOOK           EntityUrnType = "ALERTING_HOOK"
	EntityUrnTypeCHART                  EntityUrnType = "CHART"
	EntityUrnTypeCOLLECTION             EntityUrnType = "COLLECTION"
	EntityUrnTypeCONFIG                 EntityUrnType = "CONFIG"
	EntityUrnTypeDAG                    EntityUrnType = "DAG"
	EntityUrnTypeDASHBOARD              EntityUrnType = "DASHBOARD"
	EntityUrnTypeDATASET                EntityUrnType = "DATASET"
	EntityUrnTypeDATASETFIELD           EntityUrnType = "DATASET_FIELD"
	EntityUrnTypeDATASOURCE             EntityUrnType = "DATASOURCE"
	EntityUrnTypeDATASOURCEINGESTIONRUN EntityUrnType = "DATASOURCE_INGESTION_RUN"
	EntityUrnTypeDOMAIN                 EntityUrnType = "DOMAIN"
	EntityUrnTypeINCIDENT               EntityUrnType = "INCIDENT"
	EntityUrnTypeRULERUN                EntityUrnType = "RULE_RUN"
	EntityUrnTypeSIFFLETRULE            EntityUrnType = "SIFFLET_RULE"
	EntityUrnTypeTAG                    EntityUrnType = "TAG"
	EntityUrnTypeUSER                   EntityUrnType = "USER"
)

// Defines values for EventDtoType.
const (
	COMMENTCREATED   EventDtoType = "COMMENT_CREATED"
	INCIDENTCREATED  EventDtoType = "INCIDENT_CREATED"
	NEWFAILURE       EventDtoType = "NEW_FAILURE"
	NOTIFICATIONSENT EventDtoType = "NOTIFICATION_SENT"
	OWNERSASSIGNED   EventDtoType = "OWNERS_ASSIGNED"
	STATUSUPDATED    EventDtoType = "STATUS_UPDATED"
)

// Defines values for ExternalTablePropertiesType.
const (
	ExternalTablePropertiesTypeBIGQUERYDATASETREF       ExternalTablePropertiesType = "BIGQUERY_DATASET_REF"
	ExternalTablePropertiesTypeBIGQUERYEXTERNALTABLE    ExternalTablePropertiesType = "BIGQUERY_EXTERNAL_TABLE"
	ExternalTablePropertiesTypeBIGQUERYMATERIALIZEDVIEW ExternalTablePropertiesType = "BIGQUERY_MATERIALIZED_VIEW"
	ExternalTablePropertiesTypeBIGQUERYTABLE            ExternalTablePropertiesType = "BIGQUERY_TABLE"
	ExternalTablePropertiesTypeBIGQUERYVIEW             ExternalTablePropertiesType = "BIGQUERY_VIEW"
	ExternalTablePropertiesTypeDATABRICKSSTREAMINGTABLE ExternalTablePropertiesType = "DATABRICKS_STREAMING_TABLE"
	ExternalTablePropertiesTypeDATABRICKSUNKNOWN        ExternalTablePropertiesType = "DATABRICKS_UNKNOWN"
	ExternalTablePropertiesTypeDBTEPHEMERALREF          ExternalTablePropertiesType = "DBT_EPHEMERAL_REF"
	ExternalTablePropertiesTypeDBTMODEL                 ExternalTablePropertiesType = "DBT_MODEL"
	ExternalTablePropertiesTypeDBTSEED                  ExternalTablePropertiesType = "DBT_SEED"
	ExternalTablePropertiesTypeDBTSOURCEDATASETREF      ExternalTablePropertiesType = "DBT_SOURCE_DATASET_REF"
	ExternalTablePropertiesTypeDBTTABLEREF              ExternalTablePropertiesType = "DBT_TABLE_REF"
	ExternalTablePropertiesTypeDBTUNKNOWN               ExternalTablePropertiesType = "DBT_UNKNOWN"
	ExternalTablePropertiesTypeDBTVIEWREF               ExternalTablePropertiesType = "DBT_VIEW_REF"
	ExternalTablePropertiesTypeHIVEDATASETREF           ExternalTablePropertiesType = "HIVE_DATASET_REF"
	ExternalTablePropertiesTypeHIVEEXTERNALTABLE        ExternalTablePropertiesType = "HIVE_EXTERNAL_TABLE"
	ExternalTablePropertiesTypeHIVEHDFSSTORAGE          ExternalTablePropertiesType = "HIVE_HDFS_STORAGE"
	ExternalTablePropertiesTypeHIVEHIVEPROCESS          ExternalTablePropertiesType = "HIVE_HIVE_PROCESS"
	ExternalTablePropertiesTypeHIVEMANAGEDTABLE         ExternalTablePropertiesType = "HIVE_MANAGED_TABLE"
	ExternalTablePropertiesTypeHIVESPARKPROCESS         ExternalTablePropertiesType = "HIVE_SPARK_PROCESS"
	ExternalTablePropertiesTypeHIVEUNKNOWN              ExternalTablePropertiesType = "HIVE_UNKNOWN"
	ExternalTablePropertiesTypeHIVEUNKNOWNPROCESS       ExternalTablePropertiesType = "HIVE_UNKNOWN_PROCESS"
	ExternalTablePropertiesTypeHIVEVIRTUALVIEW          ExternalTablePropertiesType = "HIVE_VIRTUAL_VIEW"
	ExternalTablePropertiesTypeJDBCDATASET              ExternalTablePropertiesType = "JDBC_DATASET"
	ExternalTablePropertiesTypeJDBCDATASETREF           ExternalTablePropertiesType = "JDBC_DATASET_REF"
	ExternalTablePropertiesTypeJDBCEXTERNALTABLE        ExternalTablePropertiesType = "JDBC_EXTERNAL_TABLE"
	ExternalTablePropertiesTypeJDBCSNOWFLAKESTREAM      ExternalTablePropertiesType = "JDBC_SNOWFLAKE_STREAM"
	ExternalTablePropertiesTypeJDBCTABLE                ExternalTablePropertiesType = "JDBC_TABLE"
	ExternalTablePropertiesTypeJDBCVIEW                 ExternalTablePropertiesType = "JDBC_VIEW"
	ExternalTablePropertiesTypeLOOKERQUERY              ExternalTablePropertiesType = "LOOKER_QUERY"
	ExternalTablePropertiesTypeLOOKERSQLTABLE           ExternalTablePropertiesType = "LOOKER_SQL_TABLE"
	ExternalTablePropertiesTypeLOOKERVIEW               ExternalTablePropertiesType = "LOOKER_VIEW"
	ExternalTablePropertiesTypePOWERBITABLEREF          ExternalTablePropertiesType = "POWERBI_TABLE_REF"
	ExternalTablePropertiesTypeQUICKSIGHTTABLEREF       ExternalTablePropertiesType = "QUICKSIGHT_TABLE_REF"
	ExternalTablePropertiesTypeSTORAGEBUCKETGCP         ExternalTablePropertiesType = "STORAGE_BUCKET_GCP"
	ExternalTablePropertiesTypeSTORAGEBUCKETS3          ExternalTablePropertiesType = "STORAGE_BUCKET_S3"
	ExternalTablePropertiesTypeSTORAGEGOOGLEDRIVE       ExternalTablePropertiesType = "STORAGE_GOOGLE_DRIVE"
	ExternalTablePropertiesTypeTABLEAUDATABASETABLE     ExternalTablePropertiesType = "TABLEAU_DATABASE_TABLE"
	ExternalTablePropertiesTypeTABLEAUQUERY             ExternalTablePropertiesType = "TABLEAU_QUERY"
)

// Defines values for FieldDtoEntityType.
const (
	FieldDtoEntityTypeACCESSTOKEN            FieldDtoEntityType = "ACCESS_TOKEN"
	FieldDtoEntityTypeALERTINGHOOK           FieldDtoEntityType = "ALERTING_HOOK"
	FieldDtoEntityTypeCHART                  FieldDtoEntityType = "CHART"
	FieldDtoEntityTypeCOLLECTION             FieldDtoEntityType = "COLLECTION"
	FieldDtoEntityTypeCONFIG                 FieldDtoEntityType = "CONFIG"
	FieldDtoEntityTypeDAG                    FieldDtoEntityType = "DAG"
	FieldDtoEntityTypeDASHBOARD              FieldDtoEntityType = "DASHBOARD"
	FieldDtoEntityTypeDATASET                FieldDtoEntityType = "DATASET"
	FieldDtoEntityTypeDATASETFIELD           FieldDtoEntityType = "DATASET_FIELD"
	FieldDtoEntityTypeDATASOURCE             FieldDtoEntityType = "DATASOURCE"
	FieldDtoEntityTypeDATASOURCEINGESTIONRUN FieldDtoEntityType = "DATASOURCE_INGESTION_RUN"
	FieldDtoEntityTypeDOMAIN                 FieldDtoEntityType = "DOMAIN"
	FieldDtoEntityTypeINCIDENT               FieldDtoEntityType = "INCIDENT"
	FieldDtoEntityTypeRULERUN                FieldDtoEntityType = "RULE_RUN"
	FieldDtoEntityTypeSIFFLETRULE            FieldDtoEntityType = "SIFFLET_RULE"
	FieldDtoEntityTypeTAG                    FieldDtoEntityType = "TAG"
	FieldDtoEntityTypeUSER                   FieldDtoEntityType = "USER"
)

// Defines values for FieldLevelSearchDtoDatasourceType.
const (
	FieldLevelSearchDtoDatasourceTypeAIRFLOW    FieldLevelSearchDtoDatasourceType = "AIRFLOW"
	FieldLevelSearchDtoDatasourceTypeATHENA     FieldLevelSearchDtoDatasourceType = "ATHENA"
	FieldLevelSearchDtoDatasourceTypeBIGQUERY   FieldLevelSearchDtoDatasourceType = "BIGQUERY"
	FieldLevelSearchDtoDatasourceTypeDATABRICKS FieldLevelSearchDtoDatasourceType = "DATABRICKS"
	FieldLevelSearchDtoDatasourceTypeDBT        FieldLevelSearchDtoDatasourceType = "DBT"
	FieldLevelSearchDtoDatasourceTypeDBTCLOUD   FieldLevelSearchDtoDatasourceType = "DBTCLOUD"
	FieldLevelSearchDtoDatasourceTypeFIREBOLT   FieldLevelSearchDtoDatasourceType = "FIREBOLT"
	FieldLevelSearchDtoDatasourceTypeFIVETRAN   FieldLevelSearchDtoDatasourceType = "FIVETRAN"
	FieldLevelSearchDtoDatasourceTypeH2         FieldLevelSearchDtoDatasourceType = "H2"
	FieldLevelSearchDtoDatasourceTypeHIVE       FieldLevelSearchDtoDatasourceType = "HIVE"
	FieldLevelSearchDtoDatasourceTypeLOOKER     FieldLevelSearchDtoDatasourceType = "LOOKER"
	FieldLevelSearchDtoDatasourceTypeMSSQL      FieldLevelSearchDtoDatasourceType = "MSSQL"
	FieldLevelSearchDtoDatasourceTypeMYSQL      FieldLevelSearchDtoDatasourceType = "MYSQL"
	FieldLevelSearchDtoDatasourceTypeORACLE     FieldLevelSearchDtoDatasourceType = "ORACLE"
	FieldLevelSearchDtoDatasourceTypePOSTGRES   FieldLevelSearchDtoDatasourceType = "POSTGRES"
	FieldLevelSearchDtoDatasourceTypePOWERBI    FieldLevelSearchDtoDatasourceType = "POWER_BI"
	FieldLevelSearchDtoDatasourceTypeQUICKSIGHT FieldLevelSearchDtoDatasourceType = "QUICKSIGHT"
	FieldLevelSearchDtoDatasourceTypeREDSHIFT   FieldLevelSearchDtoDatasourceType = "REDSHIFT"
	FieldLevelSearchDtoDatasourceTypeSNOWFLAKE  FieldLevelSearchDtoDatasourceType = "SNOWFLAKE"
	FieldLevelSearchDtoDatasourceTypeTABLEAU    FieldLevelSearchDtoDatasourceType = "TABLEAU"
	FieldLevelSearchDtoDatasourceTypeUNKNOWN    FieldLevelSearchDtoDatasourceType = "_UNKNOWN_"
)

// Defines values for FieldLevelSearchDtoDisplayedType.
const (
	FieldLevelSearchDtoDisplayedTypeDAG              FieldLevelSearchDtoDisplayedType = "DAG"
	FieldLevelSearchDtoDisplayedTypeDASHBOARD        FieldLevelSearchDtoDisplayedType = "DASHBOARD"
	FieldLevelSearchDtoDisplayedTypeDATABASE         FieldLevelSearchDtoDisplayedType = "DATABASE"
	FieldLevelSearchDtoDisplayedTypeEXTERNALTABLE    FieldLevelSearchDtoDisplayedType = "EXTERNAL_TABLE"
	FieldLevelSearchDtoDisplayedTypeFIELD            FieldLevelSearchDtoDisplayedType = "FIELD"
	FieldLevelSearchDtoDisplayedTypeMATERIALIZEDVIEW FieldLevelSearchDtoDisplayedType = "MATERIALIZED_VIEW"
	FieldLevelSearchDtoDisplayedTypeMODEL            FieldLevelSearchDtoDisplayedType = "MODEL"
	FieldLevelSearchDtoDisplayedTypeMONITOR          FieldLevelSearchDtoDisplayedType = "MONITOR"
	FieldLevelSearchDtoDisplayedTypeNONE             FieldLevelSearchDtoDisplayedType = "NONE"
	FieldLevelSearchDtoDisplayedTypeORCHESTRATOR     FieldLevelSearchDtoDisplayedType = "ORCHESTRATOR"
	FieldLevelSearchDtoDisplayedTypeSCHEMA           FieldLevelSearchDtoDisplayedType = "SCHEMA"
	FieldLevelSearchDtoDisplayedTypeSNOWFLAKESTREAM  FieldLevelSearchDtoDisplayedType = "SNOWFLAKE_STREAM"
	FieldLevelSearchDtoDisplayedTypeTABLE            FieldLevelSearchDtoDisplayedType = "TABLE"
	FieldLevelSearchDtoDisplayedTypeTRANSFORMATION   FieldLevelSearchDtoDisplayedType = "TRANSFORMATION"
	FieldLevelSearchDtoDisplayedTypeVIEW             FieldLevelSearchDtoDisplayedType = "VIEW"
)

// Defines values for FieldLevelSearchDtoEntityType.
const (
	FieldLevelSearchDtoEntityTypeACCESSTOKEN            FieldLevelSearchDtoEntityType = "ACCESS_TOKEN"
	FieldLevelSearchDtoEntityTypeALERTINGHOOK           FieldLevelSearchDtoEntityType = "ALERTING_HOOK"
	FieldLevelSearchDtoEntityTypeCHART                  FieldLevelSearchDtoEntityType = "CHART"
	FieldLevelSearchDtoEntityTypeCOLLECTION             FieldLevelSearchDtoEntityType = "COLLECTION"
	FieldLevelSearchDtoEntityTypeCONFIG                 FieldLevelSearchDtoEntityType = "CONFIG"
	FieldLevelSearchDtoEntityTypeDAG                    FieldLevelSearchDtoEntityType = "DAG"
	FieldLevelSearchDtoEntityTypeDASHBOARD              FieldLevelSearchDtoEntityType = "DASHBOARD"
	FieldLevelSearchDtoEntityTypeDATASET                FieldLevelSearchDtoEntityType = "DATASET"
	FieldLevelSearchDtoEntityTypeDATASETFIELD           FieldLevelSearchDtoEntityType = "DATASET_FIELD"
	FieldLevelSearchDtoEntityTypeDATASOURCE             FieldLevelSearchDtoEntityType = "DATASOURCE"
	FieldLevelSearchDtoEntityTypeDATASOURCEINGESTIONRUN FieldLevelSearchDtoEntityType = "DATASOURCE_INGESTION_RUN"
	FieldLevelSearchDtoEntityTypeDOMAIN                 FieldLevelSearchDtoEntityType = "DOMAIN"
	FieldLevelSearchDtoEntityTypeINCIDENT               FieldLevelSearchDtoEntityType = "INCIDENT"
	FieldLevelSearchDtoEntityTypeRULERUN                FieldLevelSearchDtoEntityType = "RULE_RUN"
	FieldLevelSearchDtoEntityTypeSIFFLETRULE            FieldLevelSearchDtoEntityType = "SIFFLET_RULE"
	FieldLevelSearchDtoEntityTypeTAG                    FieldLevelSearchDtoEntityType = "TAG"
	FieldLevelSearchDtoEntityTypeUSER                   FieldLevelSearchDtoEntityType = "USER"
)

// Defines values for FieldLevelSearchDtoHealth.
const (
	FieldLevelSearchDtoHealthATRISK       FieldLevelSearchDtoHealth = "AT_RISK"
	FieldLevelSearchDtoHealthCRITICAL     FieldLevelSearchDtoHealth = "CRITICAL"
	FieldLevelSearchDtoHealthHEALTHY      FieldLevelSearchDtoHealth = "HEALTHY"
	FieldLevelSearchDtoHealthNOTSUPPORTED FieldLevelSearchDtoHealth = "NOT_SUPPORTED"
	FieldLevelSearchDtoHealthUNMONITORED  FieldLevelSearchDtoHealth = "UNMONITORED"
)

// Defines values for FieldLevelSearchDtoUsage.
const (
	FieldLevelSearchDtoUsageHIGH        FieldLevelSearchDtoUsage = "HIGH"
	FieldLevelSearchDtoUsageLOW         FieldLevelSearchDtoUsage = "LOW"
	FieldLevelSearchDtoUsageMEDIUM      FieldLevelSearchDtoUsage = "MEDIUM"
	FieldLevelSearchDtoUsageUNSUPPORTED FieldLevelSearchDtoUsage = "UNSUPPORTED"
)

// Defines values for FieldLevelSearchFieldDtoEntityType.
const (
	FieldLevelSearchFieldDtoEntityTypeACCESSTOKEN            FieldLevelSearchFieldDtoEntityType = "ACCESS_TOKEN"
	FieldLevelSearchFieldDtoEntityTypeALERTINGHOOK           FieldLevelSearchFieldDtoEntityType = "ALERTING_HOOK"
	FieldLevelSearchFieldDtoEntityTypeCHART                  FieldLevelSearchFieldDtoEntityType = "CHART"
	FieldLevelSearchFieldDtoEntityTypeCOLLECTION             FieldLevelSearchFieldDtoEntityType = "COLLECTION"
	FieldLevelSearchFieldDtoEntityTypeCONFIG                 FieldLevelSearchFieldDtoEntityType = "CONFIG"
	FieldLevelSearchFieldDtoEntityTypeDAG                    FieldLevelSearchFieldDtoEntityType = "DAG"
	FieldLevelSearchFieldDtoEntityTypeDASHBOARD              FieldLevelSearchFieldDtoEntityType = "DASHBOARD"
	FieldLevelSearchFieldDtoEntityTypeDATASET                FieldLevelSearchFieldDtoEntityType = "DATASET"
	FieldLevelSearchFieldDtoEntityTypeDATASETFIELD           FieldLevelSearchFieldDtoEntityType = "DATASET_FIELD"
	FieldLevelSearchFieldDtoEntityTypeDATASOURCE             FieldLevelSearchFieldDtoEntityType = "DATASOURCE"
	FieldLevelSearchFieldDtoEntityTypeDATASOURCEINGESTIONRUN FieldLevelSearchFieldDtoEntityType = "DATASOURCE_INGESTION_RUN"
	FieldLevelSearchFieldDtoEntityTypeDOMAIN                 FieldLevelSearchFieldDtoEntityType = "DOMAIN"
	FieldLevelSearchFieldDtoEntityTypeINCIDENT               FieldLevelSearchFieldDtoEntityType = "INCIDENT"
	FieldLevelSearchFieldDtoEntityTypeRULERUN                FieldLevelSearchFieldDtoEntityType = "RULE_RUN"
	FieldLevelSearchFieldDtoEntityTypeSIFFLETRULE            FieldLevelSearchFieldDtoEntityType = "SIFFLET_RULE"
	FieldLevelSearchFieldDtoEntityTypeTAG                    FieldLevelSearchFieldDtoEntityType = "TAG"
	FieldLevelSearchFieldDtoEntityTypeUSER                   FieldLevelSearchFieldDtoEntityType = "USER"
)

// Defines values for GitConnectionAuthType.
const (
	HTTPAUTHORIZATIONHEADER GitConnectionAuthType = "HTTP_AUTHORIZATION_HEADER"
	SSH                     GitConnectionAuthType = "SSH"
	USERPASSWORD            GitConnectionAuthType = "USER_PASSWORD"
)

// Defines values for HealthStatusSearchFilterElementDtoId.
const (
	HealthStatusSearchFilterElementDtoIdATRISK       HealthStatusSearchFilterElementDtoId = "AT_RISK"
	HealthStatusSearchFilterElementDtoIdCRITICAL     HealthStatusSearchFilterElementDtoId = "CRITICAL"
	HealthStatusSearchFilterElementDtoIdHEALTHY      HealthStatusSearchFilterElementDtoId = "HEALTHY"
	HealthStatusSearchFilterElementDtoIdNOTSUPPORTED HealthStatusSearchFilterElementDtoId = "NOT_SUPPORTED"
	HealthStatusSearchFilterElementDtoIdUNMONITORED  HealthStatusSearchFilterElementDtoId = "UNMONITORED"
)

// Defines values for ImpactedAssetDtoDatasourceType.
const (
	ImpactedAssetDtoDatasourceTypeAIRFLOW    ImpactedAssetDtoDatasourceType = "AIRFLOW"
	ImpactedAssetDtoDatasourceTypeATHENA     ImpactedAssetDtoDatasourceType = "ATHENA"
	ImpactedAssetDtoDatasourceTypeBIGQUERY   ImpactedAssetDtoDatasourceType = "BIGQUERY"
	ImpactedAssetDtoDatasourceTypeDATABRICKS ImpactedAssetDtoDatasourceType = "DATABRICKS"
	ImpactedAssetDtoDatasourceTypeDBT        ImpactedAssetDtoDatasourceType = "DBT"
	ImpactedAssetDtoDatasourceTypeDBTCLOUD   ImpactedAssetDtoDatasourceType = "DBTCLOUD"
	ImpactedAssetDtoDatasourceTypeFIREBOLT   ImpactedAssetDtoDatasourceType = "FIREBOLT"
	ImpactedAssetDtoDatasourceTypeFIVETRAN   ImpactedAssetDtoDatasourceType = "FIVETRAN"
	ImpactedAssetDtoDatasourceTypeH2         ImpactedAssetDtoDatasourceType = "H2"
	ImpactedAssetDtoDatasourceTypeHIVE       ImpactedAssetDtoDatasourceType = "HIVE"
	ImpactedAssetDtoDatasourceTypeLOOKER     ImpactedAssetDtoDatasourceType = "LOOKER"
	ImpactedAssetDtoDatasourceTypeMSSQL      ImpactedAssetDtoDatasourceType = "MSSQL"
	ImpactedAssetDtoDatasourceTypeMYSQL      ImpactedAssetDtoDatasourceType = "MYSQL"
	ImpactedAssetDtoDatasourceTypeORACLE     ImpactedAssetDtoDatasourceType = "ORACLE"
	ImpactedAssetDtoDatasourceTypePOSTGRES   ImpactedAssetDtoDatasourceType = "POSTGRES"
	ImpactedAssetDtoDatasourceTypePOWERBI    ImpactedAssetDtoDatasourceType = "POWER_BI"
	ImpactedAssetDtoDatasourceTypeQUICKSIGHT ImpactedAssetDtoDatasourceType = "QUICKSIGHT"
	ImpactedAssetDtoDatasourceTypeREDSHIFT   ImpactedAssetDtoDatasourceType = "REDSHIFT"
	ImpactedAssetDtoDatasourceTypeSNOWFLAKE  ImpactedAssetDtoDatasourceType = "SNOWFLAKE"
	ImpactedAssetDtoDatasourceTypeTABLEAU    ImpactedAssetDtoDatasourceType = "TABLEAU"
	ImpactedAssetDtoDatasourceTypeUNKNOWN    ImpactedAssetDtoDatasourceType = "_UNKNOWN_"
)

// Defines values for IncidentLightDtoStatus.
const (
	IncidentLightDtoStatusCLOSED     IncidentLightDtoStatus = "CLOSED"
	IncidentLightDtoStatusONGOING    IncidentLightDtoStatus = "ONGOING"
	IncidentLightDtoStatusUNASSIGNED IncidentLightDtoStatus = "UNASSIGNED"
)

// Defines values for IncidentStatusUpdatePayloadQualification.
const (
	IncidentStatusUpdatePayloadQualificationEXPECTED      IncidentStatusUpdatePayloadQualification = "EXPECTED"
	IncidentStatusUpdatePayloadQualificationFALSEPOSITIVE IncidentStatusUpdatePayloadQualification = "FALSE_POSITIVE"
	IncidentStatusUpdatePayloadQualificationFIXED         IncidentStatusUpdatePayloadQualification = "FIXED"
	IncidentStatusUpdatePayloadQualificationKNOWNERROR    IncidentStatusUpdatePayloadQualification = "KNOWN_ERROR"
)

// Defines values for IssueDetailsDtoCriticality.
const (
	IssueDetailsDtoCriticalityCRITICAL IssueDetailsDtoCriticality = "CRITICAL"
	IssueDetailsDtoCriticalityHIGH     IssueDetailsDtoCriticality = "HIGH"
	IssueDetailsDtoCriticalityLOW      IssueDetailsDtoCriticality = "LOW"
	IssueDetailsDtoCriticalityMODERATE IssueDetailsDtoCriticality = "MODERATE"
)

// Defines values for IssueDetailsDtoQualification.
const (
	IssueDetailsDtoQualificationEXPECTED      IssueDetailsDtoQualification = "EXPECTED"
	IssueDetailsDtoQualificationFALSEPOSITIVE IssueDetailsDtoQualification = "FALSE_POSITIVE"
	IssueDetailsDtoQualificationFIXED         IssueDetailsDtoQualification = "FIXED"
	IssueDetailsDtoQualificationKNOWNERROR    IssueDetailsDtoQualification = "KNOWN_ERROR"
)

// Defines values for IssueDetailsDtoStatus.
const (
	IssueDetailsDtoStatusCLOSED     IssueDetailsDtoStatus = "CLOSED"
	IssueDetailsDtoStatusONGOING    IssueDetailsDtoStatus = "ONGOING"
	IssueDetailsDtoStatusUNASSIGNED IssueDetailsDtoStatus = "UNASSIGNED"
)

// Defines values for LastIngestionStatusDtoStatus.
const (
	LastIngestionStatusDtoStatusFAILURE                         LastIngestionStatusDtoStatus = "FAILURE"
	LastIngestionStatusDtoStatusPENDING                         LastIngestionStatusDtoStatus = "PENDING"
	LastIngestionStatusDtoStatusRUNNING                         LastIngestionStatusDtoStatus = "RUNNING"
	LastIngestionStatusDtoStatusSKIPPEDDATASOURCEALREADYRUNNING LastIngestionStatusDtoStatus = "SKIPPED_DATASOURCE_ALREADY_RUNNING"
	LastIngestionStatusDtoStatusSUCCESS                         LastIngestionStatusDtoStatus = "SUCCESS"
)

// Defines values for LineageAttachedEntityDatasourceType.
const (
	LineageAttachedEntityDatasourceTypeAIRFLOW    LineageAttachedEntityDatasourceType = "AIRFLOW"
	LineageAttachedEntityDatasourceTypeATHENA     LineageAttachedEntityDatasourceType = "ATHENA"
	LineageAttachedEntityDatasourceTypeBIGQUERY   LineageAttachedEntityDatasourceType = "BIGQUERY"
	LineageAttachedEntityDatasourceTypeDATABRICKS LineageAttachedEntityDatasourceType = "DATABRICKS"
	LineageAttachedEntityDatasourceTypeDBT        LineageAttachedEntityDatasourceType = "DBT"
	LineageAttachedEntityDatasourceTypeDBTCLOUD   LineageAttachedEntityDatasourceType = "DBTCLOUD"
	LineageAttachedEntityDatasourceTypeFIREBOLT   LineageAttachedEntityDatasourceType = "FIREBOLT"
	LineageAttachedEntityDatasourceTypeFIVETRAN   LineageAttachedEntityDatasourceType = "FIVETRAN"
	LineageAttachedEntityDatasourceTypeH2         LineageAttachedEntityDatasourceType = "H2"
	LineageAttachedEntityDatasourceTypeHIVE       LineageAttachedEntityDatasourceType = "HIVE"
	LineageAttachedEntityDatasourceTypeLOOKER     LineageAttachedEntityDatasourceType = "LOOKER"
	LineageAttachedEntityDatasourceTypeMSSQL      LineageAttachedEntityDatasourceType = "MSSQL"
	LineageAttachedEntityDatasourceTypeMYSQL      LineageAttachedEntityDatasourceType = "MYSQL"
	LineageAttachedEntityDatasourceTypeORACLE     LineageAttachedEntityDatasourceType = "ORACLE"
	LineageAttachedEntityDatasourceTypePOSTGRES   LineageAttachedEntityDatasourceType = "POSTGRES"
	LineageAttachedEntityDatasourceTypePOWERBI    LineageAttachedEntityDatasourceType = "POWER_BI"
	LineageAttachedEntityDatasourceTypeQUICKSIGHT LineageAttachedEntityDatasourceType = "QUICKSIGHT"
	LineageAttachedEntityDatasourceTypeREDSHIFT   LineageAttachedEntityDatasourceType = "REDSHIFT"
	LineageAttachedEntityDatasourceTypeSNOWFLAKE  LineageAttachedEntityDatasourceType = "SNOWFLAKE"
	LineageAttachedEntityDatasourceTypeTABLEAU    LineageAttachedEntityDatasourceType = "TABLEAU"
	LineageAttachedEntityDatasourceTypeUNKNOWN    LineageAttachedEntityDatasourceType = "_UNKNOWN_"
)

// Defines values for LineageAttachedEntityType.
const (
	LineageAttachedEntityTypeDAG              LineageAttachedEntityType = "DAG"
	LineageAttachedEntityTypeDASHBOARD        LineageAttachedEntityType = "DASHBOARD"
	LineageAttachedEntityTypeDATABASE         LineageAttachedEntityType = "DATABASE"
	LineageAttachedEntityTypeEXTERNALTABLE    LineageAttachedEntityType = "EXTERNAL_TABLE"
	LineageAttachedEntityTypeFIELD            LineageAttachedEntityType = "FIELD"
	LineageAttachedEntityTypeMATERIALIZEDVIEW LineageAttachedEntityType = "MATERIALIZED_VIEW"
	LineageAttachedEntityTypeMODEL            LineageAttachedEntityType = "MODEL"
	LineageAttachedEntityTypeMONITOR          LineageAttachedEntityType = "MONITOR"
	LineageAttachedEntityTypeNONE             LineageAttachedEntityType = "NONE"
	LineageAttachedEntityTypeORCHESTRATOR     LineageAttachedEntityType = "ORCHESTRATOR"
	LineageAttachedEntityTypeSCHEMA           LineageAttachedEntityType = "SCHEMA"
	LineageAttachedEntityTypeSNOWFLAKESTREAM  LineageAttachedEntityType = "SNOWFLAKE_STREAM"
	LineageAttachedEntityTypeTABLE            LineageAttachedEntityType = "TABLE"
	LineageAttachedEntityTypeTRANSFORMATION   LineageAttachedEntityType = "TRANSFORMATION"
	LineageAttachedEntityTypeVIEW             LineageAttachedEntityType = "VIEW"
)

// Defines values for LineageEntityDtoEntityType.
const (
	LineageEntityDtoEntityTypeACCESSTOKEN            LineageEntityDtoEntityType = "ACCESS_TOKEN"
	LineageEntityDtoEntityTypeALERTINGHOOK           LineageEntityDtoEntityType = "ALERTING_HOOK"
	LineageEntityDtoEntityTypeCHART                  LineageEntityDtoEntityType = "CHART"
	LineageEntityDtoEntityTypeCOLLECTION             LineageEntityDtoEntityType = "COLLECTION"
	LineageEntityDtoEntityTypeCONFIG                 LineageEntityDtoEntityType = "CONFIG"
	LineageEntityDtoEntityTypeDAG                    LineageEntityDtoEntityType = "DAG"
	LineageEntityDtoEntityTypeDASHBOARD              LineageEntityDtoEntityType = "DASHBOARD"
	LineageEntityDtoEntityTypeDATASET                LineageEntityDtoEntityType = "DATASET"
	LineageEntityDtoEntityTypeDATASETFIELD           LineageEntityDtoEntityType = "DATASET_FIELD"
	LineageEntityDtoEntityTypeDATASOURCE             LineageEntityDtoEntityType = "DATASOURCE"
	LineageEntityDtoEntityTypeDATASOURCEINGESTIONRUN LineageEntityDtoEntityType = "DATASOURCE_INGESTION_RUN"
	LineageEntityDtoEntityTypeDOMAIN                 LineageEntityDtoEntityType = "DOMAIN"
	LineageEntityDtoEntityTypeINCIDENT               LineageEntityDtoEntityType = "INCIDENT"
	LineageEntityDtoEntityTypeRULERUN                LineageEntityDtoEntityType = "RULE_RUN"
	LineageEntityDtoEntityTypeSIFFLETRULE            LineageEntityDtoEntityType = "SIFFLET_RULE"
	LineageEntityDtoEntityTypeTAG                    LineageEntityDtoEntityType = "TAG"
	LineageEntityDtoEntityTypeUSER                   LineageEntityDtoEntityType = "USER"
)

// Defines values for LineageEntityDtoHealth.
const (
	LineageEntityDtoHealthATRISK       LineageEntityDtoHealth = "AT_RISK"
	LineageEntityDtoHealthCRITICAL     LineageEntityDtoHealth = "CRITICAL"
	LineageEntityDtoHealthHEALTHY      LineageEntityDtoHealth = "HEALTHY"
	LineageEntityDtoHealthNOTSUPPORTED LineageEntityDtoHealth = "NOT_SUPPORTED"
	LineageEntityDtoHealthUNMONITORED  LineageEntityDtoHealth = "UNMONITORED"
)

// Defines values for LineageUrnDtoCreationMethod.
const (
	BARRACUDALINEAGEEXTRACTION LineageUrnDtoCreationMethod = "BARRACUDA_LINEAGE_EXTRACTION"
	DECLARATIVELINEAGEAPI      LineageUrnDtoCreationMethod = "DECLARATIVE_LINEAGE_API"
)

// Defines values for ModelAssetOverviewType.
const (
	ModelAssetOverviewTypeBIGQUERYDATASETREF       ModelAssetOverviewType = "BIGQUERY_DATASET_REF"
	ModelAssetOverviewTypeBIGQUERYEXTERNALTABLE    ModelAssetOverviewType = "BIGQUERY_EXTERNAL_TABLE"
	ModelAssetOverviewTypeBIGQUERYMATERIALIZEDVIEW ModelAssetOverviewType = "BIGQUERY_MATERIALIZED_VIEW"
	ModelAssetOverviewTypeBIGQUERYTABLE            ModelAssetOverviewType = "BIGQUERY_TABLE"
	ModelAssetOverviewTypeBIGQUERYVIEW             ModelAssetOverviewType = "BIGQUERY_VIEW"
	ModelAssetOverviewTypeDATABRICKSSTREAMINGTABLE ModelAssetOverviewType = "DATABRICKS_STREAMING_TABLE"
	ModelAssetOverviewTypeDATABRICKSUNKNOWN        ModelAssetOverviewType = "DATABRICKS_UNKNOWN"
	ModelAssetOverviewTypeDBTEPHEMERALREF          ModelAssetOverviewType = "DBT_EPHEMERAL_REF"
	ModelAssetOverviewTypeDBTMODEL                 ModelAssetOverviewType = "DBT_MODEL"
	ModelAssetOverviewTypeDBTSEED                  ModelAssetOverviewType = "DBT_SEED"
	ModelAssetOverviewTypeDBTSOURCEDATASETREF      ModelAssetOverviewType = "DBT_SOURCE_DATASET_REF"
	ModelAssetOverviewTypeDBTTABLEREF              ModelAssetOverviewType = "DBT_TABLE_REF"
	ModelAssetOverviewTypeDBTUNKNOWN               ModelAssetOverviewType = "DBT_UNKNOWN"
	ModelAssetOverviewTypeDBTVIEWREF               ModelAssetOverviewType = "DBT_VIEW_REF"
	ModelAssetOverviewTypeHIVEDATASETREF           ModelAssetOverviewType = "HIVE_DATASET_REF"
	ModelAssetOverviewTypeHIVEEXTERNALTABLE        ModelAssetOverviewType = "HIVE_EXTERNAL_TABLE"
	ModelAssetOverviewTypeHIVEHDFSSTORAGE          ModelAssetOverviewType = "HIVE_HDFS_STORAGE"
	ModelAssetOverviewTypeHIVEHIVEPROCESS          ModelAssetOverviewType = "HIVE_HIVE_PROCESS"
	ModelAssetOverviewTypeHIVEMANAGEDTABLE         ModelAssetOverviewType = "HIVE_MANAGED_TABLE"
	ModelAssetOverviewTypeHIVESPARKPROCESS         ModelAssetOverviewType = "HIVE_SPARK_PROCESS"
	ModelAssetOverviewTypeHIVEUNKNOWN              ModelAssetOverviewType = "HIVE_UNKNOWN"
	ModelAssetOverviewTypeHIVEUNKNOWNPROCESS       ModelAssetOverviewType = "HIVE_UNKNOWN_PROCESS"
	ModelAssetOverviewTypeHIVEVIRTUALVIEW          ModelAssetOverviewType = "HIVE_VIRTUAL_VIEW"
	ModelAssetOverviewTypeJDBCDATASET              ModelAssetOverviewType = "JDBC_DATASET"
	ModelAssetOverviewTypeJDBCDATASETREF           ModelAssetOverviewType = "JDBC_DATASET_REF"
	ModelAssetOverviewTypeJDBCEXTERNALTABLE        ModelAssetOverviewType = "JDBC_EXTERNAL_TABLE"
	ModelAssetOverviewTypeJDBCSNOWFLAKESTREAM      ModelAssetOverviewType = "JDBC_SNOWFLAKE_STREAM"
	ModelAssetOverviewTypeJDBCTABLE                ModelAssetOverviewType = "JDBC_TABLE"
	ModelAssetOverviewTypeJDBCVIEW                 ModelAssetOverviewType = "JDBC_VIEW"
	ModelAssetOverviewTypeLOOKERQUERY              ModelAssetOverviewType = "LOOKER_QUERY"
	ModelAssetOverviewTypeLOOKERSQLTABLE           ModelAssetOverviewType = "LOOKER_SQL_TABLE"
	ModelAssetOverviewTypeLOOKERVIEW               ModelAssetOverviewType = "LOOKER_VIEW"
	ModelAssetOverviewTypePOWERBITABLEREF          ModelAssetOverviewType = "POWERBI_TABLE_REF"
	ModelAssetOverviewTypeQUICKSIGHTTABLEREF       ModelAssetOverviewType = "QUICKSIGHT_TABLE_REF"
	ModelAssetOverviewTypeSTORAGEBUCKETGCP         ModelAssetOverviewType = "STORAGE_BUCKET_GCP"
	ModelAssetOverviewTypeSTORAGEBUCKETS3          ModelAssetOverviewType = "STORAGE_BUCKET_S3"
	ModelAssetOverviewTypeSTORAGEGOOGLEDRIVE       ModelAssetOverviewType = "STORAGE_GOOGLE_DRIVE"
	ModelAssetOverviewTypeTABLEAUDATABASETABLE     ModelAssetOverviewType = "TABLEAU_DATABASE_TABLE"
	ModelAssetOverviewTypeTABLEAUQUERY             ModelAssetOverviewType = "TABLEAU_QUERY"
)

// Defines values for MysqlParamsMysqlTlsVersion.
const (
	TLSV12 MysqlParamsMysqlTlsVersion = "TLS_V_1_2"
	TLSV13 MysqlParamsMysqlTlsVersion = "TLS_V_1_3"
)

// Defines values for PlatformSearchFilterElementDtoId.
const (
	AIRFLOW    PlatformSearchFilterElementDtoId = "AIRFLOW"
	ATHENA     PlatformSearchFilterElementDtoId = "ATHENA"
	BIGQUERY   PlatformSearchFilterElementDtoId = "BIGQUERY"
	DATABRICKS PlatformSearchFilterElementDtoId = "DATABRICKS"
	DBT        PlatformSearchFilterElementDtoId = "DBT"
	DBTCLOUD   PlatformSearchFilterElementDtoId = "DBTCLOUD"
	FIREBOLT   PlatformSearchFilterElementDtoId = "FIREBOLT"
	FIVETRAN   PlatformSearchFilterElementDtoId = "FIVETRAN"
	H2         PlatformSearchFilterElementDtoId = "H2"
	HIVE       PlatformSearchFilterElementDtoId = "HIVE"
	LOOKER     PlatformSearchFilterElementDtoId = "LOOKER"
	MSSQL      PlatformSearchFilterElementDtoId = "MSSQL"
	MYSQL      PlatformSearchFilterElementDtoId = "MYSQL"
	ORACLE     PlatformSearchFilterElementDtoId = "ORACLE"
	POSTGRES   PlatformSearchFilterElementDtoId = "POSTGRES"
	POWERBI    PlatformSearchFilterElementDtoId = "POWER_BI"
	QUICKSIGHT PlatformSearchFilterElementDtoId = "QUICKSIGHT"
	REDSHIFT   PlatformSearchFilterElementDtoId = "REDSHIFT"
	SNOWFLAKE  PlatformSearchFilterElementDtoId = "SNOWFLAKE"
	TABLEAU    PlatformSearchFilterElementDtoId = "TABLEAU"
	UNKNOWN    PlatformSearchFilterElementDtoId = "_UNKNOWN_"
)

// Defines values for RuleRunDetailsByGroupDtoGraphType.
const (
	COMPLETENESS            RuleRunDetailsByGroupDtoGraphType = "COMPLETENESS"
	DISTRIBUTION            RuleRunDetailsByGroupDtoGraphType = "DISTRIBUTION"
	DUPLICATE               RuleRunDetailsByGroupDtoGraphType = "DUPLICATE"
	FRESHNESS               RuleRunDetailsByGroupDtoGraphType = "FRESHNESS"
	INTERLINKEDMETRICS      RuleRunDetailsByGroupDtoGraphType = "INTERLINKED_METRICS"
	NONE                    RuleRunDetailsByGroupDtoGraphType = "NONE"
	NUMERICALTRANSFORMATION RuleRunDetailsByGroupDtoGraphType = "NUMERICAL_TRANSFORMATION"
)

// Defines values for RuleRunDetailsByGroupDtoStatus.
const (
	FAILED                RuleRunDetailsByGroupDtoStatus = "FAILED"
	PENDING               RuleRunDetailsByGroupDtoStatus = "PENDING"
	REQUIRESYOURATTENTION RuleRunDetailsByGroupDtoStatus = "REQUIRES_YOUR_ATTENTION"
	RUNNING               RuleRunDetailsByGroupDtoStatus = "RUNNING"
	SUCCESS               RuleRunDetailsByGroupDtoStatus = "SUCCESS"
	TECHNICALERROR        RuleRunDetailsByGroupDtoStatus = "TECHNICAL_ERROR"
)

// Defines values for SnowflakeStreamPropertiesType.
const (
	SnowflakeStreamPropertiesTypeBIGQUERYDATASETREF       SnowflakeStreamPropertiesType = "BIGQUERY_DATASET_REF"
	SnowflakeStreamPropertiesTypeBIGQUERYEXTERNALTABLE    SnowflakeStreamPropertiesType = "BIGQUERY_EXTERNAL_TABLE"
	SnowflakeStreamPropertiesTypeBIGQUERYMATERIALIZEDVIEW SnowflakeStreamPropertiesType = "BIGQUERY_MATERIALIZED_VIEW"
	SnowflakeStreamPropertiesTypeBIGQUERYTABLE            SnowflakeStreamPropertiesType = "BIGQUERY_TABLE"
	SnowflakeStreamPropertiesTypeBIGQUERYVIEW             SnowflakeStreamPropertiesType = "BIGQUERY_VIEW"
	SnowflakeStreamPropertiesTypeDATABRICKSSTREAMINGTABLE SnowflakeStreamPropertiesType = "DATABRICKS_STREAMING_TABLE"
	SnowflakeStreamPropertiesTypeDATABRICKSUNKNOWN        SnowflakeStreamPropertiesType = "DATABRICKS_UNKNOWN"
	SnowflakeStreamPropertiesTypeDBTEPHEMERALREF          SnowflakeStreamPropertiesType = "DBT_EPHEMERAL_REF"
	SnowflakeStreamPropertiesTypeDBTMODEL                 SnowflakeStreamPropertiesType = "DBT_MODEL"
	SnowflakeStreamPropertiesTypeDBTSEED                  SnowflakeStreamPropertiesType = "DBT_SEED"
	SnowflakeStreamPropertiesTypeDBTSOURCEDATASETREF      SnowflakeStreamPropertiesType = "DBT_SOURCE_DATASET_REF"
	SnowflakeStreamPropertiesTypeDBTTABLEREF              SnowflakeStreamPropertiesType = "DBT_TABLE_REF"
	SnowflakeStreamPropertiesTypeDBTUNKNOWN               SnowflakeStreamPropertiesType = "DBT_UNKNOWN"
	SnowflakeStreamPropertiesTypeDBTVIEWREF               SnowflakeStreamPropertiesType = "DBT_VIEW_REF"
	SnowflakeStreamPropertiesTypeHIVEDATASETREF           SnowflakeStreamPropertiesType = "HIVE_DATASET_REF"
	SnowflakeStreamPropertiesTypeHIVEEXTERNALTABLE        SnowflakeStreamPropertiesType = "HIVE_EXTERNAL_TABLE"
	SnowflakeStreamPropertiesTypeHIVEHDFSSTORAGE          SnowflakeStreamPropertiesType = "HIVE_HDFS_STORAGE"
	SnowflakeStreamPropertiesTypeHIVEHIVEPROCESS          SnowflakeStreamPropertiesType = "HIVE_HIVE_PROCESS"
	SnowflakeStreamPropertiesTypeHIVEMANAGEDTABLE         SnowflakeStreamPropertiesType = "HIVE_MANAGED_TABLE"
	SnowflakeStreamPropertiesTypeHIVESPARKPROCESS         SnowflakeStreamPropertiesType = "HIVE_SPARK_PROCESS"
	SnowflakeStreamPropertiesTypeHIVEUNKNOWN              SnowflakeStreamPropertiesType = "HIVE_UNKNOWN"
	SnowflakeStreamPropertiesTypeHIVEUNKNOWNPROCESS       SnowflakeStreamPropertiesType = "HIVE_UNKNOWN_PROCESS"
	SnowflakeStreamPropertiesTypeHIVEVIRTUALVIEW          SnowflakeStreamPropertiesType = "HIVE_VIRTUAL_VIEW"
	SnowflakeStreamPropertiesTypeJDBCDATASET              SnowflakeStreamPropertiesType = "JDBC_DATASET"
	SnowflakeStreamPropertiesTypeJDBCDATASETREF           SnowflakeStreamPropertiesType = "JDBC_DATASET_REF"
	SnowflakeStreamPropertiesTypeJDBCEXTERNALTABLE        SnowflakeStreamPropertiesType = "JDBC_EXTERNAL_TABLE"
	SnowflakeStreamPropertiesTypeJDBCSNOWFLAKESTREAM      SnowflakeStreamPropertiesType = "JDBC_SNOWFLAKE_STREAM"
	SnowflakeStreamPropertiesTypeJDBCTABLE                SnowflakeStreamPropertiesType = "JDBC_TABLE"
	SnowflakeStreamPropertiesTypeJDBCVIEW                 SnowflakeStreamPropertiesType = "JDBC_VIEW"
	SnowflakeStreamPropertiesTypeLOOKERQUERY              SnowflakeStreamPropertiesType = "LOOKER_QUERY"
	SnowflakeStreamPropertiesTypeLOOKERSQLTABLE           SnowflakeStreamPropertiesType = "LOOKER_SQL_TABLE"
	SnowflakeStreamPropertiesTypeLOOKERVIEW               SnowflakeStreamPropertiesType = "LOOKER_VIEW"
	SnowflakeStreamPropertiesTypePOWERBITABLEREF          SnowflakeStreamPropertiesType = "POWERBI_TABLE_REF"
	SnowflakeStreamPropertiesTypeQUICKSIGHTTABLEREF       SnowflakeStreamPropertiesType = "QUICKSIGHT_TABLE_REF"
	SnowflakeStreamPropertiesTypeSTORAGEBUCKETGCP         SnowflakeStreamPropertiesType = "STORAGE_BUCKET_GCP"
	SnowflakeStreamPropertiesTypeSTORAGEBUCKETS3          SnowflakeStreamPropertiesType = "STORAGE_BUCKET_S3"
	SnowflakeStreamPropertiesTypeSTORAGEGOOGLEDRIVE       SnowflakeStreamPropertiesType = "STORAGE_GOOGLE_DRIVE"
	SnowflakeStreamPropertiesTypeTABLEAUDATABASETABLE     SnowflakeStreamPropertiesType = "TABLEAU_DATABASE_TABLE"
	SnowflakeStreamPropertiesTypeTABLEAUQUERY             SnowflakeStreamPropertiesType = "TABLEAU_QUERY"
)

// Defines values for TagCreateDtoType.
const (
	TagCreateDtoTypeBIGQUERYEXTERNAL          TagCreateDtoType = "BIGQUERY_EXTERNAL"
	TagCreateDtoTypeGENERIC                   TagCreateDtoType = "GENERIC"
	TagCreateDtoTypeHIDDENDATACLASSIFICATION  TagCreateDtoType = "HIDDEN_DATA_CLASSIFICATION"
	TagCreateDtoTypeSNOWFLAKEEXTERNAL         TagCreateDtoType = "SNOWFLAKE_EXTERNAL"
	TagCreateDtoTypeTERM                      TagCreateDtoType = "TERM"
	TagCreateDtoTypeVISIBLEDATACLASSIFICATION TagCreateDtoType = "VISIBLE_DATA_CLASSIFICATION"
)

// Defines values for TagDtoType.
const (
	TagDtoTypeBIGQUERYEXTERNAL          TagDtoType = "BIGQUERY_EXTERNAL"
	TagDtoTypeGENERIC                   TagDtoType = "GENERIC"
	TagDtoTypeHIDDENDATACLASSIFICATION  TagDtoType = "HIDDEN_DATA_CLASSIFICATION"
	TagDtoTypeSNOWFLAKEEXTERNAL         TagDtoType = "SNOWFLAKE_EXTERNAL"
	TagDtoTypeTERM                      TagDtoType = "TERM"
	TagDtoTypeVISIBLEDATACLASSIFICATION TagDtoType = "VISIBLE_DATA_CLASSIFICATION"
)

// Defines values for TagSearchFilterElementDtoType.
const (
	TagSearchFilterElementDtoTypeBIGQUERYEXTERNAL          TagSearchFilterElementDtoType = "BIGQUERY_EXTERNAL"
	TagSearchFilterElementDtoTypeGENERIC                   TagSearchFilterElementDtoType = "GENERIC"
	TagSearchFilterElementDtoTypeHIDDENDATACLASSIFICATION  TagSearchFilterElementDtoType = "HIDDEN_DATA_CLASSIFICATION"
	TagSearchFilterElementDtoTypeSNOWFLAKEEXTERNAL         TagSearchFilterElementDtoType = "SNOWFLAKE_EXTERNAL"
	TagSearchFilterElementDtoTypeTERM                      TagSearchFilterElementDtoType = "TERM"
	TagSearchFilterElementDtoTypeVISIBLEDATACLASSIFICATION TagSearchFilterElementDtoType = "VISIBLE_DATA_CLASSIFICATION"
)

// Defines values for UpstreamOfFieldDtoType.
const (
	FIELD    UpstreamOfFieldDtoType = "FIELD"
	FUNCTION UpstreamOfFieldDtoType = "FUNCTION"
)

// Defines values for UsageSearchFilterElementDtoId.
const (
	UsageSearchFilterElementDtoIdHIGH        UsageSearchFilterElementDtoId = "HIGH"
	UsageSearchFilterElementDtoIdLOW         UsageSearchFilterElementDtoId = "LOW"
	UsageSearchFilterElementDtoIdMEDIUM      UsageSearchFilterElementDtoId = "MEDIUM"
	UsageSearchFilterElementDtoIdUNSUPPORTED UsageSearchFilterElementDtoId = "UNSUPPORTED"
)

// Defines values for GetAllParamsHealthStatus.
const (
	GetAllParamsHealthStatusATRISK       GetAllParamsHealthStatus = "AT_RISK"
	GetAllParamsHealthStatusCRITICAL     GetAllParamsHealthStatus = "CRITICAL"
	GetAllParamsHealthStatusHEALTHY      GetAllParamsHealthStatus = "HEALTHY"
	GetAllParamsHealthStatusNOTSUPPORTED GetAllParamsHealthStatus = "NOT_SUPPORTED"
	GetAllParamsHealthStatusUNMONITORED  GetAllParamsHealthStatus = "UNMONITORED"
)

// Defines values for GetAllParamsAssetFilterType.
const (
	GetAllParamsAssetFilterTypeDASHBOARD    GetAllParamsAssetFilterType = "DASHBOARD"
	GetAllParamsAssetFilterTypeMONITOR      GetAllParamsAssetFilterType = "MONITOR"
	GetAllParamsAssetFilterTypePIPELINE     GetAllParamsAssetFilterType = "PIPELINE"
	GetAllParamsAssetFilterTypeTABLEANDVIEW GetAllParamsAssetFilterType = "TABLE_AND_VIEW"
)

// Defines values for GetAllParamsUsage.
const (
	GetAllParamsUsageHIGH        GetAllParamsUsage = "HIGH"
	GetAllParamsUsageLOW         GetAllParamsUsage = "LOW"
	GetAllParamsUsageMEDIUM      GetAllParamsUsage = "MEDIUM"
	GetAllParamsUsageUNSUPPORTED GetAllParamsUsage = "UNSUPPORTED"
)

// Defines values for ExportAssetDescriptionsParamsHealthStatus.
const (
	ExportAssetDescriptionsParamsHealthStatusATRISK       ExportAssetDescriptionsParamsHealthStatus = "AT_RISK"
	ExportAssetDescriptionsParamsHealthStatusCRITICAL     ExportAssetDescriptionsParamsHealthStatus = "CRITICAL"
	ExportAssetDescriptionsParamsHealthStatusHEALTHY      ExportAssetDescriptionsParamsHealthStatus = "HEALTHY"
	ExportAssetDescriptionsParamsHealthStatusNOTSUPPORTED ExportAssetDescriptionsParamsHealthStatus = "NOT_SUPPORTED"
	ExportAssetDescriptionsParamsHealthStatusUNMONITORED  ExportAssetDescriptionsParamsHealthStatus = "UNMONITORED"
)

// Defines values for ExportAssetDescriptionsParamsAssetFilterType.
const (
	DASHBOARD    ExportAssetDescriptionsParamsAssetFilterType = "DASHBOARD"
	MONITOR      ExportAssetDescriptionsParamsAssetFilterType = "MONITOR"
	PIPELINE     ExportAssetDescriptionsParamsAssetFilterType = "PIPELINE"
	TABLEANDVIEW ExportAssetDescriptionsParamsAssetFilterType = "TABLE_AND_VIEW"
)

// Defines values for ExportAssetDescriptionsParamsUsage.
const (
	HIGH        ExportAssetDescriptionsParamsUsage = "HIGH"
	LOW         ExportAssetDescriptionsParamsUsage = "LOW"
	MEDIUM      ExportAssetDescriptionsParamsUsage = "MEDIUM"
	UNSUPPORTED ExportAssetDescriptionsParamsUsage = "UNSUPPORTED"
)

// Defines values for GetAllIncidentParamsStatus.
const (
	CLOSED     GetAllIncidentParamsStatus = "CLOSED"
	ONGOING    GetAllIncidentParamsStatus = "ONGOING"
	UNASSIGNED GetAllIncidentParamsStatus = "UNASSIGNED"
)

// Defines values for SiffletRuleRunDownloadByRunParamsExportFormat.
const (
	CSV         SiffletRuleRunDownloadByRunParamsExportFormat = "CSV"
	CSVFOREXCEL SiffletRuleRunDownloadByRunParamsExportFormat = "CSV_FOR_EXCEL"
	TSV         SiffletRuleRunDownloadByRunParamsExportFormat = "TSV"
)

// Defines values for GetAllTagParamsType.
const (
	GetAllTagParamsTypeBIGQUERYEXTERNAL          GetAllTagParamsType = "BIGQUERY_EXTERNAL"
	GetAllTagParamsTypeGENERIC                   GetAllTagParamsType = "GENERIC"
	GetAllTagParamsTypeHIDDENDATACLASSIFICATION  GetAllTagParamsType = "HIDDEN_DATA_CLASSIFICATION"
	GetAllTagParamsTypeSNOWFLAKEEXTERNAL         GetAllTagParamsType = "SNOWFLAKE_EXTERNAL"
	GetAllTagParamsTypeTERM                      GetAllTagParamsType = "TERM"
	GetAllTagParamsTypeVISIBLEDATACLASSIFICATION GetAllTagParamsType = "VISIBLE_DATA_CLASSIFICATION"
)

// AirflowParams defines model for AirflowParams.
type AirflowParams struct {
	Host         *string     `json:"host,omitempty"`
	Port         *string     `json:"port,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// AlertingHookDto defines model for AlertingHookDto.
type AlertingHookDto struct {
	CreatedBy        *string             `json:"createdBy,omitempty"`
	CreatedDate      *int64          `json:"createdDate,omitempty"`
	ExternalHook     *string             `json:"externalHook,omitempty"`
	Id               openapi_types.UUID  `json:"id"`
	LastModifiedDate *int64          `json:"lastModifiedDate,omitempty"`
	ModifiedBy       *string             `json:"modifiedBy,omitempty"`
	Name             string              `json:"name"`
	Type             AlertingHookDtoType `json:"type"`
}

// AlertingHookDtoType defines model for AlertingHookDto.Type.
type AlertingHookDtoType string

// AsCodeWorkspaceDto defines model for AsCodeWorkspaceDto.
type AsCodeWorkspaceDto struct {
	Description *string                 `json:"description,omitempty"`
	Id          openapi_types.UUID      `json:"id"`
	Kind        *AsCodeWorkspaceDtoKind `json:"kind,omitempty"`
	Name        string                  `json:"name"`
	Version     *int32                  `json:"version,omitempty"`
}

// AsCodeWorkspaceDtoKind defines model for AsCodeWorkspaceDto.Kind.
type AsCodeWorkspaceDtoKind string

// AssetDataQualityDto defines model for AssetDataQualityDto.
type AssetDataQualityDto struct {
	Incidents     *map[string]int64                `json:"incidents,omitempty"`
	QualityStatus AssetDataQualityDtoQualityStatus `json:"qualityStatus"`
	Rules         *map[string]int64                `json:"rules,omitempty"`
}

// AssetDataQualityDtoQualityStatus defines model for AssetDataQualityDto.QualityStatus.
type AssetDataQualityDtoQualityStatus string

// AssetDetailsDto defines model for AssetDetailsDto.
type AssetDetailsDto struct {
	DatasourceId         openapi_types.UUID            `json:"datasourceId"`
	DatasourceName       string                        `json:"datasourceName"`
	DatasourceType       AssetDetailsDtoDatasourceType `json:"datasourceType"`
	Description          *string                       `json:"description,omitempty"`
	ExternalDescriptions *[]DescriptionDto             `json:"externalDescriptions,omitempty"`
	HasPreview           bool                          `json:"hasPreview"`
	LastRefresh          *int64                    `json:"lastRefresh,omitempty"`
	NextRefresh          *int64                    `json:"nextRefresh,omitempty"`
	Platform             *string                       `json:"platform,omitempty"`
	Tags                 *[]TagDto                     `json:"tags,omitempty"`
	Terms                *[]TagDto                     `json:"terms,omitempty"`
	Usage                *AssetUsageDto                `json:"usage,omitempty"`
}

// AssetDetailsDtoDatasourceType defines model for AssetDetailsDto.DatasourceType.
type AssetDetailsDtoDatasourceType string

// AssetDto defines model for AssetDto.
type AssetDto struct {
	CreatedBy         *string                    `json:"createdBy,omitempty"`
	CreatedDate       *int64                 `json:"createdDate,omitempty"`
	DatasourceId      *openapi_types.UUID        `json:"datasourceId,omitempty"`
	DatasourceName    *string                    `json:"datasourceName,omitempty"`
	DatasourceType    *string                    `json:"datasourceType,omitempty"`
	DisplayedType     *string                    `json:"displayedType,omitempty"`
	DisplayedTypeEnum *AssetDtoDisplayedTypeEnum `json:"displayedTypeEnum,omitempty"`
	EntityType        *AssetDtoEntityType        `json:"entityType,omitempty"`
	ExternalLink      *string                    `json:"externalLink,omitempty"`
	Id                openapi_types.UUID         `json:"id"`
	LastModifiedDate  *int64                 `json:"lastModifiedDate,omitempty"`
	ModifiedBy        *string                    `json:"modifiedBy,omitempty"`
	Name              string                     `json:"name"`
	QualityStatus     *AssetDtoQualityStatus     `json:"qualityStatus,omitempty"`
	SourceId          *string                    `json:"sourceId,omitempty"`
	Tags              *[]TagDto                  `json:"tags,omitempty"`
	Terms             *[]TagDto                  `json:"terms,omitempty"`
	Urn               string                     `json:"urn"`
	Usage             *AssetUsageDto             `json:"usage,omitempty"`
}

// AssetDtoDisplayedTypeEnum defines model for AssetDto.DisplayedTypeEnum.
type AssetDtoDisplayedTypeEnum string

// AssetDtoEntityType defines model for AssetDto.EntityType.
type AssetDtoEntityType string

// AssetDtoQualityStatus defines model for AssetDto.QualityStatus.
type AssetDtoQualityStatus string

// AssetLightDto defines model for AssetLightDto.
type AssetLightDto struct {
	DatasourceId   openapi_types.UUID      `json:"datasourceId"`
	DatasourceName string                  `json:"datasourceName"`
	DatasourceType string                  `json:"datasourceType"`
	EntityType     AssetLightDtoEntityType `json:"entityType"`
	Id             openapi_types.UUID      `json:"id"`
	Name           string                  `json:"name"`
	Urn            string                  `json:"urn"`
}

// AssetLightDtoEntityType defines model for AssetLightDto.EntityType.
type AssetLightDtoEntityType string

// AssetOrchestratorDto defines model for AssetOrchestratorDto.
type AssetOrchestratorDto struct {
	DatasourceName string                             `json:"datasourceName"`
	DatasourceType AssetOrchestratorDtoDatasourceType `json:"datasourceType"`
}

// AssetOrchestratorDtoDatasourceType defines model for AssetOrchestratorDto.DatasourceType.
type AssetOrchestratorDtoDatasourceType string

// AssetOverview defines model for AssetOverview.
type AssetOverview struct {
	Details *AssetOverview_Details `json:"details,omitempty"`
	Id      *openapi_types.UUID    `json:"id,omitempty"`
	Urn     *string                `json:"urn,omitempty"`
}

// AssetOverview_Details defines model for AssetOverview.Details.
type AssetOverview_Details struct {
	union json.RawMessage
}

// AssetProperties defines model for AssetProperties.
type AssetProperties struct {
	Type AssetPropertiesType `json:"type"`
}

// AssetPropertiesType defines model for AssetProperties.Type.
type AssetPropertiesType string

// AssetSchemaDto defines model for AssetSchemaDto.
type AssetSchemaDto struct {
	Fields *[]FieldNameTypeDto `json:"fields,omitempty"`
}

// AssetSearchFilterElementDto defines model for AssetSearchFilterElementDto.
type AssetSearchFilterElementDto struct {
	Id      *AssetSearchFilterElementDtoId `json:"id,omitempty"`
	Results *int32                         `json:"results,omitempty"`
}

// AssetSearchFilterElementDtoId defines model for AssetSearchFilterElementDto.Id.
type AssetSearchFilterElementDtoId string

// AssetUsageDto defines model for AssetUsageDto.
type AssetUsageDto struct {
	AssetId                 openapi_types.UUID          `json:"assetId"`
	CalculationDate         int64                   `json:"calculationDate"`
	CountRead               int64                       `json:"countRead"`
	EndDay                  int64                   `json:"endDay"`
	Percentile              float32                     `json:"percentile"`
	Qualification           AssetUsageDtoQualification  `json:"qualification"`
	ReadType                AssetUsageDtoReadType       `json:"readType"`
	StartDay                int64                   `json:"startDay"`
	UsagePerDatasourceUsers []UsagePerDatasourceUserDto `json:"usagePerDatasourceUsers"`
}

// AssetUsageDtoQualification defines model for AssetUsageDto.Qualification.
type AssetUsageDtoQualification string

// AssetUsageDtoReadType defines model for AssetUsageDto.ReadType.
type AssetUsageDtoReadType string

// AssetsCatalogDto defines model for AssetsCatalogDto.
type AssetsCatalogDto struct {
	CatalogFilters []BaseSearchFilterDto               `json:"catalogFilters"`
	SearchAssets   SearchCollectionFieldLevelSearchDto `json:"searchAssets"`
}

// AssignOwnersPayload defines model for AssignOwnersPayload.
type AssignOwnersPayload struct {
	NewOwnerIds      *[]openapi_types.UUID `json:"newOwnerIds,omitempty"`
	PreviousOwnerIds *[]openapi_types.UUID `json:"previousOwnerIds,omitempty"`
	Type             *string               `json:"type,omitempty"`
}

// AthenaParams defines model for AthenaParams.
type AthenaParams struct {
	Database         *string     `json:"database,omitempty"`
	Datasource       *string     `json:"datasource,omitempty"`
	Region           *string     `json:"region,omitempty"`
	RoleArn          *string     `json:"roleArn,omitempty"`
	S3OutputLocation *string     `json:"s3OutputLocation,omitempty"`
	TimezoneData     TimeZoneDto `json:"timezoneData"`
	Type             string      `json:"type"`
	VpcUrl           *string     `json:"vpcUrl,omitempty"`
	Workgroup        *string     `json:"workgroup,omitempty"`
}

// BaseSearchFilterDto defines model for BaseSearchFilterDto.
type BaseSearchFilterDto struct {
	Children *[]BaseSearchFilterDto_Children_Item `json:"children,omitempty"`
	Query    *string                              `json:"query,omitempty"`
	Type     *BaseSearchFilterDtoType             `json:"type,omitempty"`
}

// BaseSearchFilterDto_Children_Item defines model for BaseSearchFilterDto.children.Item.
type BaseSearchFilterDto_Children_Item struct {
	union json.RawMessage
}

// BaseSearchFilterDtoType defines model for BaseSearchFilterDto.Type.
type BaseSearchFilterDtoType string

// BaseSearchFilterElementDto defines model for BaseSearchFilterElementDto.
type BaseSearchFilterElementDto struct {
	Results *int32 `json:"results,omitempty"`
}

// BigQueryParams defines model for BigQueryParams.
type BigQueryParams struct {
	BillingProjectId *string     `json:"billingProjectId,omitempty"`
	DatasetId        *string     `json:"datasetId,omitempty"`
	ProjectId        *string     `json:"projectId,omitempty"`
	TimezoneData     TimeZoneDto `json:"timezoneData"`
	Type             string      `json:"type"`
}

// BigQueryPartitionedTableProperties defines model for BigQueryPartitionedTableProperties.
type BigQueryPartitionedTableProperties struct {
	PartitioningProperties *BigQueryPartitioningProperties        `json:"partitioningProperties,omitempty"`
	RequirePartitionFilter *bool                                  `json:"requirePartitionFilter,omitempty"`
	Type                   BigQueryPartitionedTablePropertiesType `json:"type"`
}

// BigQueryPartitionedTablePropertiesType defines model for BigQueryPartitionedTableProperties.Type.
type BigQueryPartitionedTablePropertiesType string

// BigQueryPartitioningProperties defines model for BigQueryPartitioningProperties.
type BigQueryPartitioningProperties struct {
	PartitioningType BigQueryPartitioningPropertiesPartitioningType `json:"partitioningType"`
}

// BigQueryPartitioningPropertiesPartitioningType defines model for BigQueryPartitioningProperties.PartitioningType.
type BigQueryPartitioningPropertiesPartitioningType string

// CatalogFilterDto defines model for CatalogFilterDto.
type CatalogFilterDto struct {
	Children *[]FilterElementDto `json:"children,omitempty"`
	Id       *string             `json:"id,omitempty"`
	Name     *string             `json:"name,omitempty"`
	Query    *string             `json:"query,omitempty"`
}

// ConnectionTestDto defines model for ConnectionTestDto.
type ConnectionTestDto struct {
	Message *string `json:"message,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// CreateCommentPayload defines model for CreateCommentPayload.
type CreateCommentPayload struct {
	Comment *string `json:"comment,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// CreateDatasourceDto defines model for CreateDatasourceDto.
type CreateDatasourceDto struct {
	CronExpression *string                    `json:"cronExpression,omitempty"`
	Description    *string                    `json:"description,omitempty"`
	Name           string                     `json:"name"`
	Params         CreateDatasourceDto_Params `json:"params"`
	SecretId       *string                    `json:"secretId,omitempty"`
	Tags           *[]openapi_types.UUID      `json:"tags,omitempty"`
	Type           string                     `json:"type"`
}

// CreateDatasourceDto_Params defines model for CreateDatasourceDto.Params.
type CreateDatasourceDto_Params struct {
	union json.RawMessage
}

// CreateDomainDto defines model for CreateDomainDto.
type CreateDomainDto struct {
	Assets      []AssetLightDto `json:"assets"`
	Description *string         `json:"description,omitempty"`
	Name        string          `json:"name"`
	Regexs      *[]string       `json:"regexs,omitempty"`
}

// CsvContentDto defines model for CsvContentDto.
type CsvContentDto struct {
	Content *string `json:"content,omitempty"`
}

// DBTCloudParams defines model for DBTCloudParams.
type DBTCloudParams struct {
	AccountId       *string     `json:"accountId,omitempty"`
	BaseUrl         *string     `json:"baseUrl,omitempty"`
	JobDefinitionId *string     `json:"jobDefinitionId,omitempty"`
	ProjectId       *string     `json:"projectId,omitempty"`
	TimezoneData    TimeZoneDto `json:"timezoneData"`
	Type            string      `json:"type"`
}

// DBTParams defines model for DBTParams.
type DBTParams struct {
	ProjectName  *string     `json:"projectName,omitempty"`
	Target       *string     `json:"target,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// DagAssetOverview defines model for DagAssetOverview.
type DagAssetOverview struct {
	Details *DagAssetOverview_Details `json:"details,omitempty"`
	Id      *openapi_types.UUID       `json:"id,omitempty"`
	Type    *DagAssetOverviewType     `json:"type,omitempty"`
	Urn     *string                   `json:"urn,omitempty"`
}

// DagAssetOverview_Details defines model for DagAssetOverview.Details.
type DagAssetOverview_Details struct {
	union json.RawMessage
}

// DagAssetOverviewType defines model for DagAssetOverview.Type.
type DagAssetOverviewType string

// DagDetailsDto defines model for DagDetailsDto.
type DagDetailsDto struct {
	DatasourceId         openapi_types.UUID          `json:"datasourceId"`
	DatasourceName       string                      `json:"datasourceName"`
	DatasourceType       DagDetailsDtoDatasourceType `json:"datasourceType"`
	Description          *string                     `json:"description,omitempty"`
	ExternalDescriptions *[]DescriptionDto           `json:"externalDescriptions,omitempty"`
	HasPreview           bool                        `json:"hasPreview"`
	LastRefresh          *int64                  `json:"lastRefresh,omitempty"`
	NextRefresh          *int64                  `json:"nextRefresh,omitempty"`
	Platform             *string                     `json:"platform,omitempty"`
	Tags                 *[]TagDto                   `json:"tags,omitempty"`
	Tasks                *int32                      `json:"tasks,omitempty"`
	Terms                *[]TagDto                   `json:"terms,omitempty"`
	Usage                *AssetUsageDto              `json:"usage,omitempty"`
}

// DagDetailsDtoDatasourceType defines model for DagDetailsDto.DatasourceType.
type DagDetailsDtoDatasourceType string

// DashboardAssetOverview defines model for DashboardAssetOverview.
type DashboardAssetOverview struct {
	Details *DashboardAssetOverview_Details `json:"details,omitempty"`
	Id      *openapi_types.UUID             `json:"id,omitempty"`
	Type    *DashboardAssetOverviewType     `json:"type,omitempty"`
	Urn     *string                         `json:"urn,omitempty"`
}

// DashboardAssetOverview_Details defines model for DashboardAssetOverview.Details.
type DashboardAssetOverview_Details struct {
	union json.RawMessage
}

// DashboardAssetOverviewType defines model for DashboardAssetOverview.Type.
type DashboardAssetOverviewType string

// DataQualityRuleSummaryDto defines model for DataQualityRuleSummaryDto.
type DataQualityRuleSummaryDto struct {
	RuleStatsByCriticality *map[string]RuleGroupSummaryDto `json:"ruleStatsByCriticality,omitempty"`
	TotalElements          *int64                          `json:"totalElements,omitempty"`
}

// DataStackGroupSummaryDto defines model for DataStackGroupSummaryDto.
type DataStackGroupSummaryDto struct {
	QuantityByType *map[string]int64 `json:"quantityByType,omitempty"`
}

// DataStackSummaryDto defines model for DataStackSummaryDto.
type DataStackSummaryDto struct {
	DataStackGroupByDatasourceType *map[string]DataStackGroupSummaryDto `json:"dataStackGroupByDatasourceType,omitempty"`
}

// DatabricksParams defines model for DatabricksParams.
type DatabricksParams struct {
	Authentication *string     `json:"authentication,omitempty"`
	Catalog        *string     `json:"catalog,omitempty"`
	Host           *string     `json:"host,omitempty"`
	HttpPath       *string     `json:"httpPath,omitempty"`
	Port           *int32      `json:"port,omitempty"`
	Schema         *string     `json:"schema,omitempty"`
	TimezoneData   TimeZoneDto `json:"timezoneData"`
	Type           string      `json:"type"`
}

// DatasetAssetOverview defines model for DatasetAssetOverview.
type DatasetAssetOverview struct {
	DataQuality *AssetDataQualityDto          `json:"dataQuality,omitempty"`
	Details     *DatasetAssetOverview_Details `json:"details,omitempty"`
	Id          *openapi_types.UUID           `json:"id,omitempty"`
	Schema      *AssetSchemaDto               `json:"schema,omitempty"`
	Type        *DatasetAssetOverviewType     `json:"type,omitempty"`
	Urn         *string                       `json:"urn,omitempty"`
}

// DatasetAssetOverview_Details defines model for DatasetAssetOverview.Details.
type DatasetAssetOverview_Details struct {
	union json.RawMessage
}

// DatasetAssetOverviewType defines model for DatasetAssetOverview.Type.
type DatasetAssetOverviewType string

// DatasetBriefDto defines model for DatasetBriefDto.
type DatasetBriefDto struct {
	DatasourceName string             `json:"datasourceName"`
	DatasourceType string             `json:"datasourceType"`
	Id             openapi_types.UUID `json:"id"`
	Name           string             `json:"name"`
	Urn            string             `json:"urn"`
}

// DatasetDetailsDto defines model for DatasetDetailsDto.
type DatasetDetailsDto struct {
	DatasourceId         openapi_types.UUID              `json:"datasourceId"`
	DatasourceName       string                          `json:"datasourceName"`
	DatasourceType       DatasetDetailsDtoDatasourceType `json:"datasourceType"`
	Description          *string                         `json:"description,omitempty"`
	ExternalDescriptions *[]DescriptionDto               `json:"externalDescriptions,omitempty"`
	HasPreview           bool                            `json:"hasPreview"`
	LastRefresh          *int64                      `json:"lastRefresh,omitempty"`
	NextRefresh          *int64                      `json:"nextRefresh,omitempty"`
	Platform             *string                         `json:"platform,omitempty"`
	Size                 *map[string]int64               `json:"size,omitempty"`
	Tags                 *[]TagDto                       `json:"tags,omitempty"`
	Terms                *[]TagDto                       `json:"terms,omitempty"`
	TimeWindow           *TimeWindow                     `json:"timeWindow,omitempty"`
	Transformation       *string                         `json:"transformation,omitempty"`
	Usage                *AssetUsageDto                  `json:"usage,omitempty"`
}

// DatasetDetailsDtoDatasourceType defines model for DatasetDetailsDto.DatasourceType.
type DatasetDetailsDtoDatasourceType string

// DatasetDto defines model for DatasetDto.
type DatasetDto struct {
	CreatedBy         *string                       `json:"createdBy,omitempty"`
	CreatedDate       *int64                    `json:"createdDate,omitempty"`
	Database          *string                       `json:"database,omitempty"`
	DatasetProperties *DatasetDto_DatasetProperties `json:"datasetProperties,omitempty"`
	DatasourceId      *openapi_types.UUID           `json:"datasourceId,omitempty"`
	DatasourceName    *string                       `json:"datasourceName,omitempty"`
	DatasourceType    *string                       `json:"datasourceType,omitempty"`
	DbtDescription    *string                       `json:"dbtDescription,omitempty"`
	Description       *string                       `json:"description,omitempty"`
	DtoDescription    *string                       `json:"dtoDescription,omitempty"`
	EntityType        DatasetDtoEntityType          `json:"entityType"`
	HasARule          *bool                         `json:"hasARule,omitempty"`
	Id                string                        `json:"id"`
	LastModifiedDate  *int64                    `json:"lastModifiedDate,omitempty"`
	ModifiedBy        *string                       `json:"modifiedBy,omitempty"`
	Name              *string                       `json:"name,omitempty"`
	Params            *DatasetParamsDto             `json:"params,omitempty"`
	Schema            *string                       `json:"schema,omitempty"`
	SourceDescription *string                       `json:"sourceDescription,omitempty"`
	Tags              *[]TagDto                     `json:"tags,omitempty"`
	Terms             *[]TagDto                     `json:"terms,omitempty"`
	Transformation    *string                       `json:"transformation,omitempty"`
	Type              *string                       `json:"type,omitempty"`
	Urn               string                        `json:"urn"`
}

// DatasetDto_DatasetProperties defines model for DatasetDto.DatasetProperties.
type DatasetDto_DatasetProperties struct {
	union json.RawMessage
}

// DatasetDtoEntityType defines model for DatasetDto.EntityType.
type DatasetDtoEntityType string

// DatasetFieldPatchDto defines model for DatasetFieldPatchDto.
type DatasetFieldPatchDto struct {
	Description *string               `json:"description,omitempty"`
	TagIds      *[]openapi_types.UUID `json:"tagIds,omitempty"`
	TermIds     *[]openapi_types.UUID `json:"termIds,omitempty"`
}

// DatasetLightDto defines model for DatasetLightDto.
type DatasetLightDto struct {
	DatasourceId   openapi_types.UUID `json:"datasourceId"`
	DatasourceName string             `json:"datasourceName"`
	DatasourceType string             `json:"datasourceType"`
	Id             openapi_types.UUID `json:"id"`
	Name           string             `json:"name"`
	Urn            string             `json:"urn"`
}

// DatasetParamsDto defines model for DatasetParamsDto.
type DatasetParamsDto struct {
	HasOffset           *bool   `json:"hasOffset,omitempty"`
	HasTimeWindow       *bool   `json:"hasTimeWindow,omitempty"`
	OffsetUnit          *string `json:"offsetUnit,omitempty"`
	OffsetValue         *int32  `json:"offsetValue,omitempty"`
	TimeWindowField     *string `json:"timeWindowField,omitempty"`
	TimeWindowFieldType *string `json:"timeWindowFieldType,omitempty"`
	TimeWindowLast      *int32  `json:"timeWindowLast,omitempty"`
	TimeWindowUnit      *string `json:"timeWindowUnit,omitempty"`
}

// DatasourceCatalogAssetDto defines model for DatasourceCatalogAssetDto.
type DatasourceCatalogAssetDto struct {
	CreatedBy        *string                             `json:"createdBy,omitempty"`
	CreatedDate      *int64                          `json:"createdDate,omitempty"`
	CronExpression   *string                             `json:"cronExpression,omitempty"`
	EntityType       DatasourceCatalogAssetDtoEntityType `json:"entityType"`
	Id               openapi_types.UUID                  `json:"id"`
	LastModifiedDate *int64                          `json:"lastModifiedDate,omitempty"`
	LastWeekStatuses *[]LastIngestionStatusDto           `json:"lastWeekStatuses,omitempty"`
	ModifiedBy       *string                             `json:"modifiedBy,omitempty"`
	Name             string                              `json:"name"`
	NextExecution    *int64                          `json:"nextExecution,omitempty"`
	Params           DatasourceCatalogAssetDto_Params    `json:"params"`
	Tags             *[]TagDto                           `json:"tags,omitempty"`
	Type             string                              `json:"type"`
}

// DatasourceCatalogAssetDtoEntityType defines model for DatasourceCatalogAssetDto.EntityType.
type DatasourceCatalogAssetDtoEntityType string

// DatasourceCatalogAssetDto_Params defines model for DatasourceCatalogAssetDto.Params.
type DatasourceCatalogAssetDto_Params struct {
	union json.RawMessage
}

// DatasourceDto defines model for DatasourceDto.
type DatasourceDto struct {
	Catalogued                *bool                   `json:"catalogued,omitempty"`
	CreatedBy                 *string                 `json:"createdBy,omitempty"`
	CreatedDate               *int64              `json:"createdDate,omitempty"`
	CronExpression            *string                 `json:"cronExpression,omitempty"`
	CronExpressionDescription *string                 `json:"cronExpressionDescription,omitempty"`
	Description               *string                 `json:"description,omitempty"`
	EntityType                DatasourceDtoEntityType `json:"entityType"`
	Id                        openapi_types.UUID      `json:"id"`
	KubeCronJobId             *string                 `json:"kubeCronJobId,omitempty"`
	LastIngestionStatus       *LastIngestionStatusDto `json:"lastIngestionStatus,omitempty"`
	LastModifiedDate          *int64              `json:"lastModifiedDate,omitempty"`
	ModifiedBy                *string                 `json:"modifiedBy,omitempty"`
	Name                      string                  `json:"name"`
	NextExecution             *int64              `json:"nextExecution,omitempty"`
	Params                    DatasourceDto_Params    `json:"params"`
	SecretId                  *string                 `json:"secretId,omitempty"`
	Tags                      *[]TagDto               `json:"tags,omitempty"`
	Type                      string                  `json:"type"`
}

// DatasourceDtoEntityType defines model for DatasourceDto.EntityType.
type DatasourceDtoEntityType string

// DatasourceDto_Params defines model for DatasourceDto.Params.
type DatasourceDto_Params struct {
	union json.RawMessage
}

// DatasourceIngestionRunDto defines model for DatasourceIngestionRunDto.
type DatasourceIngestionRunDto struct {
	CreatedBy         *string                              `json:"createdBy,omitempty"`
	CreatedDate       *int64                           `json:"createdDate,omitempty"`
	DurationInSeconds *int64                               `json:"durationInSeconds,omitempty"`
	ExecutionEndDate  *int64                           `json:"executionEndDate,omitempty"`
	Id                openapi_types.UUID                   `json:"id"`
	LastModifiedDate  *int64                           `json:"lastModifiedDate,omitempty"`
	LastStatus        *DatasourceIngestionRunDtoLastStatus `json:"lastStatus,omitempty"`
	ModifiedBy        *string                              `json:"modifiedBy,omitempty"`
	RunSummary        *IngestionRunSummary                 `json:"runSummary,omitempty"`
	Trigger           *string                              `json:"trigger,omitempty"`
}

// DatasourceIngestionRunDtoLastStatus defines model for DatasourceIngestionRunDto.LastStatus.
type DatasourceIngestionRunDtoLastStatus string

// DatasourceParams defines model for DatasourceParams.
type DatasourceParams struct {
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// DatasourceSearchDto defines model for DatasourceSearchDto.
type DatasourceSearchDto struct {
	CatalogFilters    []CatalogFilterDto                        `json:"catalogFilters"`
	SearchDatasources SearchCollectionDatasourceCatalogAssetDto `json:"searchDatasources"`
}

// DescriptionDto defines model for DescriptionDto.
type DescriptionDto struct {
	Description *string                   `json:"description,omitempty"`
	SourceType  *DescriptionDtoSourceType `json:"sourceType,omitempty"`
}

// DescriptionDtoSourceType defines model for DescriptionDto.SourceType.
type DescriptionDtoSourceType string

// DomainDto defines model for DomainDto.
type DomainDto struct {
	Assets           []AssetLightDto    `json:"assets"`
	CreatedBy        *string            `json:"createdBy,omitempty"`
	CreatedDate      *int64         `json:"createdDate,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Id               openapi_types.UUID `json:"id"`
	IsAllDomain      bool               `json:"isAllDomain"`
	LastModifiedDate *int64         `json:"lastModifiedDate,omitempty"`
	ModifiedBy       *string            `json:"modifiedBy,omitempty"`
	Name             string             `json:"name"`
	Regexs           *[]string          `json:"regexs,omitempty"`
}

// EntityUrn defines model for EntityUrn.
type EntityUrn struct {
	Id   *openapi_types.UUID `json:"id,omitempty"`
	Type *EntityUrnType      `json:"type,omitempty"`
}

// EntityUrnType defines model for EntityUrn.Type.
type EntityUrnType string

// EventDto defines model for EventDto.
type EventDto struct {
	CreatedBy    *string             `json:"createdBy,omitempty"`
	CreatedDate  *int64          `json:"createdDate,omitempty"`
	Id           *openapi_types.UUID `json:"id,omitempty"`
	Payload      *EventDto_Payload   `json:"payload,omitempty"`
	PublisherUrn *EntityUrn          `json:"publisherUrn,omitempty"`
	ResourceUrn  *EntityUrn          `json:"resourceUrn,omitempty"`
	Type         *EventDtoType       `json:"type,omitempty"`
}

// EventDto_Payload defines model for EventDto.Payload.
type EventDto_Payload struct {
	union json.RawMessage
}

// EventDtoType defines model for EventDto.Type.
type EventDtoType string

// EventPayload defines model for EventPayload.
type EventPayload struct {
	Type *string `json:"type,omitempty"`
}

// ExternalTableProperties defines model for ExternalTableProperties.
type ExternalTableProperties struct {
	FileType    *string                     `json:"fileType,omitempty"`
	Location    *string                     `json:"location,omitempty"`
	PartitionBy *[]string                   `json:"partitionBy,omitempty"`
	Type        ExternalTablePropertiesType `json:"type"`
}

// ExternalTablePropertiesType defines model for ExternalTableProperties.Type.
type ExternalTablePropertiesType string

// FieldDto defines model for FieldDto.
type FieldDto struct {
	CreatedBy            *string             `json:"createdBy,omitempty"`
	CreatedDate          *int64          `json:"createdDate,omitempty"`
	DatasetId            *openapi_types.UUID `json:"datasetId,omitempty"`
	DatasetName          *string             `json:"datasetName,omitempty"`
	DatasourceName       *string             `json:"datasourceName,omitempty"`
	DatasourceType       *string             `json:"datasourceType,omitempty"`
	DbtDescription       *string             `json:"dbtDescription,omitempty"`
	DdlComment           *string             `json:"ddlComment,omitempty"`
	DefaultValue         *string             `json:"defaultValue,omitempty"`
	Description          *string             `json:"description,omitempty"`
	DisplayType          *string             `json:"displayType,omitempty"`
	EntityType           FieldDtoEntityType  `json:"entityType"`
	Id                   openapi_types.UUID  `json:"id"`
	LastModifiedDate     *int64          `json:"lastModifiedDate,omitempty"`
	ModifiedBy           *string             `json:"modifiedBy,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Nullable             *bool               `json:"nullable,omitempty"`
	ParentDatasetFieldId *openapi_types.UUID `json:"parentDatasetFieldId,omitempty"`
	Repeated             *bool               `json:"repeated,omitempty"`
	Size                 *int32              `json:"size,omitempty"`
	Subfields            *[]FieldDto         `json:"subfields,omitempty"`
	TagNames             *[]string           `json:"tagNames,omitempty"`
	Tags                 *[]TagDto           `json:"tags,omitempty"`
	Terms                *[]TagDto           `json:"terms,omitempty"`
	Type                 *string             `json:"type,omitempty"`
	UpstreamField        *UpstreamOfFieldDto `json:"upstreamField,omitempty"`
}

// FieldDtoEntityType defines model for FieldDto.EntityType.
type FieldDtoEntityType string

// FieldLevelSearchDto defines model for FieldLevelSearchDto.
type FieldLevelSearchDto struct {
	CanDoAutoCoverage    *bool                                     `json:"canDoAutoCoverage,omitempty"`
	DatasourceId         *openapi_types.UUID                       `json:"datasourceId,omitempty"`
	DatasourceName       string                                    `json:"datasourceName"`
	DatasourceType       FieldLevelSearchDtoDatasourceType         `json:"datasourceType"`
	Description          *string                                   `json:"description,omitempty"`
	DisplayedType        FieldLevelSearchDtoDisplayedType          `json:"displayedType"`
	EntityType           FieldLevelSearchDtoEntityType             `json:"entityType"`
	ExternalDescriptions *[]DescriptionDto                         `json:"externalDescriptions,omitempty"`
	Fields               *SearchCollectionFieldLevelSearchFieldDto `json:"fields,omitempty"`
	Health               *FieldLevelSearchDtoHealth                `json:"health,omitempty"`
	Id                   openapi_types.UUID                        `json:"id"`
	MetadataRefresh      *int64                                `json:"metadataRefresh,omitempty"`
	Name                 string                                    `json:"name"`
	SearchWeight         *int32                                    `json:"searchWeight,omitempty"`
	Tags                 *[]TagDto                                 `json:"tags,omitempty"`
	Terms                *[]TagDto                                 `json:"terms,omitempty"`
	Urn                  *string                                   `json:"urn,omitempty"`
	Usage                *FieldLevelSearchDtoUsage                 `json:"usage,omitempty"`
}

// FieldLevelSearchDtoDatasourceType defines model for FieldLevelSearchDto.DatasourceType.
type FieldLevelSearchDtoDatasourceType string

// FieldLevelSearchDtoDisplayedType defines model for FieldLevelSearchDto.DisplayedType.
type FieldLevelSearchDtoDisplayedType string

// FieldLevelSearchDtoEntityType defines model for FieldLevelSearchDto.EntityType.
type FieldLevelSearchDtoEntityType string

// FieldLevelSearchDtoHealth defines model for FieldLevelSearchDto.Health.
type FieldLevelSearchDtoHealth string

// FieldLevelSearchDtoUsage defines model for FieldLevelSearchDto.Usage.
type FieldLevelSearchDtoUsage string

// FieldLevelSearchFieldDto defines model for FieldLevelSearchFieldDto.
type FieldLevelSearchFieldDto struct {
	Description          *string                            `json:"description,omitempty"`
	EntityType           FieldLevelSearchFieldDtoEntityType `json:"entityType"`
	ExternalDescriptions *[]DescriptionDto                  `json:"externalDescriptions,omitempty"`
	Name                 string                             `json:"name"`
}

// FieldLevelSearchFieldDtoEntityType defines model for FieldLevelSearchFieldDto.EntityType.
type FieldLevelSearchFieldDtoEntityType string

// FieldNameTypeDto defines model for FieldNameTypeDto.
type FieldNameTypeDto struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// FilterElementDto defines model for FilterElementDto.
type FilterElementDto struct {
	Id      *string `json:"id,omitempty"`
	Name    string  `json:"name"`
	Results *int32  `json:"results,omitempty"`
}

// FireboltParams defines model for FireboltParams.
type FireboltParams struct {
	Database     *string     `json:"database,omitempty"`
	Engine       *string     `json:"engine,omitempty"`
	Host         *string     `json:"host,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// FivetranParams defines model for FivetranParams.
type FivetranParams struct {
	Host         *string     `json:"host,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// GitConnection defines model for GitConnection.
type GitConnection struct {
	AuthType GitConnectionAuthType `json:"authType"`
	Branch   *string               `json:"branch,omitempty"`
	SecretId string                `json:"secretId"`
	Url      string                `json:"url"`
}

// GitConnectionAuthType defines model for GitConnection.AuthType.
type GitConnectionAuthType string

// GroupIdentifierDto defines model for GroupIdentifierDto.
type GroupIdentifierDto struct {
	Hash   string   `json:"hash"`
	Keys   []string `json:"keys"`
	Values []string `json:"values"`
}

// HealthStatusSearchFilterElementDto defines model for HealthStatusSearchFilterElementDto.
type HealthStatusSearchFilterElementDto struct {
	Id      *HealthStatusSearchFilterElementDtoId `json:"id,omitempty"`
	Results *int32                                `json:"results,omitempty"`
}

// HealthStatusSearchFilterElementDtoId defines model for HealthStatusSearchFilterElementDto.Id.
type HealthStatusSearchFilterElementDtoId string

// HiveParams defines model for HiveParams.
type HiveParams struct {
	AtlasBaseUrl   *string     `json:"atlasBaseUrl,omitempty"`
	AtlasPrincipal *string     `json:"atlasPrincipal,omitempty"`
	Database       *string     `json:"database,omitempty"`
	JdbcUrl        *string     `json:"jdbcUrl,omitempty"`
	Krb5Conf       *string     `json:"krb5Conf,omitempty"`
	Principal      *string     `json:"principal,omitempty"`
	TimezoneData   TimeZoneDto `json:"timezoneData"`
	Type           string      `json:"type"`
}

// ImpactedAssetDto defines model for ImpactedAssetDto.
type ImpactedAssetDto struct {
	DatasourceName string                         `json:"datasourceName"`
	DatasourceType ImpactedAssetDtoDatasourceType `json:"datasourceType"`
	Name           string                         `json:"name"`
	Urn            string                         `json:"urn"`
}

// ImpactedAssetDtoDatasourceType defines model for ImpactedAssetDto.DatasourceType.
type ImpactedAssetDtoDatasourceType string

// ImpactedAssetsSearchDto defines model for ImpactedAssetsSearchDto.
type ImpactedAssetsSearchDto struct {
	LastUpdate   int64                        `json:"lastUpdate"`
	SearchAssets SearchCollectionImpactedAssetDto `json:"searchAssets"`
}

// IncidentGroupSummaryDto defines model for IncidentGroupSummaryDto.
type IncidentGroupSummaryDto struct {
	ComparisonLastWeek *float32 `json:"comparisonLastWeek,omitempty"`
	Percentage         *float32 `json:"percentage,omitempty"`
	TotalIncidents     *int64   `json:"totalIncidents,omitempty"`
}

// IncidentLightDto defines model for IncidentLightDto.
type IncidentLightDto struct {
	CompromisedAssets *int32                  `json:"compromisedAssets,omitempty"`
	Criticality       *int32                  `json:"criticality,omitempty"`
	Datasets          *[]DatasetBriefDto      `json:"datasets,omitempty"`
	Id                *openapi_types.UUID     `json:"id,omitempty"`
	IssueNo           *int32                  `json:"issueNo,omitempty"`
	LastModifiedDate  *int64              `json:"lastModifiedDate,omitempty"`
	Name              *string                 `json:"name,omitempty"`
	Owners            *[]UserDto              `json:"owners,omitempty"`
	RuleLabel         *string                 `json:"ruleLabel,omitempty"`
	Status            *IncidentLightDtoStatus `json:"status,omitempty"`
	TriggerTime       *int64              `json:"triggerTime,omitempty"`
}

// IncidentLightDtoStatus defines model for IncidentLightDto.Status.
type IncidentLightDtoStatus string

// IncidentScope defines model for IncidentScope.
type IncidentScope struct {
	LastOccurredDate *int64              `json:"lastOccurredDate,omitempty"`
	NumberOfFailures *int32                  `json:"numberOfFailures,omitempty"`
	Rule             *RuleInIncidentScopeDto `json:"rule,omitempty"`
	Tables           *[]DatasetDto           `json:"tables,omitempty"`
}

// IncidentSearchDto defines model for IncidentSearchDto.
type IncidentSearchDto struct {
	CatalogFilters  []CatalogFilterDto               `json:"catalogFilters"`
	SearchIncidents SearchCollectionIncidentLightDto `json:"searchIncidents"`
}

// IncidentStatusUpdatePayload defines model for IncidentStatusUpdatePayload.
type IncidentStatusUpdatePayload struct {
	NewStatus     *string                                   `json:"newStatus,omitempty"`
	OldStatus     *string                                   `json:"oldStatus,omitempty"`
	Qualification *IncidentStatusUpdatePayloadQualification `json:"qualification,omitempty"`
	Type          *string                                   `json:"type,omitempty"`
}

// IncidentStatusUpdatePayloadQualification defines model for IncidentStatusUpdatePayload.Qualification.
type IncidentStatusUpdatePayloadQualification string

// IncidentSummaryDto defines model for IncidentSummaryDto.
type IncidentSummaryDto struct {
	AverageResponseRate    *int64                              `json:"averageResponseRate,omitempty"`
	OpenIncidentsByStatus  *map[string]IncidentGroupSummaryDto `json:"openIncidentsByStatus,omitempty"`
	RateComparisonLastWeek *float32                            `json:"rateComparisonLastWeek,omitempty"`
	TotalElements          *int64                              `json:"totalElements,omitempty"`
}

// IngestionRunSummary defines model for IngestionRunSummary.
type IngestionRunSummary struct {
	Errors *[]string `json:"errors,omitempty"`
}

// IssueDetailsDto defines model for IssueDetailsDto.
type IssueDetailsDto struct {
	CreatedBy        *string                       `json:"createdBy,omitempty"`
	CreatedDate      *int64                    `json:"createdDate,omitempty"`
	Criticality      *IssueDetailsDtoCriticality   `json:"criticality,omitempty"`
	Id               openapi_types.UUID            `json:"id"`
	IssueNo          *int32                        `json:"issueNo,omitempty"`
	LastModifiedDate *int64                    `json:"lastModifiedDate,omitempty"`
	ModifiedBy       *string                       `json:"modifiedBy,omitempty"`
	Name             *string                       `json:"name,omitempty"`
	Owners           *[]UserDto                    `json:"owners,omitempty"`
	Qualification    *IssueDetailsDtoQualification `json:"qualification,omitempty"`
	Status           *IssueDetailsDtoStatus        `json:"status,omitempty"`
}

// IssueDetailsDtoCriticality defines model for IssueDetailsDto.Criticality.
type IssueDetailsDtoCriticality string

// IssueDetailsDtoQualification defines model for IssueDetailsDto.Qualification.
type IssueDetailsDtoQualification string

// IssueDetailsDtoStatus defines model for IssueDetailsDto.Status.
type IssueDetailsDtoStatus string

// LastIngestionStatusDto defines model for LastIngestionStatusDto.
type LastIngestionStatusDto struct {
	Status    LastIngestionStatusDtoStatus `json:"status"`
	Timestamp int64                    `json:"timestamp"`
}

// LastIngestionStatusDtoStatus defines model for LastIngestionStatusDto.Status.
type LastIngestionStatusDtoStatus string

// LineageAttachedEntity defines model for LineageAttachedEntity.
type LineageAttachedEntity struct {
	DatasourceType LineageAttachedEntityDatasourceType `json:"datasourceType"`
	Name           string                              `json:"name"`
	Type           LineageAttachedEntityType           `json:"type"`
	Urn            string                              `json:"urn"`
}

// LineageAttachedEntityDatasourceType defines model for LineageAttachedEntity.DatasourceType.
type LineageAttachedEntityDatasourceType string

// LineageAttachedEntityType defines model for LineageAttachedEntity.Type.
type LineageAttachedEntityType string

// LineageEntityDto defines model for LineageEntityDto.
type LineageEntityDto struct {
	AccessAuthorized *bool                      `json:"accessAuthorized,omitempty"`
	AttachedEntity   *LineageAttachedEntity     `json:"attachedEntity,omitempty"`
	Children         []LineageEntityDto         `json:"children"`
	DatasourceName   string                     `json:"datasourceName"`
	Downstreams      []LineageUrnDto            `json:"downstreams"`
	EntityType       LineageEntityDtoEntityType `json:"entityType"`
	FullName         string                     `json:"fullName"`
	HasInformation   bool                       `json:"hasInformation"`
	Health           LineageEntityDtoHealth     `json:"health"`
	Id               string                     `json:"id"`
	Platform         string                     `json:"platform"`
	Title            string                     `json:"title"`
	Type             string                     `json:"type"`
	Upstreams        []LineageUrnDto            `json:"upstreams"`
	Urn              string                     `json:"urn"`
}

// LineageEntityDtoEntityType defines model for LineageEntityDto.EntityType.
type LineageEntityDtoEntityType string

// LineageEntityDtoHealth defines model for LineageEntityDto.Health.
type LineageEntityDtoHealth string

// LineageUrnDto defines model for LineageUrnDto.
type LineageUrnDto struct {
	CreationMethod LineageUrnDtoCreationMethod `json:"creationMethod"`
	Urn            string                      `json:"urn"`
}

// LineageUrnDtoCreationMethod defines model for LineageUrnDto.CreationMethod.
type LineageUrnDtoCreationMethod string

// LookerParams defines model for LookerParams.
type LookerParams struct {
	GitConnections *[]GitConnection `json:"gitConnections,omitempty"`
	Host           *string          `json:"host,omitempty"`
	TimezoneData   TimeZoneDto      `json:"timezoneData"`
	Type           string           `json:"type"`
}

// ModelAssetOverview defines model for ModelAssetOverview.
type ModelAssetOverview struct {
	Details      *ModelAssetOverview_Details `json:"details,omitempty"`
	Id           *openapi_types.UUID         `json:"id,omitempty"`
	Orchestrator *AssetOrchestratorDto       `json:"orchestrator,omitempty"`
	Type         *ModelAssetOverviewType     `json:"type,omitempty"`
	Urn          *string                     `json:"urn,omitempty"`
}

// ModelAssetOverview_Details defines model for ModelAssetOverview.Details.
type ModelAssetOverview_Details struct {
	union json.RawMessage
}

// ModelAssetOverviewType defines model for ModelAssetOverview.Type.
type ModelAssetOverviewType string

// MssqlParams defines model for MssqlParams.
type MssqlParams struct {
	Database     *string     `json:"database,omitempty"`
	Host         *string     `json:"host,omitempty"`
	Port         *int32      `json:"port,omitempty"`
	Schema       *string     `json:"schema,omitempty"`
	Ssl          *bool       `json:"ssl,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// MysqlParams defines model for MysqlParams.
type MysqlParams struct {
	Database        *string                     `json:"database,omitempty"`
	Host            *string                     `json:"host,omitempty"`
	MysqlTlsVersion *MysqlParamsMysqlTlsVersion `json:"mysqlTlsVersion,omitempty"`
	Port            *int32                      `json:"port,omitempty"`
	TimezoneData    TimeZoneDto                 `json:"timezoneData"`
	Type            string                      `json:"type"`
}

// MysqlParamsMysqlTlsVersion defines model for MysqlParams.MysqlTlsVersion.
type MysqlParamsMysqlTlsVersion string

// OracleParams defines model for OracleParams.
type OracleParams struct {
	Database     *string     `json:"database,omitempty"`
	Host         *string     `json:"host,omitempty"`
	Port         *int32      `json:"port,omitempty"`
	Schema       *string     `json:"schema,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// ParameterizedQueryDto defines model for ParameterizedQueryDto.
type ParameterizedQueryDto struct {
	PositionalParameters []PositionalParameterDto `json:"positionalParameters"`
	Query                string                   `json:"query"`
}

// PlatformSearchFilterElementDto defines model for PlatformSearchFilterElementDto.
type PlatformSearchFilterElementDto struct {
	Children *[]UuidSearchFilterElementDto     `json:"children,omitempty"`
	Id       *PlatformSearchFilterElementDtoId `json:"id,omitempty"`
	Results  *int32                            `json:"results,omitempty"`
}

// PlatformSearchFilterElementDtoId defines model for PlatformSearchFilterElementDto.Id.
type PlatformSearchFilterElementDtoId string

// PositionalParameterDto defines model for PositionalParameterDto.
type PositionalParameterDto struct {
	Value *map[string]interface{} `json:"value,omitempty"`
}

// PostgresqlParams defines model for PostgresqlParams.
type PostgresqlParams struct {
	Database     *string     `json:"database,omitempty"`
	Host         *string     `json:"host,omitempty"`
	Port         *int32      `json:"port,omitempty"`
	Schema       *string     `json:"schema,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// PowerBiParams defines model for PowerBiParams.
type PowerBiParams struct {
	ClientId     *string     `json:"clientId,omitempty"`
	TenantId     *string     `json:"tenantId,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
	WorkspaceId  *string     `json:"workspaceId,omitempty"`
}

// Problem defines model for Problem.
type Problem struct {
	Detail     *string                            `json:"detail,omitempty"`
	Instance   *string                            `json:"instance,omitempty"`
	Parameters *map[string]map[string]interface{} `json:"parameters,omitempty"`
	Status     *StatusType                        `json:"status,omitempty"`
	Title      *string                            `json:"title,omitempty"`
	Type       *string                            `json:"type,omitempty"`
}

// QuickSightParams defines model for QuickSightParams.
type QuickSightParams struct {
	AccountId    *string     `json:"accountId,omitempty"`
	AwsRegion    *string     `json:"awsRegion,omitempty"`
	RoleArn      *string     `json:"roleArn,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// RedshiftParams defines model for RedshiftParams.
type RedshiftParams struct {
	Database     *string     `json:"database,omitempty"`
	Host         *string     `json:"host,omitempty"`
	Port         *int32      `json:"port,omitempty"`
	Schema       *string     `json:"schema,omitempty"`
	Ssl          *bool       `json:"ssl,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// RuleDto defines model for RuleDto.
type RuleDto struct {
	Category         *string                 `json:"category,omitempty"`
	Criticality      *int32                  `json:"criticality,omitempty"`
	Datasets         *[]DatasetLightDto      `json:"datasets,omitempty"`
	Description      *string                 `json:"description,omitempty"`
	Id               *openapi_types.UUID     `json:"id,omitempty"`
	InputValues      *map[string]interface{} `json:"inputValues,omitempty"`
	Mails            *[]AlertingHookDto      `json:"mails,omitempty"`
	Message          *string                 `json:"message,omitempty"`
	MsTeams          *[]AlertingHookDto      `json:"msTeams,omitempty"`
	Name             string                  `json:"name"`
	RuleTemplateName string                  `json:"ruleTemplateName"`
	Schedule         *string                 `json:"schedule,omitempty"`
	SlackChannels    *[]AlertingHookDto      `json:"slackChannels,omitempty"`
	Tags             *[]TagDto               `json:"tags,omitempty"`
	Terms            *[]TagDto               `json:"terms,omitempty"`
}

// RuleGroupRequestDto defines model for RuleGroupRequestDto.
type RuleGroupRequestDto struct {
	Group *GroupIdentifierDto `json:"group,omitempty"`
}

// RuleGroupSummaryDto defines model for RuleGroupSummaryDto.
type RuleGroupSummaryDto struct {
	AverageResponseTime *int64 `json:"averageResponseTime,omitempty"`
	OpenIncidents       *int64 `json:"openIncidents,omitempty"`
	TotalRules          *int64 `json:"totalRules,omitempty"`
	UnassignedIncidents *int64 `json:"unassignedIncidents,omitempty"`
}

// RuleInIncidentScopeDto defines model for RuleInIncidentScopeDto.
type RuleInIncidentScopeDto struct {
	Datasets *[]DatasetLightDto  `json:"datasets,omitempty"`
	Id       *openapi_types.UUID `json:"id,omitempty"`
	Name     string              `json:"name"`
}

// RuleRunDebugDto defines model for RuleRunDebugDto.
type RuleRunDebugDto struct {
	RowCount   *int64  `json:"rowCount,omitempty"`
	RowJsonStr *string `json:"rowJsonStr,omitempty"`
}

// RuleRunDetailsByGroupDto defines model for RuleRunDetailsByGroupDto.
type RuleRunDetailsByGroupDto struct {
	DebugSql  *ParameterizedQueryDto             `json:"debugSql,omitempty"`
	Dimension *string                            `json:"dimension,omitempty"`
	GraphType *RuleRunDetailsByGroupDtoGraphType `json:"graphType,omitempty"`
	Group     GroupIdentifierDto                 `json:"group"`
	Result    *string                            `json:"result,omitempty"`
	Status    *RuleRunDetailsByGroupDtoStatus    `json:"status,omitempty"`
}

// RuleRunDetailsByGroupDtoGraphType defines model for RuleRunDetailsByGroupDto.GraphType.
type RuleRunDetailsByGroupDtoGraphType string

// RuleRunDetailsByGroupDtoStatus defines model for RuleRunDetailsByGroupDto.Status.
type RuleRunDetailsByGroupDtoStatus string

// RuleTemplateLightDto defines model for RuleTemplateLightDto.
type RuleTemplateLightDto struct {
	Label *string `json:"label,omitempty"`
	Name  string  `json:"name"`
}

// SearchCollectionAssetLightDto defines model for SearchCollectionAssetLightDto.
type SearchCollectionAssetLightDto struct {
	Data          *[]AssetLightDto `json:"data,omitempty"`
	TotalElements *int64           `json:"totalElements,omitempty"`
}

// SearchCollectionDatasetLightDto defines model for SearchCollectionDatasetLightDto.
type SearchCollectionDatasetLightDto struct {
	Data          *[]DatasetLightDto `json:"data,omitempty"`
	TotalElements *int64             `json:"totalElements,omitempty"`
}

// SearchCollectionDatasourceCatalogAssetDto defines model for SearchCollectionDatasourceCatalogAssetDto.
type SearchCollectionDatasourceCatalogAssetDto struct {
	Data          *[]DatasourceCatalogAssetDto `json:"data,omitempty"`
	TotalElements *int64                       `json:"totalElements,omitempty"`
}

// SearchCollectionDatasourceIngestionRunDto defines model for SearchCollectionDatasourceIngestionRunDto.
type SearchCollectionDatasourceIngestionRunDto struct {
	Data          *[]DatasourceIngestionRunDto `json:"data,omitempty"`
	TotalElements *int64                       `json:"totalElements,omitempty"`
}

// SearchCollectionDomainDto defines model for SearchCollectionDomainDto.
type SearchCollectionDomainDto struct {
	Data          *[]DomainDto `json:"data,omitempty"`
	TotalElements *int64       `json:"totalElements,omitempty"`
}

// SearchCollectionFieldLevelSearchDto defines model for SearchCollectionFieldLevelSearchDto.
type SearchCollectionFieldLevelSearchDto struct {
	Data          *[]FieldLevelSearchDto `json:"data,omitempty"`
	TotalElements *int64                 `json:"totalElements,omitempty"`
}

// SearchCollectionFieldLevelSearchFieldDto defines model for SearchCollectionFieldLevelSearchFieldDto.
type SearchCollectionFieldLevelSearchFieldDto struct {
	Data          *[]FieldLevelSearchFieldDto `json:"data,omitempty"`
	TotalElements *int64                      `json:"totalElements,omitempty"`
}

// SearchCollectionImpactedAssetDto defines model for SearchCollectionImpactedAssetDto.
type SearchCollectionImpactedAssetDto struct {
	Data          *[]ImpactedAssetDto `json:"data,omitempty"`
	TotalElements *int64              `json:"totalElements,omitempty"`
}

// SearchCollectionIncidentLightDto defines model for SearchCollectionIncidentLightDto.
type SearchCollectionIncidentLightDto struct {
	Data          *[]IncidentLightDto `json:"data,omitempty"`
	TotalElements *int64              `json:"totalElements,omitempty"`
}

// SearchCollectionRuleRunDetailsByGroupDto defines model for SearchCollectionRuleRunDetailsByGroupDto.
type SearchCollectionRuleRunDetailsByGroupDto struct {
	Data          *[]RuleRunDetailsByGroupDto `json:"data,omitempty"`
	TotalElements *int64                      `json:"totalElements,omitempty"`
}

// SearchCollectionTagDto defines model for SearchCollectionTagDto.
type SearchCollectionTagDto struct {
	Data          *[]TagDto `json:"data,omitempty"`
	TotalElements *int64    `json:"totalElements,omitempty"`
}

// SecretDto defines model for SecretDto.
type SecretDto struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
	Value       *string `json:"value,omitempty"`
}

// SnowflakeParams defines model for SnowflakeParams.
type SnowflakeParams struct {
	AccountIdentifier *string     `json:"accountIdentifier,omitempty"`
	Database          *string     `json:"database,omitempty"`
	Schema            *string     `json:"schema,omitempty"`
	TimezoneData      TimeZoneDto `json:"timezoneData"`
	Type              string      `json:"type"`
	Warehouse         *string     `json:"warehouse,omitempty"`
}

// SnowflakeStreamProperties defines model for SnowflakeStreamProperties.
type SnowflakeStreamProperties struct {
	CreatedDate   *int64                    `json:"createdDate,omitempty"`
	InvalidReason *string                       `json:"invalidReason,omitempty"`
	Mode          *string                       `json:"mode,omitempty"`
	Owner         *string                       `json:"owner,omitempty"`
	Stale         *bool                         `json:"stale,omitempty"`
	StaleAfter    *int64                    `json:"staleAfter,omitempty"`
	StreamType    *string                       `json:"streamType,omitempty"`
	TableName     *string                       `json:"tableName,omitempty"`
	Type          SnowflakeStreamPropertiesType `json:"type"`
}

// SnowflakeStreamPropertiesType defines model for SnowflakeStreamProperties.Type.
type SnowflakeStreamPropertiesType string

// StatusType defines model for StatusType.
type StatusType struct {
	ReasonPhrase *string `json:"reasonPhrase,omitempty"`
	StatusCode   *int32  `json:"statusCode,omitempty"`
}

// StatusUpdatePayload defines model for StatusUpdatePayload.
type StatusUpdatePayload struct {
	NewStatus *string `json:"newStatus,omitempty"`
	OldStatus *string `json:"oldStatus,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// TableauParams defines model for TableauParams.
type TableauParams struct {
	Host         *string     `json:"host,omitempty"`
	Site         *string     `json:"site,omitempty"`
	TimezoneData TimeZoneDto `json:"timezoneData"`
	Type         string      `json:"type"`
}

// TagCreateDto defines model for TagCreateDto.
type TagCreateDto struct {
	Description *string          `json:"description,omitempty"`
	Name        string           `json:"name"`
	Type        TagCreateDtoType `json:"type"`
}

// TagCreateDtoType defines model for TagCreateDto.Type.
type TagCreateDtoType string

// TagDto defines model for TagDto.
type TagDto struct {
	CreatedBy        *string            `json:"createdBy,omitempty"`
	CreatedDate      *int64         `json:"createdDate,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Editable         *bool              `json:"editable,omitempty"`
	Id               openapi_types.UUID `json:"id"`
	LastModifiedDate *int64         `json:"lastModifiedDate,omitempty"`
	ModifiedBy       *string            `json:"modifiedBy,omitempty"`
	Name             string             `json:"name"`
	Type             TagDtoType         `json:"type"`
}

// TagDtoType defines model for TagDto.Type.
type TagDtoType string

// TagSearchFilterElementDto defines model for TagSearchFilterElementDto.
type TagSearchFilterElementDto struct {
	Id      *openapi_types.UUID            `json:"id,omitempty"`
	Name    *string                        `json:"name,omitempty"`
	Results *int32                         `json:"results,omitempty"`
	Type    *TagSearchFilterElementDtoType `json:"type,omitempty"`
}

// TagSearchFilterElementDtoType defines model for TagSearchFilterElementDto.Type.
type TagSearchFilterElementDtoType string

// TagUpdateDto defines model for TagUpdateDto.
type TagUpdateDto struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// TimeWindow defines model for TimeWindow.
type TimeWindow struct {
	HasOffset           *bool   `json:"hasOffset,omitempty"`
	HasTimeWindow       *bool   `json:"hasTimeWindow,omitempty"`
	OffsetUnit          *string `json:"offsetUnit,omitempty"`
	OffsetValue         *int32  `json:"offsetValue,omitempty"`
	TimeWindowField     *string `json:"timeWindowField,omitempty"`
	TimeWindowFieldType *string `json:"timeWindowFieldType,omitempty"`
	TimeWindowLast      *int32  `json:"timeWindowLast,omitempty"`
	TimeWindowUnit      *string `json:"timeWindowUnit,omitempty"`
}

// TimeZoneDto defines model for TimeZoneDto.
type TimeZoneDto struct {
	Timezone  string `json:"timezone"`
	UtcOffset string `json:"utcOffset"`
}

// UnknownDatasourceParams defines model for UnknownDatasourceParams.
type UnknownDatasourceParams = DatasourceParams

// UpdateDomainDto defines model for UpdateDomainDto.
type UpdateDomainDto struct {
	Assets      []AssetLightDto `json:"assets"`
	Description *string         `json:"description,omitempty"`
	Name        string          `json:"name"`
	Regexs      *[]string       `json:"regexs,omitempty"`
}

// UpstreamOfFieldDto defines model for UpstreamOfFieldDto.
type UpstreamOfFieldDto struct {
	Type *UpstreamOfFieldDtoType `json:"type,omitempty"`
}

// UpstreamOfFieldDtoType defines model for UpstreamOfFieldDto.Type.
type UpstreamOfFieldDtoType string

// UsagePerDatasourceUserDto defines model for UsagePerDatasourceUserDto.
type UsagePerDatasourceUserDto struct {
	CountRead int64  `json:"countRead"`
	UserName  string `json:"userName"`
}

// UsageSearchFilterElementDto defines model for UsageSearchFilterElementDto.
type UsageSearchFilterElementDto struct {
	Id      *UsageSearchFilterElementDtoId `json:"id,omitempty"`
	Results *int32                         `json:"results,omitempty"`
}

// UsageSearchFilterElementDtoId defines model for UsageSearchFilterElementDto.Id.
type UsageSearchFilterElementDtoId string

// UserDto defines model for UserDto.
type UserDto struct {
	Id    *openapi_types.UUID `json:"id,omitempty"`
	Login *string             `json:"login,omitempty"`
	Name  *string             `json:"name,omitempty"`
}

// UuidSearchFilterElementDto defines model for UuidSearchFilterElementDto.
type UuidSearchFilterElementDto struct {
	Id      *openapi_types.UUID `json:"id,omitempty"`
	Name    *string             `json:"name,omitempty"`
	Results *int32              `json:"results,omitempty"`
}

// GetAllParams defines parameters for GetAll.
type GetAllParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// HealthStatus Filter on given health statuses
	HealthStatus *[]GetAllParamsHealthStatus `form:"healthStatus,omitempty" json:"healthStatus,omitempty"`

	// AssetFilterType Filter on given asset types
	AssetFilterType *[]GetAllParamsAssetFilterType `form:"assetFilterType,omitempty" json:"assetFilterType,omitempty"`

	// Usage Filter on given usage types
	Usage *[]GetAllParamsUsage `form:"usage,omitempty" json:"usage,omitempty"`

	// Tag Filter on given tag ids
	Tag *[]openapi_types.UUID `form:"tag,omitempty" json:"tag,omitempty"`

	// Term Filter on given term ids
	Term *[]openapi_types.UUID `form:"term,omitempty" json:"term,omitempty"`

	// Datasource Filter on given datasource ids
	Datasource *[]openapi_types.UUID `form:"datasource,omitempty" json:"datasource,omitempty"`

	// Domain Domain searched
	Domain *string `form:"domain,omitempty" json:"domain,omitempty"`

	// SearchInFieldsAndDescriptions Search on fields and field descriptions
	SearchInFieldsAndDescriptions *bool `form:"searchInFieldsAndDescriptions,omitempty" json:"searchInFieldsAndDescriptions,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetAllParamsHealthStatus defines parameters for GetAll.
type GetAllParamsHealthStatus string

// GetAllParamsAssetFilterType defines parameters for GetAll.
type GetAllParamsAssetFilterType string

// GetAllParamsUsage defines parameters for GetAll.
type GetAllParamsUsage string

// ExportAssetDescriptionsParams defines parameters for ExportAssetDescriptions.
type ExportAssetDescriptionsParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// HealthStatus Filter on given health statuses
	HealthStatus *[]ExportAssetDescriptionsParamsHealthStatus `form:"healthStatus,omitempty" json:"healthStatus,omitempty"`

	// AssetFilterType Filter on given asset types
	AssetFilterType *[]ExportAssetDescriptionsParamsAssetFilterType `form:"assetFilterType,omitempty" json:"assetFilterType,omitempty"`

	// Usage Filter on given usage types
	Usage *[]ExportAssetDescriptionsParamsUsage `form:"usage,omitempty" json:"usage,omitempty"`

	// Tag Filter on given tag ids
	Tag *[]openapi_types.UUID `form:"tag,omitempty" json:"tag,omitempty"`

	// Term Filter on given term ids
	Term *[]openapi_types.UUID `form:"term,omitempty" json:"term,omitempty"`

	// Datasource Filter on given datasource ids
	Datasource *[]openapi_types.UUID `form:"datasource,omitempty" json:"datasource,omitempty"`

	// Domain Domain searched
	Domain *string `form:"domain,omitempty" json:"domain,omitempty"`

	// SearchInFieldsAndDescriptions Search on fields and field descriptions
	SearchInFieldsAndDescriptions *bool `form:"searchInFieldsAndDescriptions,omitempty" json:"searchInFieldsAndDescriptions,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// ExportAssetDescriptionsParamsHealthStatus defines parameters for ExportAssetDescriptions.
type ExportAssetDescriptionsParamsHealthStatus string

// ExportAssetDescriptionsParamsAssetFilterType defines parameters for ExportAssetDescriptions.
type ExportAssetDescriptionsParamsAssetFilterType string

// ExportAssetDescriptionsParamsUsage defines parameters for ExportAssetDescriptions.
type ExportAssetDescriptionsParamsUsage string

// GetAllLightParams defines parameters for GetAllLight.
type GetAllLightParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// Urn Filter on given urns
	Urn *[]string `form:"urn,omitempty" json:"urn,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetAllDatasetParams defines parameters for GetAllDataset.
type GetAllDatasetParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// Urn Filter on given urns
	Urn *[]string `form:"urn,omitempty" json:"urn,omitempty"`

	// Domain Domain searched
	Domain *string `form:"domain,omitempty" json:"domain,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetAllDatasourceParams defines parameters for GetAllDatasource.
type GetAllDatasourceParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// Tag Filter on given tag ids
	Tag *[]openapi_types.UUID `form:"tag,omitempty" json:"tag,omitempty"`

	// DatasourceType Filter on given datasource types
	DatasourceType *[]string `form:"datasourceType,omitempty" json:"datasourceType,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetDatasourceIngestionRunsParams defines parameters for GetDatasourceIngestionRuns.
type GetDatasourceIngestionRunsParams struct {
	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetAllDomainsParams defines parameters for GetAllDomains.
type GetAllDomainsParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetAllIncidentParams defines parameters for GetAllIncident.
type GetAllIncidentParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// From Retrieve incidents from the given start date
	From *int64 `form:"from,omitempty" json:"from,omitempty"`

	// To Retrieve incidents up to a given end date
	To          *int64 `form:"to,omitempty" json:"to,omitempty"`
	Criticality *[]int32   `form:"criticality,omitempty" json:"criticality,omitempty"`

	// Status Filter on given statuses
	Status *[]GetAllIncidentParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// User Filter on given user ids
	User *[]openapi_types.UUID `form:"user,omitempty" json:"user,omitempty"`

	// Rule Filter on given rule type
	Rule *[]openapi_types.UUID `form:"rule,omitempty" json:"rule,omitempty"`

	// Dataset Filter on given dataset ids
	Dataset *[]openapi_types.UUID `form:"dataset,omitempty" json:"dataset,omitempty"`

	// Domain Domain searched
	Domain *string `form:"domain,omitempty" json:"domain,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetAllIncidentParamsStatus defines parameters for GetAllIncident.
type GetAllIncidentParamsStatus string

// GetDownstreamImpactedAssetsParams defines parameters for GetDownstreamImpactedAssets.
type GetDownstreamImpactedAssetsParams struct {
	// IssueNo Retrieve impacted assets related to a given incident
	IssueNo *int32 `form:"issueNo,omitempty" json:"issueNo,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// SiffletRuleRunDownloadByRunParams defines parameters for SiffletRuleRunDownloadByRun.
type SiffletRuleRunDownloadByRunParams struct {
	ExportFormat *SiffletRuleRunDownloadByRunParamsExportFormat `form:"exportFormat,omitempty" json:"exportFormat,omitempty"`
}

// SiffletRuleRunDownloadByRunParamsExportFormat defines parameters for SiffletRuleRunDownloadByRun.
type SiffletRuleRunDownloadByRunParamsExportFormat string

// GetSiffletRuleRunDetailsParams defines parameters for GetSiffletRuleRunDetails.
type GetSiffletRuleRunDetailsParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// DeleteSecretParams defines parameters for DeleteSecret.
type DeleteSecretParams struct {
	Name string `form:"name" json:"name"`
}

// GetSecretParams defines parameters for GetSecret.
type GetSecretParams struct {
	Name string `form:"name" json:"name"`
}

// GetDataStackParams defines parameters for GetDataStack.
type GetDataStackParams struct {
	// Domain Domain used for stats
	Domain *string `form:"domain,omitempty" json:"domain,omitempty"`
}

// GetIncidentsSummaryParams defines parameters for GetIncidentsSummary.
type GetIncidentsSummaryParams struct {
	// Domain Domain used for stats
	Domain *string `form:"domain,omitempty" json:"domain,omitempty"`
}

// GetRulesSummaryParams defines parameters for GetRulesSummary.
type GetRulesSummaryParams struct {
	// Domain Domain used for stats
	Domain *string `form:"domain,omitempty" json:"domain,omitempty"`
}

// GetAllTagParams defines parameters for GetAllTag.
type GetAllTagParams struct {
	// Type Filter on given tag types
	Type *[]GetAllTagParamsType `form:"type,omitempty" json:"type,omitempty"`

	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetAllTagParamsType defines parameters for GetAllTag.
type GetAllTagParamsType string

// GetAllTermParams defines parameters for GetAllTerm.
type GetAllTermParams struct {
	// TextSearch Global text search
	TextSearch *string `form:"textSearch,omitempty" json:"textSearch,omitempty"`

	// Page The requested page number. Zero-based page index (0..N)
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// ItemsPerPage The number of elements to be returned inside the page. Pass a value of -1, to bypass pagination and fetch all items
	ItemsPerPage *int32 `form:"itemsPerPage,omitempty" json:"itemsPerPage,omitempty"`

	// Sort The resource fields on which to apply the sort, format : property,ASC|DESC
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`
}

// UpdateDatasetFieldJSONRequestBody defines body for UpdateDatasetField for application/json ContentType.
type UpdateDatasetFieldJSONRequestBody = DatasetFieldPatchDto

// CreateDatasourceJSONRequestBody defines body for CreateDatasource for application/json ContentType.
type CreateDatasourceJSONRequestBody = CreateDatasourceDto

// TestDatasourceConnectionJSONRequestBody defines body for TestDatasourceConnection for application/json ContentType.
type TestDatasourceConnectionJSONRequestBody = DatasourceDto

// CreateDomainJSONRequestBody defines body for CreateDomain for application/json ContentType.
type CreateDomainJSONRequestBody = CreateDomainDto

// UpdateDomainJSONRequestBody defines body for UpdateDomain for application/json ContentType.
type UpdateDomainJSONRequestBody = UpdateDomainDto

// SiffletRuleRunDebugJSONRequestBody defines body for SiffletRuleRunDebug for application/json ContentType.
type SiffletRuleRunDebugJSONRequestBody = RuleGroupRequestDto

// SiffletRuleRunDownloadByRunJSONRequestBody defines body for SiffletRuleRunDownloadByRun for application/json ContentType.
type SiffletRuleRunDownloadByRunJSONRequestBody = RuleGroupRequestDto

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = TagCreateDto

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = TagUpdateDto

// CreateTermJSONRequestBody defines body for CreateTerm for application/json ContentType.
type CreateTermJSONRequestBody = TagCreateDto

// UpdateTermJSONRequestBody defines body for UpdateTerm for application/json ContentType.
type UpdateTermJSONRequestBody = TagUpdateDto

// AsAssetDetailsDto returns the union data inside the AssetOverview_Details as a AssetDetailsDto
func (t AssetOverview_Details) AsAssetDetailsDto() (AssetDetailsDto, error) {
	var body AssetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssetDetailsDto overwrites any union data inside the AssetOverview_Details as the provided AssetDetailsDto
func (t *AssetOverview_Details) FromAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssetDetailsDto performs a merge with any union data inside the AssetOverview_Details, using the provided AssetDetailsDto
func (t *AssetOverview_Details) MergeAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDagDetailsDto returns the union data inside the AssetOverview_Details as a DagDetailsDto
func (t AssetOverview_Details) AsDagDetailsDto() (DagDetailsDto, error) {
	var body DagDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDagDetailsDto overwrites any union data inside the AssetOverview_Details as the provided DagDetailsDto
func (t *AssetOverview_Details) FromDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDagDetailsDto performs a merge with any union data inside the AssetOverview_Details, using the provided DagDetailsDto
func (t *AssetOverview_Details) MergeDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatasetDetailsDto returns the union data inside the AssetOverview_Details as a DatasetDetailsDto
func (t AssetOverview_Details) AsDatasetDetailsDto() (DatasetDetailsDto, error) {
	var body DatasetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatasetDetailsDto overwrites any union data inside the AssetOverview_Details as the provided DatasetDetailsDto
func (t *AssetOverview_Details) FromDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatasetDetailsDto performs a merge with any union data inside the AssetOverview_Details, using the provided DatasetDetailsDto
func (t *AssetOverview_Details) MergeDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssetOverview_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssetOverview_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseSearchFilterElementDto returns the union data inside the BaseSearchFilterDto_Children_Item as a BaseSearchFilterElementDto
func (t BaseSearchFilterDto_Children_Item) AsBaseSearchFilterElementDto() (BaseSearchFilterElementDto, error) {
	var body BaseSearchFilterElementDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseSearchFilterElementDto overwrites any union data inside the BaseSearchFilterDto_Children_Item as the provided BaseSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) FromBaseSearchFilterElementDto(v BaseSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseSearchFilterElementDto performs a merge with any union data inside the BaseSearchFilterDto_Children_Item, using the provided BaseSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) MergeBaseSearchFilterElementDto(v BaseSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssetSearchFilterElementDto returns the union data inside the BaseSearchFilterDto_Children_Item as a AssetSearchFilterElementDto
func (t BaseSearchFilterDto_Children_Item) AsAssetSearchFilterElementDto() (AssetSearchFilterElementDto, error) {
	var body AssetSearchFilterElementDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssetSearchFilterElementDto overwrites any union data inside the BaseSearchFilterDto_Children_Item as the provided AssetSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) FromAssetSearchFilterElementDto(v AssetSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssetSearchFilterElementDto performs a merge with any union data inside the BaseSearchFilterDto_Children_Item, using the provided AssetSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) MergeAssetSearchFilterElementDto(v AssetSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsHealthStatusSearchFilterElementDto returns the union data inside the BaseSearchFilterDto_Children_Item as a HealthStatusSearchFilterElementDto
func (t BaseSearchFilterDto_Children_Item) AsHealthStatusSearchFilterElementDto() (HealthStatusSearchFilterElementDto, error) {
	var body HealthStatusSearchFilterElementDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHealthStatusSearchFilterElementDto overwrites any union data inside the BaseSearchFilterDto_Children_Item as the provided HealthStatusSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) FromHealthStatusSearchFilterElementDto(v HealthStatusSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHealthStatusSearchFilterElementDto performs a merge with any union data inside the BaseSearchFilterDto_Children_Item, using the provided HealthStatusSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) MergeHealthStatusSearchFilterElementDto(v HealthStatusSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSearchFilterElementDto returns the union data inside the BaseSearchFilterDto_Children_Item as a PlatformSearchFilterElementDto
func (t BaseSearchFilterDto_Children_Item) AsPlatformSearchFilterElementDto() (PlatformSearchFilterElementDto, error) {
	var body PlatformSearchFilterElementDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSearchFilterElementDto overwrites any union data inside the BaseSearchFilterDto_Children_Item as the provided PlatformSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) FromPlatformSearchFilterElementDto(v PlatformSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSearchFilterElementDto performs a merge with any union data inside the BaseSearchFilterDto_Children_Item, using the provided PlatformSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) MergePlatformSearchFilterElementDto(v PlatformSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTagSearchFilterElementDto returns the union data inside the BaseSearchFilterDto_Children_Item as a TagSearchFilterElementDto
func (t BaseSearchFilterDto_Children_Item) AsTagSearchFilterElementDto() (TagSearchFilterElementDto, error) {
	var body TagSearchFilterElementDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTagSearchFilterElementDto overwrites any union data inside the BaseSearchFilterDto_Children_Item as the provided TagSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) FromTagSearchFilterElementDto(v TagSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTagSearchFilterElementDto performs a merge with any union data inside the BaseSearchFilterDto_Children_Item, using the provided TagSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) MergeTagSearchFilterElementDto(v TagSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUsageSearchFilterElementDto returns the union data inside the BaseSearchFilterDto_Children_Item as a UsageSearchFilterElementDto
func (t BaseSearchFilterDto_Children_Item) AsUsageSearchFilterElementDto() (UsageSearchFilterElementDto, error) {
	var body UsageSearchFilterElementDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsageSearchFilterElementDto overwrites any union data inside the BaseSearchFilterDto_Children_Item as the provided UsageSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) FromUsageSearchFilterElementDto(v UsageSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsageSearchFilterElementDto performs a merge with any union data inside the BaseSearchFilterDto_Children_Item, using the provided UsageSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) MergeUsageSearchFilterElementDto(v UsageSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUuidSearchFilterElementDto returns the union data inside the BaseSearchFilterDto_Children_Item as a UuidSearchFilterElementDto
func (t BaseSearchFilterDto_Children_Item) AsUuidSearchFilterElementDto() (UuidSearchFilterElementDto, error) {
	var body UuidSearchFilterElementDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUuidSearchFilterElementDto overwrites any union data inside the BaseSearchFilterDto_Children_Item as the provided UuidSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) FromUuidSearchFilterElementDto(v UuidSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUuidSearchFilterElementDto performs a merge with any union data inside the BaseSearchFilterDto_Children_Item, using the provided UuidSearchFilterElementDto
func (t *BaseSearchFilterDto_Children_Item) MergeUuidSearchFilterElementDto(v UuidSearchFilterElementDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t BaseSearchFilterDto_Children_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BaseSearchFilterDto_Children_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAirflowParams returns the union data inside the CreateDatasourceDto_Params as a AirflowParams
func (t CreateDatasourceDto_Params) AsAirflowParams() (AirflowParams, error) {
	var body AirflowParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAirflowParams overwrites any union data inside the CreateDatasourceDto_Params as the provided AirflowParams
func (t *CreateDatasourceDto_Params) FromAirflowParams(v AirflowParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAirflowParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided AirflowParams
func (t *CreateDatasourceDto_Params) MergeAirflowParams(v AirflowParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAthenaParams returns the union data inside the CreateDatasourceDto_Params as a AthenaParams
func (t CreateDatasourceDto_Params) AsAthenaParams() (AthenaParams, error) {
	var body AthenaParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAthenaParams overwrites any union data inside the CreateDatasourceDto_Params as the provided AthenaParams
func (t *CreateDatasourceDto_Params) FromAthenaParams(v AthenaParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAthenaParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided AthenaParams
func (t *CreateDatasourceDto_Params) MergeAthenaParams(v AthenaParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsBigQueryParams returns the union data inside the CreateDatasourceDto_Params as a BigQueryParams
func (t CreateDatasourceDto_Params) AsBigQueryParams() (BigQueryParams, error) {
	var body BigQueryParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBigQueryParams overwrites any union data inside the CreateDatasourceDto_Params as the provided BigQueryParams
func (t *CreateDatasourceDto_Params) FromBigQueryParams(v BigQueryParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBigQueryParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided BigQueryParams
func (t *CreateDatasourceDto_Params) MergeBigQueryParams(v BigQueryParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDBTCloudParams returns the union data inside the CreateDatasourceDto_Params as a DBTCloudParams
func (t CreateDatasourceDto_Params) AsDBTCloudParams() (DBTCloudParams, error) {
	var body DBTCloudParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDBTCloudParams overwrites any union data inside the CreateDatasourceDto_Params as the provided DBTCloudParams
func (t *CreateDatasourceDto_Params) FromDBTCloudParams(v DBTCloudParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDBTCloudParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided DBTCloudParams
func (t *CreateDatasourceDto_Params) MergeDBTCloudParams(v DBTCloudParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDBTParams returns the union data inside the CreateDatasourceDto_Params as a DBTParams
func (t CreateDatasourceDto_Params) AsDBTParams() (DBTParams, error) {
	var body DBTParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDBTParams overwrites any union data inside the CreateDatasourceDto_Params as the provided DBTParams
func (t *CreateDatasourceDto_Params) FromDBTParams(v DBTParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDBTParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided DBTParams
func (t *CreateDatasourceDto_Params) MergeDBTParams(v DBTParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatabricksParams returns the union data inside the CreateDatasourceDto_Params as a DatabricksParams
func (t CreateDatasourceDto_Params) AsDatabricksParams() (DatabricksParams, error) {
	var body DatabricksParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatabricksParams overwrites any union data inside the CreateDatasourceDto_Params as the provided DatabricksParams
func (t *CreateDatasourceDto_Params) FromDatabricksParams(v DatabricksParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatabricksParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided DatabricksParams
func (t *CreateDatasourceDto_Params) MergeDatabricksParams(v DatabricksParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFireboltParams returns the union data inside the CreateDatasourceDto_Params as a FireboltParams
func (t CreateDatasourceDto_Params) AsFireboltParams() (FireboltParams, error) {
	var body FireboltParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFireboltParams overwrites any union data inside the CreateDatasourceDto_Params as the provided FireboltParams
func (t *CreateDatasourceDto_Params) FromFireboltParams(v FireboltParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFireboltParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided FireboltParams
func (t *CreateDatasourceDto_Params) MergeFireboltParams(v FireboltParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFivetranParams returns the union data inside the CreateDatasourceDto_Params as a FivetranParams
func (t CreateDatasourceDto_Params) AsFivetranParams() (FivetranParams, error) {
	var body FivetranParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFivetranParams overwrites any union data inside the CreateDatasourceDto_Params as the provided FivetranParams
func (t *CreateDatasourceDto_Params) FromFivetranParams(v FivetranParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFivetranParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided FivetranParams
func (t *CreateDatasourceDto_Params) MergeFivetranParams(v FivetranParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsHiveParams returns the union data inside the CreateDatasourceDto_Params as a HiveParams
func (t CreateDatasourceDto_Params) AsHiveParams() (HiveParams, error) {
	var body HiveParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHiveParams overwrites any union data inside the CreateDatasourceDto_Params as the provided HiveParams
func (t *CreateDatasourceDto_Params) FromHiveParams(v HiveParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHiveParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided HiveParams
func (t *CreateDatasourceDto_Params) MergeHiveParams(v HiveParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLookerParams returns the union data inside the CreateDatasourceDto_Params as a LookerParams
func (t CreateDatasourceDto_Params) AsLookerParams() (LookerParams, error) {
	var body LookerParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLookerParams overwrites any union data inside the CreateDatasourceDto_Params as the provided LookerParams
func (t *CreateDatasourceDto_Params) FromLookerParams(v LookerParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLookerParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided LookerParams
func (t *CreateDatasourceDto_Params) MergeLookerParams(v LookerParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMssqlParams returns the union data inside the CreateDatasourceDto_Params as a MssqlParams
func (t CreateDatasourceDto_Params) AsMssqlParams() (MssqlParams, error) {
	var body MssqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMssqlParams overwrites any union data inside the CreateDatasourceDto_Params as the provided MssqlParams
func (t *CreateDatasourceDto_Params) FromMssqlParams(v MssqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMssqlParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided MssqlParams
func (t *CreateDatasourceDto_Params) MergeMssqlParams(v MssqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMysqlParams returns the union data inside the CreateDatasourceDto_Params as a MysqlParams
func (t CreateDatasourceDto_Params) AsMysqlParams() (MysqlParams, error) {
	var body MysqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMysqlParams overwrites any union data inside the CreateDatasourceDto_Params as the provided MysqlParams
func (t *CreateDatasourceDto_Params) FromMysqlParams(v MysqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMysqlParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided MysqlParams
func (t *CreateDatasourceDto_Params) MergeMysqlParams(v MysqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOracleParams returns the union data inside the CreateDatasourceDto_Params as a OracleParams
func (t CreateDatasourceDto_Params) AsOracleParams() (OracleParams, error) {
	var body OracleParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOracleParams overwrites any union data inside the CreateDatasourceDto_Params as the provided OracleParams
func (t *CreateDatasourceDto_Params) FromOracleParams(v OracleParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOracleParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided OracleParams
func (t *CreateDatasourceDto_Params) MergeOracleParams(v OracleParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPostgresqlParams returns the union data inside the CreateDatasourceDto_Params as a PostgresqlParams
func (t CreateDatasourceDto_Params) AsPostgresqlParams() (PostgresqlParams, error) {
	var body PostgresqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostgresqlParams overwrites any union data inside the CreateDatasourceDto_Params as the provided PostgresqlParams
func (t *CreateDatasourceDto_Params) FromPostgresqlParams(v PostgresqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostgresqlParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided PostgresqlParams
func (t *CreateDatasourceDto_Params) MergePostgresqlParams(v PostgresqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPowerBiParams returns the union data inside the CreateDatasourceDto_Params as a PowerBiParams
func (t CreateDatasourceDto_Params) AsPowerBiParams() (PowerBiParams, error) {
	var body PowerBiParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPowerBiParams overwrites any union data inside the CreateDatasourceDto_Params as the provided PowerBiParams
func (t *CreateDatasourceDto_Params) FromPowerBiParams(v PowerBiParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePowerBiParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided PowerBiParams
func (t *CreateDatasourceDto_Params) MergePowerBiParams(v PowerBiParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuickSightParams returns the union data inside the CreateDatasourceDto_Params as a QuickSightParams
func (t CreateDatasourceDto_Params) AsQuickSightParams() (QuickSightParams, error) {
	var body QuickSightParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuickSightParams overwrites any union data inside the CreateDatasourceDto_Params as the provided QuickSightParams
func (t *CreateDatasourceDto_Params) FromQuickSightParams(v QuickSightParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuickSightParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided QuickSightParams
func (t *CreateDatasourceDto_Params) MergeQuickSightParams(v QuickSightParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRedshiftParams returns the union data inside the CreateDatasourceDto_Params as a RedshiftParams
func (t CreateDatasourceDto_Params) AsRedshiftParams() (RedshiftParams, error) {
	var body RedshiftParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRedshiftParams overwrites any union data inside the CreateDatasourceDto_Params as the provided RedshiftParams
func (t *CreateDatasourceDto_Params) FromRedshiftParams(v RedshiftParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRedshiftParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided RedshiftParams
func (t *CreateDatasourceDto_Params) MergeRedshiftParams(v RedshiftParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnowflakeParams returns the union data inside the CreateDatasourceDto_Params as a SnowflakeParams
func (t CreateDatasourceDto_Params) AsSnowflakeParams() (SnowflakeParams, error) {
	var body SnowflakeParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnowflakeParams overwrites any union data inside the CreateDatasourceDto_Params as the provided SnowflakeParams
func (t *CreateDatasourceDto_Params) FromSnowflakeParams(v SnowflakeParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnowflakeParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided SnowflakeParams
func (t *CreateDatasourceDto_Params) MergeSnowflakeParams(v SnowflakeParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableauParams returns the union data inside the CreateDatasourceDto_Params as a TableauParams
func (t CreateDatasourceDto_Params) AsTableauParams() (TableauParams, error) {
	var body TableauParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableauParams overwrites any union data inside the CreateDatasourceDto_Params as the provided TableauParams
func (t *CreateDatasourceDto_Params) FromTableauParams(v TableauParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableauParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided TableauParams
func (t *CreateDatasourceDto_Params) MergeTableauParams(v TableauParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnknownDatasourceParams returns the union data inside the CreateDatasourceDto_Params as a UnknownDatasourceParams
func (t CreateDatasourceDto_Params) AsUnknownDatasourceParams() (UnknownDatasourceParams, error) {
	var body UnknownDatasourceParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnknownDatasourceParams overwrites any union data inside the CreateDatasourceDto_Params as the provided UnknownDatasourceParams
func (t *CreateDatasourceDto_Params) FromUnknownDatasourceParams(v UnknownDatasourceParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnknownDatasourceParams performs a merge with any union data inside the CreateDatasourceDto_Params, using the provided UnknownDatasourceParams
func (t *CreateDatasourceDto_Params) MergeUnknownDatasourceParams(v UnknownDatasourceParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateDatasourceDto_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateDatasourceDto_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssetDetailsDto returns the union data inside the DagAssetOverview_Details as a AssetDetailsDto
func (t DagAssetOverview_Details) AsAssetDetailsDto() (AssetDetailsDto, error) {
	var body AssetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssetDetailsDto overwrites any union data inside the DagAssetOverview_Details as the provided AssetDetailsDto
func (t *DagAssetOverview_Details) FromAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssetDetailsDto performs a merge with any union data inside the DagAssetOverview_Details, using the provided AssetDetailsDto
func (t *DagAssetOverview_Details) MergeAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDagDetailsDto returns the union data inside the DagAssetOverview_Details as a DagDetailsDto
func (t DagAssetOverview_Details) AsDagDetailsDto() (DagDetailsDto, error) {
	var body DagDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDagDetailsDto overwrites any union data inside the DagAssetOverview_Details as the provided DagDetailsDto
func (t *DagAssetOverview_Details) FromDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDagDetailsDto performs a merge with any union data inside the DagAssetOverview_Details, using the provided DagDetailsDto
func (t *DagAssetOverview_Details) MergeDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatasetDetailsDto returns the union data inside the DagAssetOverview_Details as a DatasetDetailsDto
func (t DagAssetOverview_Details) AsDatasetDetailsDto() (DatasetDetailsDto, error) {
	var body DatasetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatasetDetailsDto overwrites any union data inside the DagAssetOverview_Details as the provided DatasetDetailsDto
func (t *DagAssetOverview_Details) FromDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatasetDetailsDto performs a merge with any union data inside the DagAssetOverview_Details, using the provided DatasetDetailsDto
func (t *DagAssetOverview_Details) MergeDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DagAssetOverview_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DagAssetOverview_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssetDetailsDto returns the union data inside the DashboardAssetOverview_Details as a AssetDetailsDto
func (t DashboardAssetOverview_Details) AsAssetDetailsDto() (AssetDetailsDto, error) {
	var body AssetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssetDetailsDto overwrites any union data inside the DashboardAssetOverview_Details as the provided AssetDetailsDto
func (t *DashboardAssetOverview_Details) FromAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssetDetailsDto performs a merge with any union data inside the DashboardAssetOverview_Details, using the provided AssetDetailsDto
func (t *DashboardAssetOverview_Details) MergeAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDagDetailsDto returns the union data inside the DashboardAssetOverview_Details as a DagDetailsDto
func (t DashboardAssetOverview_Details) AsDagDetailsDto() (DagDetailsDto, error) {
	var body DagDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDagDetailsDto overwrites any union data inside the DashboardAssetOverview_Details as the provided DagDetailsDto
func (t *DashboardAssetOverview_Details) FromDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDagDetailsDto performs a merge with any union data inside the DashboardAssetOverview_Details, using the provided DagDetailsDto
func (t *DashboardAssetOverview_Details) MergeDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatasetDetailsDto returns the union data inside the DashboardAssetOverview_Details as a DatasetDetailsDto
func (t DashboardAssetOverview_Details) AsDatasetDetailsDto() (DatasetDetailsDto, error) {
	var body DatasetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatasetDetailsDto overwrites any union data inside the DashboardAssetOverview_Details as the provided DatasetDetailsDto
func (t *DashboardAssetOverview_Details) FromDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatasetDetailsDto performs a merge with any union data inside the DashboardAssetOverview_Details, using the provided DatasetDetailsDto
func (t *DashboardAssetOverview_Details) MergeDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DashboardAssetOverview_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DashboardAssetOverview_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssetDetailsDto returns the union data inside the DatasetAssetOverview_Details as a AssetDetailsDto
func (t DatasetAssetOverview_Details) AsAssetDetailsDto() (AssetDetailsDto, error) {
	var body AssetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssetDetailsDto overwrites any union data inside the DatasetAssetOverview_Details as the provided AssetDetailsDto
func (t *DatasetAssetOverview_Details) FromAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssetDetailsDto performs a merge with any union data inside the DatasetAssetOverview_Details, using the provided AssetDetailsDto
func (t *DatasetAssetOverview_Details) MergeAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDagDetailsDto returns the union data inside the DatasetAssetOverview_Details as a DagDetailsDto
func (t DatasetAssetOverview_Details) AsDagDetailsDto() (DagDetailsDto, error) {
	var body DagDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDagDetailsDto overwrites any union data inside the DatasetAssetOverview_Details as the provided DagDetailsDto
func (t *DatasetAssetOverview_Details) FromDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDagDetailsDto performs a merge with any union data inside the DatasetAssetOverview_Details, using the provided DagDetailsDto
func (t *DatasetAssetOverview_Details) MergeDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatasetDetailsDto returns the union data inside the DatasetAssetOverview_Details as a DatasetDetailsDto
func (t DatasetAssetOverview_Details) AsDatasetDetailsDto() (DatasetDetailsDto, error) {
	var body DatasetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatasetDetailsDto overwrites any union data inside the DatasetAssetOverview_Details as the provided DatasetDetailsDto
func (t *DatasetAssetOverview_Details) FromDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatasetDetailsDto performs a merge with any union data inside the DatasetAssetOverview_Details, using the provided DatasetDetailsDto
func (t *DatasetAssetOverview_Details) MergeDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DatasetAssetOverview_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DatasetAssetOverview_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssetProperties returns the union data inside the DatasetDto_DatasetProperties as a AssetProperties
func (t DatasetDto_DatasetProperties) AsAssetProperties() (AssetProperties, error) {
	var body AssetProperties
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssetProperties overwrites any union data inside the DatasetDto_DatasetProperties as the provided AssetProperties
func (t *DatasetDto_DatasetProperties) FromAssetProperties(v AssetProperties) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssetProperties performs a merge with any union data inside the DatasetDto_DatasetProperties, using the provided AssetProperties
func (t *DatasetDto_DatasetProperties) MergeAssetProperties(v AssetProperties) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsBigQueryPartitionedTableProperties returns the union data inside the DatasetDto_DatasetProperties as a BigQueryPartitionedTableProperties
func (t DatasetDto_DatasetProperties) AsBigQueryPartitionedTableProperties() (BigQueryPartitionedTableProperties, error) {
	var body BigQueryPartitionedTableProperties
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBigQueryPartitionedTableProperties overwrites any union data inside the DatasetDto_DatasetProperties as the provided BigQueryPartitionedTableProperties
func (t *DatasetDto_DatasetProperties) FromBigQueryPartitionedTableProperties(v BigQueryPartitionedTableProperties) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBigQueryPartitionedTableProperties performs a merge with any union data inside the DatasetDto_DatasetProperties, using the provided BigQueryPartitionedTableProperties
func (t *DatasetDto_DatasetProperties) MergeBigQueryPartitionedTableProperties(v BigQueryPartitionedTableProperties) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalTableProperties returns the union data inside the DatasetDto_DatasetProperties as a ExternalTableProperties
func (t DatasetDto_DatasetProperties) AsExternalTableProperties() (ExternalTableProperties, error) {
	var body ExternalTableProperties
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalTableProperties overwrites any union data inside the DatasetDto_DatasetProperties as the provided ExternalTableProperties
func (t *DatasetDto_DatasetProperties) FromExternalTableProperties(v ExternalTableProperties) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalTableProperties performs a merge with any union data inside the DatasetDto_DatasetProperties, using the provided ExternalTableProperties
func (t *DatasetDto_DatasetProperties) MergeExternalTableProperties(v ExternalTableProperties) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnowflakeStreamProperties returns the union data inside the DatasetDto_DatasetProperties as a SnowflakeStreamProperties
func (t DatasetDto_DatasetProperties) AsSnowflakeStreamProperties() (SnowflakeStreamProperties, error) {
	var body SnowflakeStreamProperties
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnowflakeStreamProperties overwrites any union data inside the DatasetDto_DatasetProperties as the provided SnowflakeStreamProperties
func (t *DatasetDto_DatasetProperties) FromSnowflakeStreamProperties(v SnowflakeStreamProperties) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnowflakeStreamProperties performs a merge with any union data inside the DatasetDto_DatasetProperties, using the provided SnowflakeStreamProperties
func (t *DatasetDto_DatasetProperties) MergeSnowflakeStreamProperties(v SnowflakeStreamProperties) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DatasetDto_DatasetProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DatasetDto_DatasetProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAirflowParams returns the union data inside the DatasourceCatalogAssetDto_Params as a AirflowParams
func (t DatasourceCatalogAssetDto_Params) AsAirflowParams() (AirflowParams, error) {
	var body AirflowParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAirflowParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided AirflowParams
func (t *DatasourceCatalogAssetDto_Params) FromAirflowParams(v AirflowParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAirflowParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided AirflowParams
func (t *DatasourceCatalogAssetDto_Params) MergeAirflowParams(v AirflowParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAthenaParams returns the union data inside the DatasourceCatalogAssetDto_Params as a AthenaParams
func (t DatasourceCatalogAssetDto_Params) AsAthenaParams() (AthenaParams, error) {
	var body AthenaParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAthenaParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided AthenaParams
func (t *DatasourceCatalogAssetDto_Params) FromAthenaParams(v AthenaParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAthenaParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided AthenaParams
func (t *DatasourceCatalogAssetDto_Params) MergeAthenaParams(v AthenaParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsBigQueryParams returns the union data inside the DatasourceCatalogAssetDto_Params as a BigQueryParams
func (t DatasourceCatalogAssetDto_Params) AsBigQueryParams() (BigQueryParams, error) {
	var body BigQueryParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBigQueryParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided BigQueryParams
func (t *DatasourceCatalogAssetDto_Params) FromBigQueryParams(v BigQueryParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBigQueryParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided BigQueryParams
func (t *DatasourceCatalogAssetDto_Params) MergeBigQueryParams(v BigQueryParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDBTCloudParams returns the union data inside the DatasourceCatalogAssetDto_Params as a DBTCloudParams
func (t DatasourceCatalogAssetDto_Params) AsDBTCloudParams() (DBTCloudParams, error) {
	var body DBTCloudParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDBTCloudParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided DBTCloudParams
func (t *DatasourceCatalogAssetDto_Params) FromDBTCloudParams(v DBTCloudParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDBTCloudParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided DBTCloudParams
func (t *DatasourceCatalogAssetDto_Params) MergeDBTCloudParams(v DBTCloudParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDBTParams returns the union data inside the DatasourceCatalogAssetDto_Params as a DBTParams
func (t DatasourceCatalogAssetDto_Params) AsDBTParams() (DBTParams, error) {
	var body DBTParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDBTParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided DBTParams
func (t *DatasourceCatalogAssetDto_Params) FromDBTParams(v DBTParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDBTParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided DBTParams
func (t *DatasourceCatalogAssetDto_Params) MergeDBTParams(v DBTParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatabricksParams returns the union data inside the DatasourceCatalogAssetDto_Params as a DatabricksParams
func (t DatasourceCatalogAssetDto_Params) AsDatabricksParams() (DatabricksParams, error) {
	var body DatabricksParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatabricksParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided DatabricksParams
func (t *DatasourceCatalogAssetDto_Params) FromDatabricksParams(v DatabricksParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatabricksParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided DatabricksParams
func (t *DatasourceCatalogAssetDto_Params) MergeDatabricksParams(v DatabricksParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFireboltParams returns the union data inside the DatasourceCatalogAssetDto_Params as a FireboltParams
func (t DatasourceCatalogAssetDto_Params) AsFireboltParams() (FireboltParams, error) {
	var body FireboltParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFireboltParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided FireboltParams
func (t *DatasourceCatalogAssetDto_Params) FromFireboltParams(v FireboltParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFireboltParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided FireboltParams
func (t *DatasourceCatalogAssetDto_Params) MergeFireboltParams(v FireboltParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFivetranParams returns the union data inside the DatasourceCatalogAssetDto_Params as a FivetranParams
func (t DatasourceCatalogAssetDto_Params) AsFivetranParams() (FivetranParams, error) {
	var body FivetranParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFivetranParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided FivetranParams
func (t *DatasourceCatalogAssetDto_Params) FromFivetranParams(v FivetranParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFivetranParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided FivetranParams
func (t *DatasourceCatalogAssetDto_Params) MergeFivetranParams(v FivetranParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsHiveParams returns the union data inside the DatasourceCatalogAssetDto_Params as a HiveParams
func (t DatasourceCatalogAssetDto_Params) AsHiveParams() (HiveParams, error) {
	var body HiveParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHiveParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided HiveParams
func (t *DatasourceCatalogAssetDto_Params) FromHiveParams(v HiveParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHiveParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided HiveParams
func (t *DatasourceCatalogAssetDto_Params) MergeHiveParams(v HiveParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLookerParams returns the union data inside the DatasourceCatalogAssetDto_Params as a LookerParams
func (t DatasourceCatalogAssetDto_Params) AsLookerParams() (LookerParams, error) {
	var body LookerParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLookerParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided LookerParams
func (t *DatasourceCatalogAssetDto_Params) FromLookerParams(v LookerParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLookerParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided LookerParams
func (t *DatasourceCatalogAssetDto_Params) MergeLookerParams(v LookerParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMssqlParams returns the union data inside the DatasourceCatalogAssetDto_Params as a MssqlParams
func (t DatasourceCatalogAssetDto_Params) AsMssqlParams() (MssqlParams, error) {
	var body MssqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMssqlParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided MssqlParams
func (t *DatasourceCatalogAssetDto_Params) FromMssqlParams(v MssqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMssqlParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided MssqlParams
func (t *DatasourceCatalogAssetDto_Params) MergeMssqlParams(v MssqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMysqlParams returns the union data inside the DatasourceCatalogAssetDto_Params as a MysqlParams
func (t DatasourceCatalogAssetDto_Params) AsMysqlParams() (MysqlParams, error) {
	var body MysqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMysqlParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided MysqlParams
func (t *DatasourceCatalogAssetDto_Params) FromMysqlParams(v MysqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMysqlParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided MysqlParams
func (t *DatasourceCatalogAssetDto_Params) MergeMysqlParams(v MysqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOracleParams returns the union data inside the DatasourceCatalogAssetDto_Params as a OracleParams
func (t DatasourceCatalogAssetDto_Params) AsOracleParams() (OracleParams, error) {
	var body OracleParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOracleParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided OracleParams
func (t *DatasourceCatalogAssetDto_Params) FromOracleParams(v OracleParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOracleParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided OracleParams
func (t *DatasourceCatalogAssetDto_Params) MergeOracleParams(v OracleParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPostgresqlParams returns the union data inside the DatasourceCatalogAssetDto_Params as a PostgresqlParams
func (t DatasourceCatalogAssetDto_Params) AsPostgresqlParams() (PostgresqlParams, error) {
	var body PostgresqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostgresqlParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided PostgresqlParams
func (t *DatasourceCatalogAssetDto_Params) FromPostgresqlParams(v PostgresqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostgresqlParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided PostgresqlParams
func (t *DatasourceCatalogAssetDto_Params) MergePostgresqlParams(v PostgresqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPowerBiParams returns the union data inside the DatasourceCatalogAssetDto_Params as a PowerBiParams
func (t DatasourceCatalogAssetDto_Params) AsPowerBiParams() (PowerBiParams, error) {
	var body PowerBiParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPowerBiParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided PowerBiParams
func (t *DatasourceCatalogAssetDto_Params) FromPowerBiParams(v PowerBiParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePowerBiParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided PowerBiParams
func (t *DatasourceCatalogAssetDto_Params) MergePowerBiParams(v PowerBiParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuickSightParams returns the union data inside the DatasourceCatalogAssetDto_Params as a QuickSightParams
func (t DatasourceCatalogAssetDto_Params) AsQuickSightParams() (QuickSightParams, error) {
	var body QuickSightParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuickSightParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided QuickSightParams
func (t *DatasourceCatalogAssetDto_Params) FromQuickSightParams(v QuickSightParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuickSightParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided QuickSightParams
func (t *DatasourceCatalogAssetDto_Params) MergeQuickSightParams(v QuickSightParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRedshiftParams returns the union data inside the DatasourceCatalogAssetDto_Params as a RedshiftParams
func (t DatasourceCatalogAssetDto_Params) AsRedshiftParams() (RedshiftParams, error) {
	var body RedshiftParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRedshiftParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided RedshiftParams
func (t *DatasourceCatalogAssetDto_Params) FromRedshiftParams(v RedshiftParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRedshiftParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided RedshiftParams
func (t *DatasourceCatalogAssetDto_Params) MergeRedshiftParams(v RedshiftParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnowflakeParams returns the union data inside the DatasourceCatalogAssetDto_Params as a SnowflakeParams
func (t DatasourceCatalogAssetDto_Params) AsSnowflakeParams() (SnowflakeParams, error) {
	var body SnowflakeParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnowflakeParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided SnowflakeParams
func (t *DatasourceCatalogAssetDto_Params) FromSnowflakeParams(v SnowflakeParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnowflakeParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided SnowflakeParams
func (t *DatasourceCatalogAssetDto_Params) MergeSnowflakeParams(v SnowflakeParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableauParams returns the union data inside the DatasourceCatalogAssetDto_Params as a TableauParams
func (t DatasourceCatalogAssetDto_Params) AsTableauParams() (TableauParams, error) {
	var body TableauParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableauParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided TableauParams
func (t *DatasourceCatalogAssetDto_Params) FromTableauParams(v TableauParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableauParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided TableauParams
func (t *DatasourceCatalogAssetDto_Params) MergeTableauParams(v TableauParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnknownDatasourceParams returns the union data inside the DatasourceCatalogAssetDto_Params as a UnknownDatasourceParams
func (t DatasourceCatalogAssetDto_Params) AsUnknownDatasourceParams() (UnknownDatasourceParams, error) {
	var body UnknownDatasourceParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnknownDatasourceParams overwrites any union data inside the DatasourceCatalogAssetDto_Params as the provided UnknownDatasourceParams
func (t *DatasourceCatalogAssetDto_Params) FromUnknownDatasourceParams(v UnknownDatasourceParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnknownDatasourceParams performs a merge with any union data inside the DatasourceCatalogAssetDto_Params, using the provided UnknownDatasourceParams
func (t *DatasourceCatalogAssetDto_Params) MergeUnknownDatasourceParams(v UnknownDatasourceParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DatasourceCatalogAssetDto_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DatasourceCatalogAssetDto_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAirflowParams returns the union data inside the DatasourceDto_Params as a AirflowParams
func (t DatasourceDto_Params) AsAirflowParams() (AirflowParams, error) {
	var body AirflowParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAirflowParams overwrites any union data inside the DatasourceDto_Params as the provided AirflowParams
func (t *DatasourceDto_Params) FromAirflowParams(v AirflowParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAirflowParams performs a merge with any union data inside the DatasourceDto_Params, using the provided AirflowParams
func (t *DatasourceDto_Params) MergeAirflowParams(v AirflowParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAthenaParams returns the union data inside the DatasourceDto_Params as a AthenaParams
func (t DatasourceDto_Params) AsAthenaParams() (AthenaParams, error) {
	var body AthenaParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAthenaParams overwrites any union data inside the DatasourceDto_Params as the provided AthenaParams
func (t *DatasourceDto_Params) FromAthenaParams(v AthenaParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAthenaParams performs a merge with any union data inside the DatasourceDto_Params, using the provided AthenaParams
func (t *DatasourceDto_Params) MergeAthenaParams(v AthenaParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsBigQueryParams returns the union data inside the DatasourceDto_Params as a BigQueryParams
func (t DatasourceDto_Params) AsBigQueryParams() (BigQueryParams, error) {
	var body BigQueryParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBigQueryParams overwrites any union data inside the DatasourceDto_Params as the provided BigQueryParams
func (t *DatasourceDto_Params) FromBigQueryParams(v BigQueryParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBigQueryParams performs a merge with any union data inside the DatasourceDto_Params, using the provided BigQueryParams
func (t *DatasourceDto_Params) MergeBigQueryParams(v BigQueryParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDBTCloudParams returns the union data inside the DatasourceDto_Params as a DBTCloudParams
func (t DatasourceDto_Params) AsDBTCloudParams() (DBTCloudParams, error) {
	var body DBTCloudParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDBTCloudParams overwrites any union data inside the DatasourceDto_Params as the provided DBTCloudParams
func (t *DatasourceDto_Params) FromDBTCloudParams(v DBTCloudParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDBTCloudParams performs a merge with any union data inside the DatasourceDto_Params, using the provided DBTCloudParams
func (t *DatasourceDto_Params) MergeDBTCloudParams(v DBTCloudParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDBTParams returns the union data inside the DatasourceDto_Params as a DBTParams
func (t DatasourceDto_Params) AsDBTParams() (DBTParams, error) {
	var body DBTParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDBTParams overwrites any union data inside the DatasourceDto_Params as the provided DBTParams
func (t *DatasourceDto_Params) FromDBTParams(v DBTParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDBTParams performs a merge with any union data inside the DatasourceDto_Params, using the provided DBTParams
func (t *DatasourceDto_Params) MergeDBTParams(v DBTParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatabricksParams returns the union data inside the DatasourceDto_Params as a DatabricksParams
func (t DatasourceDto_Params) AsDatabricksParams() (DatabricksParams, error) {
	var body DatabricksParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatabricksParams overwrites any union data inside the DatasourceDto_Params as the provided DatabricksParams
func (t *DatasourceDto_Params) FromDatabricksParams(v DatabricksParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatabricksParams performs a merge with any union data inside the DatasourceDto_Params, using the provided DatabricksParams
func (t *DatasourceDto_Params) MergeDatabricksParams(v DatabricksParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFireboltParams returns the union data inside the DatasourceDto_Params as a FireboltParams
func (t DatasourceDto_Params) AsFireboltParams() (FireboltParams, error) {
	var body FireboltParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFireboltParams overwrites any union data inside the DatasourceDto_Params as the provided FireboltParams
func (t *DatasourceDto_Params) FromFireboltParams(v FireboltParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFireboltParams performs a merge with any union data inside the DatasourceDto_Params, using the provided FireboltParams
func (t *DatasourceDto_Params) MergeFireboltParams(v FireboltParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFivetranParams returns the union data inside the DatasourceDto_Params as a FivetranParams
func (t DatasourceDto_Params) AsFivetranParams() (FivetranParams, error) {
	var body FivetranParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFivetranParams overwrites any union data inside the DatasourceDto_Params as the provided FivetranParams
func (t *DatasourceDto_Params) FromFivetranParams(v FivetranParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFivetranParams performs a merge with any union data inside the DatasourceDto_Params, using the provided FivetranParams
func (t *DatasourceDto_Params) MergeFivetranParams(v FivetranParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsHiveParams returns the union data inside the DatasourceDto_Params as a HiveParams
func (t DatasourceDto_Params) AsHiveParams() (HiveParams, error) {
	var body HiveParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHiveParams overwrites any union data inside the DatasourceDto_Params as the provided HiveParams
func (t *DatasourceDto_Params) FromHiveParams(v HiveParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHiveParams performs a merge with any union data inside the DatasourceDto_Params, using the provided HiveParams
func (t *DatasourceDto_Params) MergeHiveParams(v HiveParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLookerParams returns the union data inside the DatasourceDto_Params as a LookerParams
func (t DatasourceDto_Params) AsLookerParams() (LookerParams, error) {
	var body LookerParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLookerParams overwrites any union data inside the DatasourceDto_Params as the provided LookerParams
func (t *DatasourceDto_Params) FromLookerParams(v LookerParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLookerParams performs a merge with any union data inside the DatasourceDto_Params, using the provided LookerParams
func (t *DatasourceDto_Params) MergeLookerParams(v LookerParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMssqlParams returns the union data inside the DatasourceDto_Params as a MssqlParams
func (t DatasourceDto_Params) AsMssqlParams() (MssqlParams, error) {
	var body MssqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMssqlParams overwrites any union data inside the DatasourceDto_Params as the provided MssqlParams
func (t *DatasourceDto_Params) FromMssqlParams(v MssqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMssqlParams performs a merge with any union data inside the DatasourceDto_Params, using the provided MssqlParams
func (t *DatasourceDto_Params) MergeMssqlParams(v MssqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMysqlParams returns the union data inside the DatasourceDto_Params as a MysqlParams
func (t DatasourceDto_Params) AsMysqlParams() (MysqlParams, error) {
	var body MysqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMysqlParams overwrites any union data inside the DatasourceDto_Params as the provided MysqlParams
func (t *DatasourceDto_Params) FromMysqlParams(v MysqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMysqlParams performs a merge with any union data inside the DatasourceDto_Params, using the provided MysqlParams
func (t *DatasourceDto_Params) MergeMysqlParams(v MysqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOracleParams returns the union data inside the DatasourceDto_Params as a OracleParams
func (t DatasourceDto_Params) AsOracleParams() (OracleParams, error) {
	var body OracleParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOracleParams overwrites any union data inside the DatasourceDto_Params as the provided OracleParams
func (t *DatasourceDto_Params) FromOracleParams(v OracleParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOracleParams performs a merge with any union data inside the DatasourceDto_Params, using the provided OracleParams
func (t *DatasourceDto_Params) MergeOracleParams(v OracleParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPostgresqlParams returns the union data inside the DatasourceDto_Params as a PostgresqlParams
func (t DatasourceDto_Params) AsPostgresqlParams() (PostgresqlParams, error) {
	var body PostgresqlParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostgresqlParams overwrites any union data inside the DatasourceDto_Params as the provided PostgresqlParams
func (t *DatasourceDto_Params) FromPostgresqlParams(v PostgresqlParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostgresqlParams performs a merge with any union data inside the DatasourceDto_Params, using the provided PostgresqlParams
func (t *DatasourceDto_Params) MergePostgresqlParams(v PostgresqlParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPowerBiParams returns the union data inside the DatasourceDto_Params as a PowerBiParams
func (t DatasourceDto_Params) AsPowerBiParams() (PowerBiParams, error) {
	var body PowerBiParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPowerBiParams overwrites any union data inside the DatasourceDto_Params as the provided PowerBiParams
func (t *DatasourceDto_Params) FromPowerBiParams(v PowerBiParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePowerBiParams performs a merge with any union data inside the DatasourceDto_Params, using the provided PowerBiParams
func (t *DatasourceDto_Params) MergePowerBiParams(v PowerBiParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuickSightParams returns the union data inside the DatasourceDto_Params as a QuickSightParams
func (t DatasourceDto_Params) AsQuickSightParams() (QuickSightParams, error) {
	var body QuickSightParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuickSightParams overwrites any union data inside the DatasourceDto_Params as the provided QuickSightParams
func (t *DatasourceDto_Params) FromQuickSightParams(v QuickSightParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuickSightParams performs a merge with any union data inside the DatasourceDto_Params, using the provided QuickSightParams
func (t *DatasourceDto_Params) MergeQuickSightParams(v QuickSightParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRedshiftParams returns the union data inside the DatasourceDto_Params as a RedshiftParams
func (t DatasourceDto_Params) AsRedshiftParams() (RedshiftParams, error) {
	var body RedshiftParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRedshiftParams overwrites any union data inside the DatasourceDto_Params as the provided RedshiftParams
func (t *DatasourceDto_Params) FromRedshiftParams(v RedshiftParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRedshiftParams performs a merge with any union data inside the DatasourceDto_Params, using the provided RedshiftParams
func (t *DatasourceDto_Params) MergeRedshiftParams(v RedshiftParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnowflakeParams returns the union data inside the DatasourceDto_Params as a SnowflakeParams
func (t DatasourceDto_Params) AsSnowflakeParams() (SnowflakeParams, error) {
	var body SnowflakeParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnowflakeParams overwrites any union data inside the DatasourceDto_Params as the provided SnowflakeParams
func (t *DatasourceDto_Params) FromSnowflakeParams(v SnowflakeParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnowflakeParams performs a merge with any union data inside the DatasourceDto_Params, using the provided SnowflakeParams
func (t *DatasourceDto_Params) MergeSnowflakeParams(v SnowflakeParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableauParams returns the union data inside the DatasourceDto_Params as a TableauParams
func (t DatasourceDto_Params) AsTableauParams() (TableauParams, error) {
	var body TableauParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableauParams overwrites any union data inside the DatasourceDto_Params as the provided TableauParams
func (t *DatasourceDto_Params) FromTableauParams(v TableauParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableauParams performs a merge with any union data inside the DatasourceDto_Params, using the provided TableauParams
func (t *DatasourceDto_Params) MergeTableauParams(v TableauParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnknownDatasourceParams returns the union data inside the DatasourceDto_Params as a UnknownDatasourceParams
func (t DatasourceDto_Params) AsUnknownDatasourceParams() (UnknownDatasourceParams, error) {
	var body UnknownDatasourceParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnknownDatasourceParams overwrites any union data inside the DatasourceDto_Params as the provided UnknownDatasourceParams
func (t *DatasourceDto_Params) FromUnknownDatasourceParams(v UnknownDatasourceParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnknownDatasourceParams performs a merge with any union data inside the DatasourceDto_Params, using the provided UnknownDatasourceParams
func (t *DatasourceDto_Params) MergeUnknownDatasourceParams(v UnknownDatasourceParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DatasourceDto_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DatasourceDto_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssignOwnersPayload returns the union data inside the EventDto_Payload as a AssignOwnersPayload
func (t EventDto_Payload) AsAssignOwnersPayload() (AssignOwnersPayload, error) {
	var body AssignOwnersPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssignOwnersPayload overwrites any union data inside the EventDto_Payload as the provided AssignOwnersPayload
func (t *EventDto_Payload) FromAssignOwnersPayload(v AssignOwnersPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssignOwnersPayload performs a merge with any union data inside the EventDto_Payload, using the provided AssignOwnersPayload
func (t *EventDto_Payload) MergeAssignOwnersPayload(v AssignOwnersPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCommentPayload returns the union data inside the EventDto_Payload as a CreateCommentPayload
func (t EventDto_Payload) AsCreateCommentPayload() (CreateCommentPayload, error) {
	var body CreateCommentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCommentPayload overwrites any union data inside the EventDto_Payload as the provided CreateCommentPayload
func (t *EventDto_Payload) FromCreateCommentPayload(v CreateCommentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCommentPayload performs a merge with any union data inside the EventDto_Payload, using the provided CreateCommentPayload
func (t *EventDto_Payload) MergeCreateCommentPayload(v CreateCommentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIncidentStatusUpdatePayload returns the union data inside the EventDto_Payload as a IncidentStatusUpdatePayload
func (t EventDto_Payload) AsIncidentStatusUpdatePayload() (IncidentStatusUpdatePayload, error) {
	var body IncidentStatusUpdatePayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIncidentStatusUpdatePayload overwrites any union data inside the EventDto_Payload as the provided IncidentStatusUpdatePayload
func (t *EventDto_Payload) FromIncidentStatusUpdatePayload(v IncidentStatusUpdatePayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIncidentStatusUpdatePayload performs a merge with any union data inside the EventDto_Payload, using the provided IncidentStatusUpdatePayload
func (t *EventDto_Payload) MergeIncidentStatusUpdatePayload(v IncidentStatusUpdatePayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusUpdatePayload returns the union data inside the EventDto_Payload as a StatusUpdatePayload
func (t EventDto_Payload) AsStatusUpdatePayload() (StatusUpdatePayload, error) {
	var body StatusUpdatePayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusUpdatePayload overwrites any union data inside the EventDto_Payload as the provided StatusUpdatePayload
func (t *EventDto_Payload) FromStatusUpdatePayload(v StatusUpdatePayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusUpdatePayload performs a merge with any union data inside the EventDto_Payload, using the provided StatusUpdatePayload
func (t *EventDto_Payload) MergeStatusUpdatePayload(v StatusUpdatePayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EventDto_Payload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EventDto_Payload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssetDetailsDto returns the union data inside the ModelAssetOverview_Details as a AssetDetailsDto
func (t ModelAssetOverview_Details) AsAssetDetailsDto() (AssetDetailsDto, error) {
	var body AssetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssetDetailsDto overwrites any union data inside the ModelAssetOverview_Details as the provided AssetDetailsDto
func (t *ModelAssetOverview_Details) FromAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssetDetailsDto performs a merge with any union data inside the ModelAssetOverview_Details, using the provided AssetDetailsDto
func (t *ModelAssetOverview_Details) MergeAssetDetailsDto(v AssetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDagDetailsDto returns the union data inside the ModelAssetOverview_Details as a DagDetailsDto
func (t ModelAssetOverview_Details) AsDagDetailsDto() (DagDetailsDto, error) {
	var body DagDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDagDetailsDto overwrites any union data inside the ModelAssetOverview_Details as the provided DagDetailsDto
func (t *ModelAssetOverview_Details) FromDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDagDetailsDto performs a merge with any union data inside the ModelAssetOverview_Details, using the provided DagDetailsDto
func (t *ModelAssetOverview_Details) MergeDagDetailsDto(v DagDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatasetDetailsDto returns the union data inside the ModelAssetOverview_Details as a DatasetDetailsDto
func (t ModelAssetOverview_Details) AsDatasetDetailsDto() (DatasetDetailsDto, error) {
	var body DatasetDetailsDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatasetDetailsDto overwrites any union data inside the ModelAssetOverview_Details as the provided DatasetDetailsDto
func (t *ModelAssetOverview_Details) FromDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatasetDetailsDto performs a merge with any union data inside the ModelAssetOverview_Details, using the provided DatasetDetailsDto
func (t *ModelAssetOverview_Details) MergeDatasetDetailsDto(v DatasetDetailsDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModelAssetOverview_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModelAssetOverview_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAll request
	GetAll(ctx context.Context, params *GetAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportAssetDescriptions request
	ExportAssetDescriptions(ctx context.Context, params *ExportAssetDescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportAssetDescriptionsTemplate request
	ExportAssetDescriptionsTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLight request
	GetAllLight(ctx context.Context, params *GetAllLightParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetByUrn request
	GetAssetByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetOverviewByUrn request
	GetAssetOverviewByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetSchemaByUrnAndVersion request
	GetAssetSchemaByUrnAndVersion(ctx context.Context, urn string, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatasetFieldWithBody request with any body
	UpdateDatasetFieldWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatasetField(ctx context.Context, id openapi_types.UUID, body UpdateDatasetFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDataset request
	GetAllDataset(ctx context.Context, params *GetAllDatasetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDatasource request
	GetAllDatasource(ctx context.Context, params *GetAllDatasourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatasourceWithBody request with any body
	CreateDatasourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatasource(ctx context.Context, body CreateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestDatasourceConnectionWithBody request with any body
	TestDatasourceConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestDatasourceConnection(ctx context.Context, body TestDatasourceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatasourceById request
	DeleteDatasourceById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatasourceById request
	GetDatasourceById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasourceIngestionManualRun request
	DatasourceIngestionManualRun(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatasourceIngestionRuns request
	GetDatasourceIngestionRuns(ctx context.Context, id openapi_types.UUID, params *GetDatasourceIngestionRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDomains request
	GetAllDomains(ctx context.Context, params *GetAllDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDomainWithBody request with any body
	CreateDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDomain(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDomain request
	DeleteDomain(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainById request
	GetDomainById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDomainWithBody request with any body
	UpdateDomainWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDomain(ctx context.Context, id openapi_types.UUID, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllIncident request
	GetAllIncident(ctx context.Context, params *GetAllIncidentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDownstreamImpactedAssets request
	GetDownstreamImpactedAssets(ctx context.Context, params *GetDownstreamImpactedAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncidentByIssueNumber request
	GetIncidentByIssueNumber(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncidentEventsByIssueNumber request
	GetIncidentEventsByIssueNumber(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncidentScopeByIssueNumber request
	GetIncidentScopeByIssueNumber(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLineageByUrn request
	GetLineageByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLineageDownstreamsByUrn request
	GetLineageDownstreamsByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLineageUpstreamsByUrn request
	GetLineageUpstreamsByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleTemplateLightList request
	GetRuleTemplateLightList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSiffletRuleById request
	DeleteSiffletRuleById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSiffletRuleById request
	GetSiffletRuleById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SiffletRuleRunDebugWithBody request with any body
	SiffletRuleRunDebugWithBody(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SiffletRuleRunDebug(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, body SiffletRuleRunDebugJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SiffletRuleRunDownloadByRunWithBody request with any body
	SiffletRuleRunDownloadByRunWithBody(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SiffletRuleRunDownloadByRun(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, body SiffletRuleRunDownloadByRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSiffletRuleRunDetails request
	GetSiffletRuleRunDetails(ctx context.Context, id openapi_types.UUID, runId string, params *GetSiffletRuleRunDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecret request
	DeleteSecret(ctx context.Context, params *DeleteSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecret request
	GetSecret(ctx context.Context, params *GetSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSecrets request
	GetAllSecrets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataStack request
	GetDataStack(ctx context.Context, params *GetDataStackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncidentsSummary request
	GetIncidentsSummary(ctx context.Context, params *GetIncidentsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRulesSummary request
	GetRulesSummary(ctx context.Context, params *GetRulesSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTag request
	GetAllTag(ctx context.Context, params *GetAllTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagWithBody request with any body
	CreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagById request
	GetTagById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTagWithBody request with any body
	UpdateTagWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTag(ctx context.Context, id openapi_types.UUID, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTerm request
	GetAllTerm(ctx context.Context, params *GetAllTermParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTermWithBody request with any body
	CreateTermWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTerm(ctx context.Context, body CreateTermJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTerm request
	DeleteTerm(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTermById request
	GetTermById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTermWithBody request with any body
	UpdateTermWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTerm(ctx context.Context, id openapi_types.UUID, body UpdateTermJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetUsage request
	GetAssetUsage(ctx context.Context, assetId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAll(ctx context.Context, params *GetAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAssetDescriptions(ctx context.Context, params *ExportAssetDescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAssetDescriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAssetDescriptionsTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAssetDescriptionsTemplateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLight(ctx context.Context, params *GetAllLightParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLightRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetByUrnRequest(c.Server, urn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetOverviewByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetOverviewByUrnRequest(c.Server, urn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetSchemaByUrnAndVersion(ctx context.Context, urn string, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetSchemaByUrnAndVersionRequest(c.Server, urn, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatasetFieldWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatasetFieldRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatasetField(ctx context.Context, id openapi_types.UUID, body UpdateDatasetFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatasetFieldRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDataset(ctx context.Context, params *GetAllDatasetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDatasetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDatasource(ctx context.Context, params *GetAllDatasourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDatasourceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatasourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatasourceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatasource(ctx context.Context, body CreateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatasourceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestDatasourceConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestDatasourceConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestDatasourceConnection(ctx context.Context, body TestDatasourceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestDatasourceConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatasourceById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatasourceByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatasourceById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatasourceByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasourceIngestionManualRun(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasourceIngestionManualRunRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatasourceIngestionRuns(ctx context.Context, id openapi_types.UUID, params *GetDatasourceIngestionRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatasourceIngestionRunsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDomains(ctx context.Context, params *GetAllDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomain(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDomain(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomain(ctx context.Context, id openapi_types.UUID, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllIncident(ctx context.Context, params *GetAllIncidentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllIncidentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDownstreamImpactedAssets(ctx context.Context, params *GetDownstreamImpactedAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDownstreamImpactedAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncidentByIssueNumber(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentByIssueNumberRequest(c.Server, issueNo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncidentEventsByIssueNumber(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentEventsByIssueNumberRequest(c.Server, issueNo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncidentScopeByIssueNumber(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentScopeByIssueNumberRequest(c.Server, issueNo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLineageByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLineageByUrnRequest(c.Server, urn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLineageDownstreamsByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLineageDownstreamsByUrnRequest(c.Server, urn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLineageUpstreamsByUrn(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLineageUpstreamsByUrnRequest(c.Server, urn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleTemplateLightList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleTemplateLightListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSiffletRuleById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSiffletRuleByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSiffletRuleById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiffletRuleByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SiffletRuleRunDebugWithBody(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSiffletRuleRunDebugRequestWithBody(c.Server, id, runId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SiffletRuleRunDebug(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, body SiffletRuleRunDebugJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSiffletRuleRunDebugRequest(c.Server, id, runId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SiffletRuleRunDownloadByRunWithBody(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSiffletRuleRunDownloadByRunRequestWithBody(c.Server, id, runId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SiffletRuleRunDownloadByRun(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, body SiffletRuleRunDownloadByRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSiffletRuleRunDownloadByRunRequest(c.Server, id, runId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSiffletRuleRunDetails(ctx context.Context, id openapi_types.UUID, runId string, params *GetSiffletRuleRunDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiffletRuleRunDetailsRequest(c.Server, id, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecret(ctx context.Context, params *DeleteSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecretRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecret(ctx context.Context, params *GetSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecretRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSecrets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSecretsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataStack(ctx context.Context, params *GetDataStackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataStackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncidentsSummary(ctx context.Context, params *GetIncidentsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentsSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRulesSummary(ctx context.Context, params *GetRulesSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTag(ctx context.Context, params *GetAllTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTagWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTag(ctx context.Context, id openapi_types.UUID, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTerm(ctx context.Context, params *GetAllTermParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTermRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTermWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTermRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTerm(ctx context.Context, body CreateTermJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTermRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTerm(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTermRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTermById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTermByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTermWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTermRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTerm(ctx context.Context, id openapi_types.UUID, body UpdateTermJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTermRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetUsage(ctx context.Context, assetId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetUsageRequest(c.Server, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllRequest generates requests for GetAll
func NewGetAllRequest(server string, params *GetAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HealthStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "healthStatus", runtime.ParamLocationQuery, *params.HealthStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetFilterType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assetFilterType", runtime.ParamLocationQuery, *params.AssetFilterType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Usage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "usage", runtime.ParamLocationQuery, *params.Usage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Term != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, *params.Term); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Datasource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datasource", runtime.ParamLocationQuery, *params.Datasource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchInFieldsAndDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchInFieldsAndDescriptions", runtime.ParamLocationQuery, *params.SearchInFieldsAndDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportAssetDescriptionsRequest generates requests for ExportAssetDescriptions
func NewExportAssetDescriptionsRequest(server string, params *ExportAssetDescriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/assets/_export-descriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HealthStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "healthStatus", runtime.ParamLocationQuery, *params.HealthStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetFilterType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assetFilterType", runtime.ParamLocationQuery, *params.AssetFilterType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Usage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "usage", runtime.ParamLocationQuery, *params.Usage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Term != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "term", runtime.ParamLocationQuery, *params.Term); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Datasource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datasource", runtime.ParamLocationQuery, *params.Datasource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchInFieldsAndDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchInFieldsAndDescriptions", runtime.ParamLocationQuery, *params.SearchInFieldsAndDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportAssetDescriptionsTemplateRequest generates requests for ExportAssetDescriptionsTemplate
func NewExportAssetDescriptionsTemplateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/assets/_export-descriptions-template")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllLightRequest generates requests for GetAllLight
func NewGetAllLightRequest(server string, params *GetAllLightParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/assets/light")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Urn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urn", runtime.ParamLocationQuery, *params.Urn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetByUrnRequest generates requests for GetAssetByUrn
func NewGetAssetByUrnRequest(server string, urn string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "urn", runtime.ParamLocationPath, urn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetOverviewByUrnRequest generates requests for GetAssetOverviewByUrn
func NewGetAssetOverviewByUrnRequest(server string, urn string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "urn", runtime.ParamLocationPath, urn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/assets/%s/overview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetSchemaByUrnAndVersionRequest generates requests for GetAssetSchemaByUrnAndVersion
func NewGetAssetSchemaByUrnAndVersionRequest(server string, urn string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "urn", runtime.ParamLocationPath, urn)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/assets/%s/schema/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatasetFieldRequest calls the generic UpdateDatasetField builder with application/json body
func NewUpdateDatasetFieldRequest(server string, id openapi_types.UUID, body UpdateDatasetFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatasetFieldRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateDatasetFieldRequestWithBody generates requests for UpdateDatasetField with any type of body
func NewUpdateDatasetFieldRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/dataset-fields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllDatasetRequest generates requests for GetAllDataset
func NewGetAllDatasetRequest(server string, params *GetAllDatasetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Urn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urn", runtime.ParamLocationQuery, *params.Urn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllDatasourceRequest generates requests for GetAllDatasource
func NewGetAllDatasourceRequest(server string, params *GetAllDatasourceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/datasources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DatasourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datasourceType", runtime.ParamLocationQuery, *params.DatasourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatasourceRequest calls the generic CreateDatasource builder with application/json body
func NewCreateDatasourceRequest(server string, body CreateDatasourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatasourceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatasourceRequestWithBody generates requests for CreateDatasource with any type of body
func NewCreateDatasourceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/datasources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestDatasourceConnectionRequest calls the generic TestDatasourceConnection builder with application/json body
func NewTestDatasourceConnectionRequest(server string, body TestDatasourceConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestDatasourceConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewTestDatasourceConnectionRequestWithBody generates requests for TestDatasourceConnection with any type of body
func NewTestDatasourceConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/datasources/_test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatasourceByIdRequest generates requests for DeleteDatasourceById
func NewDeleteDatasourceByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/datasources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatasourceByIdRequest generates requests for GetDatasourceById
func NewGetDatasourceByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/datasources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasourceIngestionManualRunRequest generates requests for DatasourceIngestionManualRun
func NewDatasourceIngestionManualRunRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/datasources/%s/_run", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatasourceIngestionRunsRequest generates requests for GetDatasourceIngestionRuns
func NewGetDatasourceIngestionRunsRequest(server string, id openapi_types.UUID, params *GetDatasourceIngestionRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/datasources/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllDomainsRequest generates requests for GetAllDomains
func NewGetAllDomainsRequest(server string, params *GetAllDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDomainRequest calls the generic CreateDomain builder with application/json body
func NewCreateDomainRequest(server string, body CreateDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDomainRequestWithBody generates requests for CreateDomain with any type of body
func NewCreateDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDomainRequest generates requests for DeleteDomain
func NewDeleteDomainRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainByIdRequest generates requests for GetDomainById
func NewGetDomainByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDomainRequest calls the generic UpdateDomain builder with application/json body
func NewUpdateDomainRequest(server string, id openapi_types.UUID, body UpdateDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDomainRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateDomainRequestWithBody generates requests for UpdateDomain with any type of body
func NewUpdateDomainRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllIncidentRequest generates requests for GetAllIncident
func NewGetAllIncidentRequest(server string, params *GetAllIncidentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/incidents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Criticality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "criticality", runtime.ParamLocationQuery, *params.Criticality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rule", runtime.ParamLocationQuery, *params.Rule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dataset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataset", runtime.ParamLocationQuery, *params.Dataset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDownstreamImpactedAssetsRequest generates requests for GetDownstreamImpactedAssets
func NewGetDownstreamImpactedAssetsRequest(server string, params *GetDownstreamImpactedAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/incidents/downstream-impacted-assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IssueNo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueNo", runtime.ParamLocationQuery, *params.IssueNo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIncidentByIssueNumberRequest generates requests for GetIncidentByIssueNumber
func NewGetIncidentByIssueNumberRequest(server string, issueNo int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issueNo", runtime.ParamLocationPath, issueNo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/incidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIncidentEventsByIssueNumberRequest generates requests for GetIncidentEventsByIssueNumber
func NewGetIncidentEventsByIssueNumberRequest(server string, issueNo int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issueNo", runtime.ParamLocationPath, issueNo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/incidents/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIncidentScopeByIssueNumberRequest generates requests for GetIncidentScopeByIssueNumber
func NewGetIncidentScopeByIssueNumberRequest(server string, issueNo int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issueNo", runtime.ParamLocationPath, issueNo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/incidents/%s/scope", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLineageByUrnRequest generates requests for GetLineageByUrn
func NewGetLineageByUrnRequest(server string, urn string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "urn", runtime.ParamLocationPath, urn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/lineages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLineageDownstreamsByUrnRequest generates requests for GetLineageDownstreamsByUrn
func NewGetLineageDownstreamsByUrnRequest(server string, urn string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "urn", runtime.ParamLocationPath, urn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/lineages/%s/downstreams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLineageUpstreamsByUrnRequest generates requests for GetLineageUpstreamsByUrn
func NewGetLineageUpstreamsByUrnRequest(server string, urn string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "urn", runtime.ParamLocationPath, urn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/lineages/%s/upstreams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleTemplateLightListRequest generates requests for GetRuleTemplateLightList
func NewGetRuleTemplateLightListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/rule-templates/light-list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSiffletRuleByIdRequest generates requests for DeleteSiffletRuleById
func NewDeleteSiffletRuleByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSiffletRuleByIdRequest generates requests for GetSiffletRuleById
func NewGetSiffletRuleByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSiffletRuleRunDebugRequest calls the generic SiffletRuleRunDebug builder with application/json body
func NewSiffletRuleRunDebugRequest(server string, id openapi_types.UUID, runId openapi_types.UUID, body SiffletRuleRunDebugJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSiffletRuleRunDebugRequestWithBody(server, id, runId, "application/json", bodyReader)
}

// NewSiffletRuleRunDebugRequestWithBody generates requests for SiffletRuleRunDebug with any type of body
func NewSiffletRuleRunDebugRequestWithBody(server string, id openapi_types.UUID, runId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runId", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/rules/%s/runs/%s/_debug", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSiffletRuleRunDownloadByRunRequest calls the generic SiffletRuleRunDownloadByRun builder with application/json body
func NewSiffletRuleRunDownloadByRunRequest(server string, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, body SiffletRuleRunDownloadByRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSiffletRuleRunDownloadByRunRequestWithBody(server, id, runId, params, "application/json", bodyReader)
}

// NewSiffletRuleRunDownloadByRunRequestWithBody generates requests for SiffletRuleRunDownloadByRun with any type of body
func NewSiffletRuleRunDownloadByRunRequestWithBody(server string, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runId", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/rules/%s/runs/%s/_download", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExportFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exportFormat", runtime.ParamLocationQuery, *params.ExportFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSiffletRuleRunDetailsRequest generates requests for GetSiffletRuleRunDetails
func NewGetSiffletRuleRunDetailsRequest(server string, id openapi_types.UUID, runId string, params *GetSiffletRuleRunDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runId", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/rules/%s/runs/%s/details", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSecretRequest generates requests for DeleteSecret
func NewDeleteSecretRequest(server string, params *DeleteSecretParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/secret")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecretRequest generates requests for GetSecret
func NewGetSecretRequest(server string, params *GetSecretParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/secret")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSecretsRequest generates requests for GetAllSecrets
func NewGetAllSecretsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataStackRequest generates requests for GetDataStack
func NewGetDataStackRequest(server string, params *GetDataStackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/statistics/data-stack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIncidentsSummaryRequest generates requests for GetIncidentsSummary
func NewGetIncidentsSummaryRequest(server string, params *GetIncidentsSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/statistics/incidents-summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesSummaryRequest generates requests for GetRulesSummary
func NewGetRulesSummaryRequest(server string, params *GetRulesSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/statistics/rules-summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllTagRequest generates requests for GetAllTag
func NewGetAllTagRequest(server string, params *GetAllTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagByIdRequest generates requests for GetTagById
func NewGetTagByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTagRequest calls the generic UpdateTag builder with application/json body
func NewUpdateTagRequest(server string, id openapi_types.UUID, body UpdateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTagRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateTagRequestWithBody generates requests for UpdateTag with any type of body
func NewUpdateTagRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTermRequest generates requests for GetAllTerm
func NewGetAllTermRequest(server string, params *GetAllTermParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TextSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "textSearch", runtime.ParamLocationQuery, *params.TextSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTermRequest calls the generic CreateTerm builder with application/json body
func NewCreateTermRequest(server string, body CreateTermJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTermRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTermRequestWithBody generates requests for CreateTerm with any type of body
func NewCreateTermRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTermRequest generates requests for DeleteTerm
func NewDeleteTermRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/terms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTermByIdRequest generates requests for GetTermById
func NewGetTermByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/terms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTermRequest calls the generic UpdateTerm builder with application/json body
func NewUpdateTermRequest(server string, id openapi_types.UUID, body UpdateTermJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTermRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateTermRequestWithBody generates requests for UpdateTerm with any type of body
func NewUpdateTermRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/terms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAssetUsageRequest generates requests for GetAssetUsage
func NewGetAssetUsageRequest(server string, assetId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/v1/usages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllWithResponse request
	GetAllWithResponse(ctx context.Context, params *GetAllParams, reqEditors ...RequestEditorFn) (*GetAllResponse, error)

	// ExportAssetDescriptionsWithResponse request
	ExportAssetDescriptionsWithResponse(ctx context.Context, params *ExportAssetDescriptionsParams, reqEditors ...RequestEditorFn) (*ExportAssetDescriptionsResponse, error)

	// ExportAssetDescriptionsTemplateWithResponse request
	ExportAssetDescriptionsTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportAssetDescriptionsTemplateResponse, error)

	// GetAllLightWithResponse request
	GetAllLightWithResponse(ctx context.Context, params *GetAllLightParams, reqEditors ...RequestEditorFn) (*GetAllLightResponse, error)

	// GetAssetByUrnWithResponse request
	GetAssetByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetAssetByUrnResponse, error)

	// GetAssetOverviewByUrnWithResponse request
	GetAssetOverviewByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetAssetOverviewByUrnResponse, error)

	// GetAssetSchemaByUrnAndVersionWithResponse request
	GetAssetSchemaByUrnAndVersionWithResponse(ctx context.Context, urn string, version string, reqEditors ...RequestEditorFn) (*GetAssetSchemaByUrnAndVersionResponse, error)

	// UpdateDatasetFieldWithBodyWithResponse request with any body
	UpdateDatasetFieldWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatasetFieldResponse, error)

	UpdateDatasetFieldWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateDatasetFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatasetFieldResponse, error)

	// GetAllDatasetWithResponse request
	GetAllDatasetWithResponse(ctx context.Context, params *GetAllDatasetParams, reqEditors ...RequestEditorFn) (*GetAllDatasetResponse, error)

	// GetAllDatasourceWithResponse request
	GetAllDatasourceWithResponse(ctx context.Context, params *GetAllDatasourceParams, reqEditors ...RequestEditorFn) (*GetAllDatasourceResponse, error)

	// CreateDatasourceWithBodyWithResponse request with any body
	CreateDatasourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatasourceResponse, error)

	CreateDatasourceWithResponse(ctx context.Context, body CreateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatasourceResponse, error)

	// TestDatasourceConnectionWithBodyWithResponse request with any body
	TestDatasourceConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestDatasourceConnectionResponse, error)

	TestDatasourceConnectionWithResponse(ctx context.Context, body TestDatasourceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestDatasourceConnectionResponse, error)

	// DeleteDatasourceByIdWithResponse request
	DeleteDatasourceByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDatasourceByIdResponse, error)

	// GetDatasourceByIdWithResponse request
	GetDatasourceByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDatasourceByIdResponse, error)

	// DatasourceIngestionManualRunWithResponse request
	DatasourceIngestionManualRunWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DatasourceIngestionManualRunResponse, error)

	// GetDatasourceIngestionRunsWithResponse request
	GetDatasourceIngestionRunsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetDatasourceIngestionRunsParams, reqEditors ...RequestEditorFn) (*GetDatasourceIngestionRunsResponse, error)

	// GetAllDomainsWithResponse request
	GetAllDomainsWithResponse(ctx context.Context, params *GetAllDomainsParams, reqEditors ...RequestEditorFn) (*GetAllDomainsResponse, error)

	// CreateDomainWithBodyWithResponse request with any body
	CreateDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error)

	CreateDomainWithResponse(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error)

	// DeleteDomainWithResponse request
	DeleteDomainWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDomainResponse, error)

	// GetDomainByIdWithResponse request
	GetDomainByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDomainByIdResponse, error)

	// UpdateDomainWithBodyWithResponse request with any body
	UpdateDomainWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error)

	UpdateDomainWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error)

	// GetAllIncidentWithResponse request
	GetAllIncidentWithResponse(ctx context.Context, params *GetAllIncidentParams, reqEditors ...RequestEditorFn) (*GetAllIncidentResponse, error)

	// GetDownstreamImpactedAssetsWithResponse request
	GetDownstreamImpactedAssetsWithResponse(ctx context.Context, params *GetDownstreamImpactedAssetsParams, reqEditors ...RequestEditorFn) (*GetDownstreamImpactedAssetsResponse, error)

	// GetIncidentByIssueNumberWithResponse request
	GetIncidentByIssueNumberWithResponse(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*GetIncidentByIssueNumberResponse, error)

	// GetIncidentEventsByIssueNumberWithResponse request
	GetIncidentEventsByIssueNumberWithResponse(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*GetIncidentEventsByIssueNumberResponse, error)

	// GetIncidentScopeByIssueNumberWithResponse request
	GetIncidentScopeByIssueNumberWithResponse(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*GetIncidentScopeByIssueNumberResponse, error)

	// GetLineageByUrnWithResponse request
	GetLineageByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetLineageByUrnResponse, error)

	// GetLineageDownstreamsByUrnWithResponse request
	GetLineageDownstreamsByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetLineageDownstreamsByUrnResponse, error)

	// GetLineageUpstreamsByUrnWithResponse request
	GetLineageUpstreamsByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetLineageUpstreamsByUrnResponse, error)

	// GetRuleTemplateLightListWithResponse request
	GetRuleTemplateLightListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuleTemplateLightListResponse, error)

	// DeleteSiffletRuleByIdWithResponse request
	DeleteSiffletRuleByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSiffletRuleByIdResponse, error)

	// GetSiffletRuleByIdWithResponse request
	GetSiffletRuleByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSiffletRuleByIdResponse, error)

	// SiffletRuleRunDebugWithBodyWithResponse request with any body
	SiffletRuleRunDebugWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SiffletRuleRunDebugResponse, error)

	SiffletRuleRunDebugWithResponse(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, body SiffletRuleRunDebugJSONRequestBody, reqEditors ...RequestEditorFn) (*SiffletRuleRunDebugResponse, error)

	// SiffletRuleRunDownloadByRunWithBodyWithResponse request with any body
	SiffletRuleRunDownloadByRunWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SiffletRuleRunDownloadByRunResponse, error)

	SiffletRuleRunDownloadByRunWithResponse(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, body SiffletRuleRunDownloadByRunJSONRequestBody, reqEditors ...RequestEditorFn) (*SiffletRuleRunDownloadByRunResponse, error)

	// GetSiffletRuleRunDetailsWithResponse request
	GetSiffletRuleRunDetailsWithResponse(ctx context.Context, id openapi_types.UUID, runId string, params *GetSiffletRuleRunDetailsParams, reqEditors ...RequestEditorFn) (*GetSiffletRuleRunDetailsResponse, error)

	// DeleteSecretWithResponse request
	DeleteSecretWithResponse(ctx context.Context, params *DeleteSecretParams, reqEditors ...RequestEditorFn) (*DeleteSecretResponse, error)

	// GetSecretWithResponse request
	GetSecretWithResponse(ctx context.Context, params *GetSecretParams, reqEditors ...RequestEditorFn) (*GetSecretResponse, error)

	// GetAllSecretsWithResponse request
	GetAllSecretsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSecretsResponse, error)

	// GetDataStackWithResponse request
	GetDataStackWithResponse(ctx context.Context, params *GetDataStackParams, reqEditors ...RequestEditorFn) (*GetDataStackResponse, error)

	// GetIncidentsSummaryWithResponse request
	GetIncidentsSummaryWithResponse(ctx context.Context, params *GetIncidentsSummaryParams, reqEditors ...RequestEditorFn) (*GetIncidentsSummaryResponse, error)

	// GetRulesSummaryWithResponse request
	GetRulesSummaryWithResponse(ctx context.Context, params *GetRulesSummaryParams, reqEditors ...RequestEditorFn) (*GetRulesSummaryResponse, error)

	// GetAllTagWithResponse request
	GetAllTagWithResponse(ctx context.Context, params *GetAllTagParams, reqEditors ...RequestEditorFn) (*GetAllTagResponse, error)

	// CreateTagWithBodyWithResponse request with any body
	CreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// DeleteTagWithResponse request
	DeleteTagWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// GetTagByIdWithResponse request
	GetTagByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetTagByIdResponse, error)

	// UpdateTagWithBodyWithResponse request with any body
	UpdateTagWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	UpdateTagWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	// GetAllTermWithResponse request
	GetAllTermWithResponse(ctx context.Context, params *GetAllTermParams, reqEditors ...RequestEditorFn) (*GetAllTermResponse, error)

	// CreateTermWithBodyWithResponse request with any body
	CreateTermWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTermResponse, error)

	CreateTermWithResponse(ctx context.Context, body CreateTermJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTermResponse, error)

	// DeleteTermWithResponse request
	DeleteTermWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteTermResponse, error)

	// GetTermByIdWithResponse request
	GetTermByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetTermByIdResponse, error)

	// UpdateTermWithBodyWithResponse request with any body
	UpdateTermWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTermResponse, error)

	UpdateTermWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateTermJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTermResponse, error)

	// GetAssetUsageWithResponse request
	GetAssetUsageWithResponse(ctx context.Context, assetId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssetUsageResponse, error)

	// ListWorkspacesWithResponse request
	ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)
}

type GetAllResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AssetsCatalogDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportAssetDescriptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CsvContentDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r ExportAssetDescriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportAssetDescriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportAssetDescriptionsTemplateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CsvContentDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r ExportAssetDescriptionsTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportAssetDescriptionsTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLightResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SearchCollectionAssetLightDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAllLightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetByUrnResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AssetDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAssetByUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetByUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetOverviewByUrnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAssetOverviewByUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetOverviewByUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetSchemaByUrnAndVersionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]FieldDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAssetSchemaByUrnAndVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetSchemaByUrnAndVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatasetFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FieldDto
}

// Status returns HTTPResponse.Status
func (r UpdateDatasetFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatasetFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDatasetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SearchCollectionDatasetLightDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAllDatasetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDatasetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDatasourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DatasourceSearchDto
	JSON206                   *DatasourceSearchDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAllDatasourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDatasourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatasourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DatasourceDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON426 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r CreateDatasourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatasourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestDatasourceConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ConnectionTestDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r TestDatasourceConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestDatasourceConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatasourceByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON204                   *DatasourceDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteDatasourceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatasourceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatasourceByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DatasourceDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetDatasourceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatasourceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasourceIngestionManualRunResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DatasourceIngestionManualRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasourceIngestionManualRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatasourceIngestionRunsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SearchCollectionDatasourceIngestionRunDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetDatasourceIngestionRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatasourceIngestionRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDomainsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SearchCollectionDomainDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAllDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDomainResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DomainDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r CreateDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDomainResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DomainDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetDomainByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDomainResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DomainDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r UpdateDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllIncidentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentSearchDto
	JSON206                   *IncidentSearchDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAllIncidentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllIncidentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDownstreamImpactedAssetsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ImpactedAssetsSearchDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetDownstreamImpactedAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDownstreamImpactedAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentByIssueNumberResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IssueDetailsDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetIncidentByIssueNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentByIssueNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentEventsByIssueNumberResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]EventDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetIncidentEventsByIssueNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentEventsByIssueNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentScopeByIssueNumberResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentScope
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetIncidentScopeByIssueNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentScopeByIssueNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLineageByUrnResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LineageEntityDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetLineageByUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLineageByUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLineageDownstreamsByUrnResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]LineageEntityDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetLineageDownstreamsByUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLineageDownstreamsByUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLineageUpstreamsByUrnResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]LineageEntityDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetLineageUpstreamsByUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLineageUpstreamsByUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleTemplateLightListResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]RuleTemplateLightDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetRuleTemplateLightListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleTemplateLightListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSiffletRuleByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON204                   *RuleDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteSiffletRuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSiffletRuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiffletRuleByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RuleDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetSiffletRuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiffletRuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SiffletRuleRunDebugResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RuleRunDebugDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r SiffletRuleRunDebugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SiffletRuleRunDebugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SiffletRuleRunDownloadByRunResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *openapi_types.File
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r SiffletRuleRunDownloadByRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SiffletRuleRunDownloadByRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiffletRuleRunDetailsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SearchCollectionRuleRunDetailsByGroupDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetSiffletRuleRunDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiffletRuleRunDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecretDto
}

// Status returns HTTPResponse.Status
func (r GetSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SecretDto
}

// Status returns HTTPResponse.Status
func (r GetAllSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataStackResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DataStackSummaryDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetDataStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentsSummaryResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentSummaryDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetIncidentsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesSummaryResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DataQualityRuleSummaryDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetRulesSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTagResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SearchCollectionTagDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAllTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *TagDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TagDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetTagByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTagResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TagDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r UpdateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTermResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SearchCollectionTagDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAllTermResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTermResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTermResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *TagDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r CreateTermResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTermResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTermResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteTermResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTermResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTermByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TagDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetTermByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTermByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTermResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TagDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r UpdateTermResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTermResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetUsageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AssetUsageDto
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON409 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r GetAssetUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AsCodeWorkspaceDto
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllWithResponse request returning *GetAllResponse
func (c *ClientWithResponses) GetAllWithResponse(ctx context.Context, params *GetAllParams, reqEditors ...RequestEditorFn) (*GetAllResponse, error) {
	rsp, err := c.GetAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllResponse(rsp)
}

// ExportAssetDescriptionsWithResponse request returning *ExportAssetDescriptionsResponse
func (c *ClientWithResponses) ExportAssetDescriptionsWithResponse(ctx context.Context, params *ExportAssetDescriptionsParams, reqEditors ...RequestEditorFn) (*ExportAssetDescriptionsResponse, error) {
	rsp, err := c.ExportAssetDescriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAssetDescriptionsResponse(rsp)
}

// ExportAssetDescriptionsTemplateWithResponse request returning *ExportAssetDescriptionsTemplateResponse
func (c *ClientWithResponses) ExportAssetDescriptionsTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportAssetDescriptionsTemplateResponse, error) {
	rsp, err := c.ExportAssetDescriptionsTemplate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAssetDescriptionsTemplateResponse(rsp)
}

// GetAllLightWithResponse request returning *GetAllLightResponse
func (c *ClientWithResponses) GetAllLightWithResponse(ctx context.Context, params *GetAllLightParams, reqEditors ...RequestEditorFn) (*GetAllLightResponse, error) {
	rsp, err := c.GetAllLight(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLightResponse(rsp)
}

// GetAssetByUrnWithResponse request returning *GetAssetByUrnResponse
func (c *ClientWithResponses) GetAssetByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetAssetByUrnResponse, error) {
	rsp, err := c.GetAssetByUrn(ctx, urn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetByUrnResponse(rsp)
}

// GetAssetOverviewByUrnWithResponse request returning *GetAssetOverviewByUrnResponse
func (c *ClientWithResponses) GetAssetOverviewByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetAssetOverviewByUrnResponse, error) {
	rsp, err := c.GetAssetOverviewByUrn(ctx, urn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetOverviewByUrnResponse(rsp)
}

// GetAssetSchemaByUrnAndVersionWithResponse request returning *GetAssetSchemaByUrnAndVersionResponse
func (c *ClientWithResponses) GetAssetSchemaByUrnAndVersionWithResponse(ctx context.Context, urn string, version string, reqEditors ...RequestEditorFn) (*GetAssetSchemaByUrnAndVersionResponse, error) {
	rsp, err := c.GetAssetSchemaByUrnAndVersion(ctx, urn, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetSchemaByUrnAndVersionResponse(rsp)
}

// UpdateDatasetFieldWithBodyWithResponse request with arbitrary body returning *UpdateDatasetFieldResponse
func (c *ClientWithResponses) UpdateDatasetFieldWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatasetFieldResponse, error) {
	rsp, err := c.UpdateDatasetFieldWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatasetFieldResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatasetFieldWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateDatasetFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatasetFieldResponse, error) {
	rsp, err := c.UpdateDatasetField(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatasetFieldResponse(rsp)
}

// GetAllDatasetWithResponse request returning *GetAllDatasetResponse
func (c *ClientWithResponses) GetAllDatasetWithResponse(ctx context.Context, params *GetAllDatasetParams, reqEditors ...RequestEditorFn) (*GetAllDatasetResponse, error) {
	rsp, err := c.GetAllDataset(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDatasetResponse(rsp)
}

// GetAllDatasourceWithResponse request returning *GetAllDatasourceResponse
func (c *ClientWithResponses) GetAllDatasourceWithResponse(ctx context.Context, params *GetAllDatasourceParams, reqEditors ...RequestEditorFn) (*GetAllDatasourceResponse, error) {
	rsp, err := c.GetAllDatasource(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDatasourceResponse(rsp)
}

// CreateDatasourceWithBodyWithResponse request with arbitrary body returning *CreateDatasourceResponse
func (c *ClientWithResponses) CreateDatasourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatasourceResponse, error) {
	rsp, err := c.CreateDatasourceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatasourceResponse(rsp)
}

func (c *ClientWithResponses) CreateDatasourceWithResponse(ctx context.Context, body CreateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatasourceResponse, error) {
	rsp, err := c.CreateDatasource(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatasourceResponse(rsp)
}

// TestDatasourceConnectionWithBodyWithResponse request with arbitrary body returning *TestDatasourceConnectionResponse
func (c *ClientWithResponses) TestDatasourceConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestDatasourceConnectionResponse, error) {
	rsp, err := c.TestDatasourceConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestDatasourceConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestDatasourceConnectionWithResponse(ctx context.Context, body TestDatasourceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestDatasourceConnectionResponse, error) {
	rsp, err := c.TestDatasourceConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestDatasourceConnectionResponse(rsp)
}

// DeleteDatasourceByIdWithResponse request returning *DeleteDatasourceByIdResponse
func (c *ClientWithResponses) DeleteDatasourceByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDatasourceByIdResponse, error) {
	rsp, err := c.DeleteDatasourceById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatasourceByIdResponse(rsp)
}

// GetDatasourceByIdWithResponse request returning *GetDatasourceByIdResponse
func (c *ClientWithResponses) GetDatasourceByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDatasourceByIdResponse, error) {
	rsp, err := c.GetDatasourceById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatasourceByIdResponse(rsp)
}

// DatasourceIngestionManualRunWithResponse request returning *DatasourceIngestionManualRunResponse
func (c *ClientWithResponses) DatasourceIngestionManualRunWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DatasourceIngestionManualRunResponse, error) {
	rsp, err := c.DatasourceIngestionManualRun(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasourceIngestionManualRunResponse(rsp)
}

// GetDatasourceIngestionRunsWithResponse request returning *GetDatasourceIngestionRunsResponse
func (c *ClientWithResponses) GetDatasourceIngestionRunsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetDatasourceIngestionRunsParams, reqEditors ...RequestEditorFn) (*GetDatasourceIngestionRunsResponse, error) {
	rsp, err := c.GetDatasourceIngestionRuns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatasourceIngestionRunsResponse(rsp)
}

// GetAllDomainsWithResponse request returning *GetAllDomainsResponse
func (c *ClientWithResponses) GetAllDomainsWithResponse(ctx context.Context, params *GetAllDomainsParams, reqEditors ...RequestEditorFn) (*GetAllDomainsResponse, error) {
	rsp, err := c.GetAllDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDomainsResponse(rsp)
}

// CreateDomainWithBodyWithResponse request with arbitrary body returning *CreateDomainResponse
func (c *ClientWithResponses) CreateDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error) {
	rsp, err := c.CreateDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateDomainWithResponse(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error) {
	rsp, err := c.CreateDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainResponse(rsp)
}

// DeleteDomainWithResponse request returning *DeleteDomainResponse
func (c *ClientWithResponses) DeleteDomainWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDomainResponse, error) {
	rsp, err := c.DeleteDomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDomainResponse(rsp)
}

// GetDomainByIdWithResponse request returning *GetDomainByIdResponse
func (c *ClientWithResponses) GetDomainByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDomainByIdResponse, error) {
	rsp, err := c.GetDomainById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainByIdResponse(rsp)
}

// UpdateDomainWithBodyWithResponse request with arbitrary body returning *UpdateDomainResponse
func (c *ClientWithResponses) UpdateDomainWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error) {
	rsp, err := c.UpdateDomainWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainResponse(rsp)
}

func (c *ClientWithResponses) UpdateDomainWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error) {
	rsp, err := c.UpdateDomain(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainResponse(rsp)
}

// GetAllIncidentWithResponse request returning *GetAllIncidentResponse
func (c *ClientWithResponses) GetAllIncidentWithResponse(ctx context.Context, params *GetAllIncidentParams, reqEditors ...RequestEditorFn) (*GetAllIncidentResponse, error) {
	rsp, err := c.GetAllIncident(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllIncidentResponse(rsp)
}

// GetDownstreamImpactedAssetsWithResponse request returning *GetDownstreamImpactedAssetsResponse
func (c *ClientWithResponses) GetDownstreamImpactedAssetsWithResponse(ctx context.Context, params *GetDownstreamImpactedAssetsParams, reqEditors ...RequestEditorFn) (*GetDownstreamImpactedAssetsResponse, error) {
	rsp, err := c.GetDownstreamImpactedAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDownstreamImpactedAssetsResponse(rsp)
}

// GetIncidentByIssueNumberWithResponse request returning *GetIncidentByIssueNumberResponse
func (c *ClientWithResponses) GetIncidentByIssueNumberWithResponse(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*GetIncidentByIssueNumberResponse, error) {
	rsp, err := c.GetIncidentByIssueNumber(ctx, issueNo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentByIssueNumberResponse(rsp)
}

// GetIncidentEventsByIssueNumberWithResponse request returning *GetIncidentEventsByIssueNumberResponse
func (c *ClientWithResponses) GetIncidentEventsByIssueNumberWithResponse(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*GetIncidentEventsByIssueNumberResponse, error) {
	rsp, err := c.GetIncidentEventsByIssueNumber(ctx, issueNo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentEventsByIssueNumberResponse(rsp)
}

// GetIncidentScopeByIssueNumberWithResponse request returning *GetIncidentScopeByIssueNumberResponse
func (c *ClientWithResponses) GetIncidentScopeByIssueNumberWithResponse(ctx context.Context, issueNo int32, reqEditors ...RequestEditorFn) (*GetIncidentScopeByIssueNumberResponse, error) {
	rsp, err := c.GetIncidentScopeByIssueNumber(ctx, issueNo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentScopeByIssueNumberResponse(rsp)
}

// GetLineageByUrnWithResponse request returning *GetLineageByUrnResponse
func (c *ClientWithResponses) GetLineageByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetLineageByUrnResponse, error) {
	rsp, err := c.GetLineageByUrn(ctx, urn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLineageByUrnResponse(rsp)
}

// GetLineageDownstreamsByUrnWithResponse request returning *GetLineageDownstreamsByUrnResponse
func (c *ClientWithResponses) GetLineageDownstreamsByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetLineageDownstreamsByUrnResponse, error) {
	rsp, err := c.GetLineageDownstreamsByUrn(ctx, urn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLineageDownstreamsByUrnResponse(rsp)
}

// GetLineageUpstreamsByUrnWithResponse request returning *GetLineageUpstreamsByUrnResponse
func (c *ClientWithResponses) GetLineageUpstreamsByUrnWithResponse(ctx context.Context, urn string, reqEditors ...RequestEditorFn) (*GetLineageUpstreamsByUrnResponse, error) {
	rsp, err := c.GetLineageUpstreamsByUrn(ctx, urn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLineageUpstreamsByUrnResponse(rsp)
}

// GetRuleTemplateLightListWithResponse request returning *GetRuleTemplateLightListResponse
func (c *ClientWithResponses) GetRuleTemplateLightListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuleTemplateLightListResponse, error) {
	rsp, err := c.GetRuleTemplateLightList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleTemplateLightListResponse(rsp)
}

// DeleteSiffletRuleByIdWithResponse request returning *DeleteSiffletRuleByIdResponse
func (c *ClientWithResponses) DeleteSiffletRuleByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSiffletRuleByIdResponse, error) {
	rsp, err := c.DeleteSiffletRuleById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSiffletRuleByIdResponse(rsp)
}

// GetSiffletRuleByIdWithResponse request returning *GetSiffletRuleByIdResponse
func (c *ClientWithResponses) GetSiffletRuleByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSiffletRuleByIdResponse, error) {
	rsp, err := c.GetSiffletRuleById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiffletRuleByIdResponse(rsp)
}

// SiffletRuleRunDebugWithBodyWithResponse request with arbitrary body returning *SiffletRuleRunDebugResponse
func (c *ClientWithResponses) SiffletRuleRunDebugWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SiffletRuleRunDebugResponse, error) {
	rsp, err := c.SiffletRuleRunDebugWithBody(ctx, id, runId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSiffletRuleRunDebugResponse(rsp)
}

func (c *ClientWithResponses) SiffletRuleRunDebugWithResponse(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, body SiffletRuleRunDebugJSONRequestBody, reqEditors ...RequestEditorFn) (*SiffletRuleRunDebugResponse, error) {
	rsp, err := c.SiffletRuleRunDebug(ctx, id, runId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSiffletRuleRunDebugResponse(rsp)
}

// SiffletRuleRunDownloadByRunWithBodyWithResponse request with arbitrary body returning *SiffletRuleRunDownloadByRunResponse
func (c *ClientWithResponses) SiffletRuleRunDownloadByRunWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SiffletRuleRunDownloadByRunResponse, error) {
	rsp, err := c.SiffletRuleRunDownloadByRunWithBody(ctx, id, runId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSiffletRuleRunDownloadByRunResponse(rsp)
}

func (c *ClientWithResponses) SiffletRuleRunDownloadByRunWithResponse(ctx context.Context, id openapi_types.UUID, runId openapi_types.UUID, params *SiffletRuleRunDownloadByRunParams, body SiffletRuleRunDownloadByRunJSONRequestBody, reqEditors ...RequestEditorFn) (*SiffletRuleRunDownloadByRunResponse, error) {
	rsp, err := c.SiffletRuleRunDownloadByRun(ctx, id, runId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSiffletRuleRunDownloadByRunResponse(rsp)
}

// GetSiffletRuleRunDetailsWithResponse request returning *GetSiffletRuleRunDetailsResponse
func (c *ClientWithResponses) GetSiffletRuleRunDetailsWithResponse(ctx context.Context, id openapi_types.UUID, runId string, params *GetSiffletRuleRunDetailsParams, reqEditors ...RequestEditorFn) (*GetSiffletRuleRunDetailsResponse, error) {
	rsp, err := c.GetSiffletRuleRunDetails(ctx, id, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiffletRuleRunDetailsResponse(rsp)
}

// DeleteSecretWithResponse request returning *DeleteSecretResponse
func (c *ClientWithResponses) DeleteSecretWithResponse(ctx context.Context, params *DeleteSecretParams, reqEditors ...RequestEditorFn) (*DeleteSecretResponse, error) {
	rsp, err := c.DeleteSecret(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecretResponse(rsp)
}

// GetSecretWithResponse request returning *GetSecretResponse
func (c *ClientWithResponses) GetSecretWithResponse(ctx context.Context, params *GetSecretParams, reqEditors ...RequestEditorFn) (*GetSecretResponse, error) {
	rsp, err := c.GetSecret(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecretResponse(rsp)
}

// GetAllSecretsWithResponse request returning *GetAllSecretsResponse
func (c *ClientWithResponses) GetAllSecretsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSecretsResponse, error) {
	rsp, err := c.GetAllSecrets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSecretsResponse(rsp)
}

// GetDataStackWithResponse request returning *GetDataStackResponse
func (c *ClientWithResponses) GetDataStackWithResponse(ctx context.Context, params *GetDataStackParams, reqEditors ...RequestEditorFn) (*GetDataStackResponse, error) {
	rsp, err := c.GetDataStack(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataStackResponse(rsp)
}

// GetIncidentsSummaryWithResponse request returning *GetIncidentsSummaryResponse
func (c *ClientWithResponses) GetIncidentsSummaryWithResponse(ctx context.Context, params *GetIncidentsSummaryParams, reqEditors ...RequestEditorFn) (*GetIncidentsSummaryResponse, error) {
	rsp, err := c.GetIncidentsSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentsSummaryResponse(rsp)
}

// GetRulesSummaryWithResponse request returning *GetRulesSummaryResponse
func (c *ClientWithResponses) GetRulesSummaryWithResponse(ctx context.Context, params *GetRulesSummaryParams, reqEditors ...RequestEditorFn) (*GetRulesSummaryResponse, error) {
	rsp, err := c.GetRulesSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesSummaryResponse(rsp)
}

// GetAllTagWithResponse request returning *GetAllTagResponse
func (c *ClientWithResponses) GetAllTagWithResponse(ctx context.Context, params *GetAllTagParams, reqEditors ...RequestEditorFn) (*GetAllTagResponse, error) {
	rsp, err := c.GetAllTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTagResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// GetTagByIdWithResponse request returning *GetTagByIdResponse
func (c *ClientWithResponses) GetTagByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetTagByIdResponse, error) {
	rsp, err := c.GetTagById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagByIdResponse(rsp)
}

// UpdateTagWithBodyWithResponse request with arbitrary body returning *UpdateTagResponse
func (c *ClientWithResponses) UpdateTagWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTagWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateTagWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTag(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

// GetAllTermWithResponse request returning *GetAllTermResponse
func (c *ClientWithResponses) GetAllTermWithResponse(ctx context.Context, params *GetAllTermParams, reqEditors ...RequestEditorFn) (*GetAllTermResponse, error) {
	rsp, err := c.GetAllTerm(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTermResponse(rsp)
}

// CreateTermWithBodyWithResponse request with arbitrary body returning *CreateTermResponse
func (c *ClientWithResponses) CreateTermWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTermResponse, error) {
	rsp, err := c.CreateTermWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTermResponse(rsp)
}

func (c *ClientWithResponses) CreateTermWithResponse(ctx context.Context, body CreateTermJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTermResponse, error) {
	rsp, err := c.CreateTerm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTermResponse(rsp)
}

// DeleteTermWithResponse request returning *DeleteTermResponse
func (c *ClientWithResponses) DeleteTermWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteTermResponse, error) {
	rsp, err := c.DeleteTerm(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTermResponse(rsp)
}

// GetTermByIdWithResponse request returning *GetTermByIdResponse
func (c *ClientWithResponses) GetTermByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetTermByIdResponse, error) {
	rsp, err := c.GetTermById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTermByIdResponse(rsp)
}

// UpdateTermWithBodyWithResponse request with arbitrary body returning *UpdateTermResponse
func (c *ClientWithResponses) UpdateTermWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTermResponse, error) {
	rsp, err := c.UpdateTermWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTermResponse(rsp)
}

func (c *ClientWithResponses) UpdateTermWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateTermJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTermResponse, error) {
	rsp, err := c.UpdateTerm(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTermResponse(rsp)
}

// GetAssetUsageWithResponse request returning *GetAssetUsageResponse
func (c *ClientWithResponses) GetAssetUsageWithResponse(ctx context.Context, assetId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssetUsageResponse, error) {
	rsp, err := c.GetAssetUsage(ctx, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetUsageResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// ParseGetAllResponse parses an HTTP response from a GetAllWithResponse call
func ParseGetAllResponse(rsp *http.Response) (*GetAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetsCatalogDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseExportAssetDescriptionsResponse parses an HTTP response from a ExportAssetDescriptionsWithResponse call
func ParseExportAssetDescriptionsResponse(rsp *http.Response) (*ExportAssetDescriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportAssetDescriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CsvContentDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseExportAssetDescriptionsTemplateResponse parses an HTTP response from a ExportAssetDescriptionsTemplateWithResponse call
func ParseExportAssetDescriptionsTemplateResponse(rsp *http.Response) (*ExportAssetDescriptionsTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportAssetDescriptionsTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CsvContentDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAllLightResponse parses an HTTP response from a GetAllLightWithResponse call
func ParseGetAllLightResponse(rsp *http.Response) (*GetAllLightResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCollectionAssetLightDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetByUrnResponse parses an HTTP response from a GetAssetByUrnWithResponse call
func ParseGetAssetByUrnResponse(rsp *http.Response) (*GetAssetByUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetByUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetOverviewByUrnResponse parses an HTTP response from a GetAssetOverviewByUrnWithResponse call
func ParseGetAssetOverviewByUrnResponse(rsp *http.Response) (*GetAssetOverviewByUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetOverviewByUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetSchemaByUrnAndVersionResponse parses an HTTP response from a GetAssetSchemaByUrnAndVersionWithResponse call
func ParseGetAssetSchemaByUrnAndVersionResponse(rsp *http.Response) (*GetAssetSchemaByUrnAndVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetSchemaByUrnAndVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FieldDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDatasetFieldResponse parses an HTTP response from a UpdateDatasetFieldWithResponse call
func ParseUpdateDatasetFieldResponse(rsp *http.Response) (*UpdateDatasetFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatasetFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FieldDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllDatasetResponse parses an HTTP response from a GetAllDatasetWithResponse call
func ParseGetAllDatasetResponse(rsp *http.Response) (*GetAllDatasetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDatasetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCollectionDatasetLightDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAllDatasourceResponse parses an HTTP response from a GetAllDatasourceWithResponse call
func ParseGetAllDatasourceResponse(rsp *http.Response) (*GetAllDatasourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDatasourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasourceSearchDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 206:
		var dest DatasourceSearchDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON206 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDatasourceResponse parses an HTTP response from a CreateDatasourceWithResponse call
func ParseCreateDatasourceResponse(rsp *http.Response) (*CreateDatasourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatasourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DatasourceDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 426:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON426 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseTestDatasourceConnectionResponse parses an HTTP response from a TestDatasourceConnectionWithResponse call
func ParseTestDatasourceConnectionResponse(rsp *http.Response) (*TestDatasourceConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestDatasourceConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectionTestDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDatasourceByIdResponse parses an HTTP response from a DeleteDatasourceByIdWithResponse call
func ParseDeleteDatasourceByIdResponse(rsp *http.Response) (*DeleteDatasourceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatasourceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest DatasourceDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDatasourceByIdResponse parses an HTTP response from a GetDatasourceByIdWithResponse call
func ParseGetDatasourceByIdResponse(rsp *http.Response) (*GetDatasourceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatasourceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasourceDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDatasourceIngestionManualRunResponse parses an HTTP response from a DatasourceIngestionManualRunWithResponse call
func ParseDatasourceIngestionManualRunResponse(rsp *http.Response) (*DatasourceIngestionManualRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasourceIngestionManualRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDatasourceIngestionRunsResponse parses an HTTP response from a GetDatasourceIngestionRunsWithResponse call
func ParseGetDatasourceIngestionRunsResponse(rsp *http.Response) (*GetDatasourceIngestionRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatasourceIngestionRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCollectionDatasourceIngestionRunDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAllDomainsResponse parses an HTTP response from a GetAllDomainsWithResponse call
func ParseGetAllDomainsResponse(rsp *http.Response) (*GetAllDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCollectionDomainDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDomainResponse parses an HTTP response from a CreateDomainWithResponse call
func ParseCreateDomainResponse(rsp *http.Response) (*CreateDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DomainDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDomainResponse parses an HTTP response from a DeleteDomainWithResponse call
func ParseDeleteDomainResponse(rsp *http.Response) (*DeleteDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainByIdResponse parses an HTTP response from a GetDomainByIdWithResponse call
func ParseGetDomainByIdResponse(rsp *http.Response) (*GetDomainByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDomainResponse parses an HTTP response from a UpdateDomainWithResponse call
func ParseUpdateDomainResponse(rsp *http.Response) (*UpdateDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAllIncidentResponse parses an HTTP response from a GetAllIncidentWithResponse call
func ParseGetAllIncidentResponse(rsp *http.Response) (*GetAllIncidentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllIncidentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentSearchDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 206:
		var dest IncidentSearchDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON206 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDownstreamImpactedAssetsResponse parses an HTTP response from a GetDownstreamImpactedAssetsWithResponse call
func ParseGetDownstreamImpactedAssetsResponse(rsp *http.Response) (*GetDownstreamImpactedAssetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDownstreamImpactedAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImpactedAssetsSearchDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIncidentByIssueNumberResponse parses an HTTP response from a GetIncidentByIssueNumberWithResponse call
func ParseGetIncidentByIssueNumberResponse(rsp *http.Response) (*GetIncidentByIssueNumberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentByIssueNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueDetailsDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIncidentEventsByIssueNumberResponse parses an HTTP response from a GetIncidentEventsByIssueNumberWithResponse call
func ParseGetIncidentEventsByIssueNumberResponse(rsp *http.Response) (*GetIncidentEventsByIssueNumberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentEventsByIssueNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EventDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIncidentScopeByIssueNumberResponse parses an HTTP response from a GetIncidentScopeByIssueNumberWithResponse call
func ParseGetIncidentScopeByIssueNumberResponse(rsp *http.Response) (*GetIncidentScopeByIssueNumberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentScopeByIssueNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentScope
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetLineageByUrnResponse parses an HTTP response from a GetLineageByUrnWithResponse call
func ParseGetLineageByUrnResponse(rsp *http.Response) (*GetLineageByUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLineageByUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LineageEntityDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetLineageDownstreamsByUrnResponse parses an HTTP response from a GetLineageDownstreamsByUrnWithResponse call
func ParseGetLineageDownstreamsByUrnResponse(rsp *http.Response) (*GetLineageDownstreamsByUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLineageDownstreamsByUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LineageEntityDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetLineageUpstreamsByUrnResponse parses an HTTP response from a GetLineageUpstreamsByUrnWithResponse call
func ParseGetLineageUpstreamsByUrnResponse(rsp *http.Response) (*GetLineageUpstreamsByUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLineageUpstreamsByUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LineageEntityDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRuleTemplateLightListResponse parses an HTTP response from a GetRuleTemplateLightListWithResponse call
func ParseGetRuleTemplateLightListResponse(rsp *http.Response) (*GetRuleTemplateLightListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleTemplateLightListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RuleTemplateLightDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSiffletRuleByIdResponse parses an HTTP response from a DeleteSiffletRuleByIdWithResponse call
func ParseDeleteSiffletRuleByIdResponse(rsp *http.Response) (*DeleteSiffletRuleByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSiffletRuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest RuleDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSiffletRuleByIdResponse parses an HTTP response from a GetSiffletRuleByIdWithResponse call
func ParseGetSiffletRuleByIdResponse(rsp *http.Response) (*GetSiffletRuleByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiffletRuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSiffletRuleRunDebugResponse parses an HTTP response from a SiffletRuleRunDebugWithResponse call
func ParseSiffletRuleRunDebugResponse(rsp *http.Response) (*SiffletRuleRunDebugResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SiffletRuleRunDebugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleRunDebugDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSiffletRuleRunDownloadByRunResponse parses an HTTP response from a SiffletRuleRunDownloadByRunWithResponse call
func ParseSiffletRuleRunDownloadByRunResponse(rsp *http.Response) (*SiffletRuleRunDownloadByRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SiffletRuleRunDownloadByRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetSiffletRuleRunDetailsResponse parses an HTTP response from a GetSiffletRuleRunDetailsWithResponse call
func ParseGetSiffletRuleRunDetailsResponse(rsp *http.Response) (*GetSiffletRuleRunDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiffletRuleRunDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCollectionRuleRunDetailsByGroupDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecretResponse parses an HTTP response from a DeleteSecretWithResponse call
func ParseDeleteSecretResponse(rsp *http.Response) (*DeleteSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSecretResponse parses an HTTP response from a GetSecretWithResponse call
func ParseGetSecretResponse(rsp *http.Response) (*GetSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecretDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllSecretsResponse parses an HTTP response from a GetAllSecretsWithResponse call
func ParseGetAllSecretsResponse(rsp *http.Response) (*GetAllSecretsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SecretDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDataStackResponse parses an HTTP response from a GetDataStackWithResponse call
func ParseGetDataStackResponse(rsp *http.Response) (*GetDataStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataStackSummaryDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIncidentsSummaryResponse parses an HTTP response from a GetIncidentsSummaryWithResponse call
func ParseGetIncidentsSummaryResponse(rsp *http.Response) (*GetIncidentsSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentSummaryDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRulesSummaryResponse parses an HTTP response from a GetRulesSummaryWithResponse call
func ParseGetRulesSummaryResponse(rsp *http.Response) (*GetRulesSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataQualityRuleSummaryDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAllTagResponse parses an HTTP response from a GetAllTagWithResponse call
func ParseGetAllTagResponse(rsp *http.Response) (*GetAllTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCollectionTagDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TagDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetTagByIdResponse parses an HTTP response from a GetTagByIdWithResponse call
func ParseGetTagByIdResponse(rsp *http.Response) (*GetTagByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTagResponse parses an HTTP response from a UpdateTagWithResponse call
func ParseUpdateTagResponse(rsp *http.Response) (*UpdateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAllTermResponse parses an HTTP response from a GetAllTermWithResponse call
func ParseGetAllTermResponse(rsp *http.Response) (*GetAllTermResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTermResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCollectionTagDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateTermResponse parses an HTTP response from a CreateTermWithResponse call
func ParseCreateTermResponse(rsp *http.Response) (*CreateTermResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTermResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TagDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTermResponse parses an HTTP response from a DeleteTermWithResponse call
func ParseDeleteTermResponse(rsp *http.Response) (*DeleteTermResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTermResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetTermByIdResponse parses an HTTP response from a GetTermByIdWithResponse call
func ParseGetTermByIdResponse(rsp *http.Response) (*GetTermByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTermByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTermResponse parses an HTTP response from a UpdateTermWithResponse call
func ParseUpdateTermResponse(rsp *http.Response) (*UpdateTermResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTermResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetUsageResponse parses an HTTP response from a GetAssetUsageWithResponse call
func ParseGetAssetUsageResponse(rsp *http.Response) (*GetAssetUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetUsageDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AsCodeWorkspaceDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get search results and search filters for asset
	// (GET /ui/v1/assets)
	GetAll(ctx echo.Context, params GetAllParams) error
	// Export asset descriptions
	// (GET /ui/v1/assets/_export-descriptions)
	ExportAssetDescriptions(ctx echo.Context, params ExportAssetDescriptionsParams) error
	// Export asset descriptions template
	// (GET /ui/v1/assets/_export-descriptions-template)
	ExportAssetDescriptionsTemplate(ctx echo.Context) error
	// Get search results and search filters for asset
	// (GET /ui/v1/assets/light)
	GetAllLight(ctx echo.Context, params GetAllLightParams) error
	// Get a single asset
	// (GET /ui/v1/assets/{urn})
	GetAssetByUrn(ctx echo.Context, urn string) error
	// Get a single asset overview params
	// (GET /ui/v1/assets/{urn}/overview)
	GetAssetOverviewByUrn(ctx echo.Context, urn string) error
	// Get a single asset schema
	// (GET /ui/v1/assets/{urn}/schema/{version})
	GetAssetSchemaByUrnAndVersion(ctx echo.Context, urn string, version string) error

	// (PATCH /ui/v1/dataset-fields/{id})
	UpdateDatasetField(ctx echo.Context, id openapi_types.UUID) error
	// Fetch datasets
	// (GET /ui/v1/datasets)
	GetAllDataset(ctx echo.Context, params GetAllDatasetParams) error
	// Perform a search query on datasource resource
	// (GET /ui/v1/datasources)
	GetAllDatasource(ctx echo.Context, params GetAllDatasourceParams) error
	// Create a datasource
	// (POST /ui/v1/datasources)
	CreateDatasource(ctx echo.Context) error
	// Test connection with given datasource params
	// (POST /ui/v1/datasources/_test)
	TestDatasourceConnection(ctx echo.Context) error
	// Delete datasource by given id
	// (DELETE /ui/v1/datasources/{id})
	DeleteDatasourceById(ctx echo.Context, id openapi_types.UUID) error
	// Get a single datasource
	// (GET /ui/v1/datasources/{id})
	GetDatasourceById(ctx echo.Context, id openapi_types.UUID) error
	// Manually trigger of datasource metadata ingestion job
	// (POST /ui/v1/datasources/{id}/_run)
	DatasourceIngestionManualRun(ctx echo.Context, id openapi_types.UUID) error
	// Fetch a datasource ingestion runs
	// (GET /ui/v1/datasources/{id}/runs)
	GetDatasourceIngestionRuns(ctx echo.Context, id openapi_types.UUID, params GetDatasourceIngestionRunsParams) error
	// Get all domains
	// (GET /ui/v1/domains)
	GetAllDomains(ctx echo.Context, params GetAllDomainsParams) error
	// Create a domain
	// (POST /ui/v1/domains)
	CreateDomain(ctx echo.Context) error
	// Delete a domain
	// (DELETE /ui/v1/domains/{id})
	DeleteDomain(ctx echo.Context, id openapi_types.UUID) error
	// Get domain by id
	// (GET /ui/v1/domains/{id})
	GetDomainById(ctx echo.Context, id openapi_types.UUID) error
	// Update a domain
	// (PUT /ui/v1/domains/{id})
	UpdateDomain(ctx echo.Context, id openapi_types.UUID) error
	// Get incidents
	// (GET /ui/v1/incidents)
	GetAllIncident(ctx echo.Context, params GetAllIncidentParams) error
	// Get assets impacted by incident
	// (GET /ui/v1/incidents/downstream-impacted-assets)
	GetDownstreamImpactedAssets(ctx echo.Context, params GetDownstreamImpactedAssetsParams) error
	// Get single incident by issue number
	// (GET /ui/v1/incidents/{issueNo})
	GetIncidentByIssueNumber(ctx echo.Context, issueNo int32) error
	// Get an incident events
	// (GET /ui/v1/incidents/{issueNo}/events)
	GetIncidentEventsByIssueNumber(ctx echo.Context, issueNo int32) error
	// Get single incident scope by issue number
	// (GET /ui/v1/incidents/{issueNo}/scope)
	GetIncidentScopeByIssueNumber(ctx echo.Context, issueNo int32) error
	// Get lineage from a given resource urn
	// (GET /ui/v1/lineages/{urn})
	GetLineageByUrn(ctx echo.Context, urn string) error
	// Get lineage downstreams from a given resource urn
	// (GET /ui/v1/lineages/{urn}/downstreams)
	GetLineageDownstreamsByUrn(ctx echo.Context, urn string) error
	// Get lineage upstreams from a given resource urn
	// (GET /ui/v1/lineages/{urn}/upstreams)
	GetLineageUpstreamsByUrn(ctx echo.Context, urn string) error
	// Fetch a light version of Rule Template list
	// (GET /ui/v1/rule-templates/light-list)
	GetRuleTemplateLightList(ctx echo.Context) error
	// Delete Sifflet rule by given id
	// (DELETE /ui/v1/rules/{id})
	DeleteSiffletRuleById(ctx echo.Context, id openapi_types.UUID) error
	// Get a single Sifflet rule
	// (GET /ui/v1/rules/{id})
	GetSiffletRuleById(ctx echo.Context, id openapi_types.UUID) error
	// Debug a Sifflet Rule run
	// (POST /ui/v1/rules/{id}/runs/{runId}/_debug)
	SiffletRuleRunDebug(ctx echo.Context, id openapi_types.UUID, runId openapi_types.UUID) error
	// Download failing results of a Sifflet Rule run. The CSV created contains the first 20000 rows sent by the Database
	// (POST /ui/v1/rules/{id}/runs/{runId}/_download)
	SiffletRuleRunDownloadByRun(ctx echo.Context, id openapi_types.UUID, runId openapi_types.UUID, params SiffletRuleRunDownloadByRunParams) error
	// Fetch a Rule Run details
	// (GET /ui/v1/rules/{id}/runs/{runId}/details)
	GetSiffletRuleRunDetails(ctx echo.Context, id openapi_types.UUID, runId string, params GetSiffletRuleRunDetailsParams) error

	// (DELETE /ui/v1/secret)
	DeleteSecret(ctx echo.Context, params DeleteSecretParams) error

	// (GET /ui/v1/secret)
	GetSecret(ctx echo.Context, params GetSecretParams) error

	// (GET /ui/v1/secrets)
	GetAllSecrets(ctx echo.Context) error
	// Fetch data stack info
	// (GET /ui/v1/statistics/data-stack)
	GetDataStack(ctx echo.Context, params GetDataStackParams) error
	// Fetch incidents summary
	// (GET /ui/v1/statistics/incidents-summary)
	GetIncidentsSummary(ctx echo.Context, params GetIncidentsSummaryParams) error
	// Fetch rules summary
	// (GET /ui/v1/statistics/rules-summary)
	GetRulesSummary(ctx echo.Context, params GetRulesSummaryParams) error
	// Get tags
	// (GET /ui/v1/tags)
	GetAllTag(ctx echo.Context, params GetAllTagParams) error
	// Create a Tag
	// (POST /ui/v1/tags)
	CreateTag(ctx echo.Context) error
	// Delete a Tag
	// (DELETE /ui/v1/tags/{id})
	DeleteTag(ctx echo.Context, id openapi_types.UUID) error
	// Get Tag by id
	// (GET /ui/v1/tags/{id})
	GetTagById(ctx echo.Context, id openapi_types.UUID) error
	// Update a Tag
	// (PUT /ui/v1/tags/{id})
	UpdateTag(ctx echo.Context, id openapi_types.UUID) error
	// Get terms
	// (GET /ui/v1/terms)
	GetAllTerm(ctx echo.Context, params GetAllTermParams) error
	// Create a Term
	// (POST /ui/v1/terms)
	CreateTerm(ctx echo.Context) error
	// Delete a Term
	// (DELETE /ui/v1/terms/{id})
	DeleteTerm(ctx echo.Context, id openapi_types.UUID) error
	// Get Term by id
	// (GET /ui/v1/terms/{id})
	GetTermById(ctx echo.Context, id openapi_types.UUID) error
	// Update a Term
	// (PUT /ui/v1/terms/{id})
	UpdateTerm(ctx echo.Context, id openapi_types.UUID) error
	// Get asset usage
	// (GET /ui/v1/usages/{assetId})
	GetAssetUsage(ctx echo.Context, assetId openapi_types.UUID) error
	// List workspaces
	// (GET /v1/workspaces)
	ListWorkspaces(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAll converts echo context to params.
func (w *ServerInterfaceWrapper) GetAll(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "healthStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "healthStatus", ctx.QueryParams(), &params.HealthStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter healthStatus: %s", err))
	}

	// ------------- Optional query parameter "assetFilterType" -------------

	err = runtime.BindQueryParameter("form", true, false, "assetFilterType", ctx.QueryParams(), &params.AssetFilterType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFilterType: %s", err))
	}

	// ------------- Optional query parameter "usage" -------------

	err = runtime.BindQueryParameter("form", true, false, "usage", ctx.QueryParams(), &params.Usage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usage: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "term" -------------

	err = runtime.BindQueryParameter("form", true, false, "term", ctx.QueryParams(), &params.Term)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter term: %s", err))
	}

	// ------------- Optional query parameter "datasource" -------------

	err = runtime.BindQueryParameter("form", true, false, "datasource", ctx.QueryParams(), &params.Datasource)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter datasource: %s", err))
	}

	// ------------- Optional query parameter "domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain", ctx.QueryParams(), &params.Domain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain: %s", err))
	}

	// ------------- Optional query parameter "searchInFieldsAndDescriptions" -------------

	err = runtime.BindQueryParameter("form", true, false, "searchInFieldsAndDescriptions", ctx.QueryParams(), &params.SearchInFieldsAndDescriptions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter searchInFieldsAndDescriptions: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAll(ctx, params)
	return err
}

// ExportAssetDescriptions converts echo context to params.
func (w *ServerInterfaceWrapper) ExportAssetDescriptions(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportAssetDescriptionsParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "healthStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "healthStatus", ctx.QueryParams(), &params.HealthStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter healthStatus: %s", err))
	}

	// ------------- Optional query parameter "assetFilterType" -------------

	err = runtime.BindQueryParameter("form", true, false, "assetFilterType", ctx.QueryParams(), &params.AssetFilterType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFilterType: %s", err))
	}

	// ------------- Optional query parameter "usage" -------------

	err = runtime.BindQueryParameter("form", true, false, "usage", ctx.QueryParams(), &params.Usage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usage: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "term" -------------

	err = runtime.BindQueryParameter("form", true, false, "term", ctx.QueryParams(), &params.Term)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter term: %s", err))
	}

	// ------------- Optional query parameter "datasource" -------------

	err = runtime.BindQueryParameter("form", true, false, "datasource", ctx.QueryParams(), &params.Datasource)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter datasource: %s", err))
	}

	// ------------- Optional query parameter "domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain", ctx.QueryParams(), &params.Domain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain: %s", err))
	}

	// ------------- Optional query parameter "searchInFieldsAndDescriptions" -------------

	err = runtime.BindQueryParameter("form", true, false, "searchInFieldsAndDescriptions", ctx.QueryParams(), &params.SearchInFieldsAndDescriptions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter searchInFieldsAndDescriptions: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportAssetDescriptions(ctx, params)
	return err
}

// ExportAssetDescriptionsTemplate converts echo context to params.
func (w *ServerInterfaceWrapper) ExportAssetDescriptionsTemplate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportAssetDescriptionsTemplate(ctx)
	return err
}

// GetAllLight converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllLight(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllLightParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "urn" -------------

	err = runtime.BindQueryParameter("form", true, false, "urn", ctx.QueryParams(), &params.Urn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urn: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllLight(ctx, params)
	return err
}

// GetAssetByUrn converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByUrn(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "urn" -------------
	var urn string

	err = runtime.BindStyledParameterWithLocation("simple", false, "urn", runtime.ParamLocationPath, ctx.Param("urn"), &urn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urn: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByUrn(ctx, urn)
	return err
}

// GetAssetOverviewByUrn converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetOverviewByUrn(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "urn" -------------
	var urn string

	err = runtime.BindStyledParameterWithLocation("simple", false, "urn", runtime.ParamLocationPath, ctx.Param("urn"), &urn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urn: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetOverviewByUrn(ctx, urn)
	return err
}

// GetAssetSchemaByUrnAndVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetSchemaByUrnAndVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "urn" -------------
	var urn string

	err = runtime.BindStyledParameterWithLocation("simple", false, "urn", runtime.ParamLocationPath, ctx.Param("urn"), &urn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urn: %s", err))
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, ctx.Param("version"), &version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetSchemaByUrnAndVersion(ctx, urn, version)
	return err
}

// UpdateDatasetField converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDatasetField(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDatasetField(ctx, id)
	return err
}

// GetAllDataset converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllDataset(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllDatasetParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "urn" -------------

	err = runtime.BindQueryParameter("form", true, false, "urn", ctx.QueryParams(), &params.Urn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urn: %s", err))
	}

	// ------------- Optional query parameter "domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain", ctx.QueryParams(), &params.Domain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllDataset(ctx, params)
	return err
}

// GetAllDatasource converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllDatasource(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllDatasourceParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "datasourceType" -------------

	err = runtime.BindQueryParameter("form", true, false, "datasourceType", ctx.QueryParams(), &params.DatasourceType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter datasourceType: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllDatasource(ctx, params)
	return err
}

// CreateDatasource converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDatasource(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDatasource(ctx)
	return err
}

// TestDatasourceConnection converts echo context to params.
func (w *ServerInterfaceWrapper) TestDatasourceConnection(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TestDatasourceConnection(ctx)
	return err
}

// DeleteDatasourceById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDatasourceById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteDatasourceById(ctx, id)
	return err
}

// GetDatasourceById converts echo context to params.
func (w *ServerInterfaceWrapper) GetDatasourceById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDatasourceById(ctx, id)
	return err
}

// DatasourceIngestionManualRun converts echo context to params.
func (w *ServerInterfaceWrapper) DatasourceIngestionManualRun(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DatasourceIngestionManualRun(ctx, id)
	return err
}

// GetDatasourceIngestionRuns converts echo context to params.
func (w *ServerInterfaceWrapper) GetDatasourceIngestionRuns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDatasourceIngestionRunsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDatasourceIngestionRuns(ctx, id, params)
	return err
}

// GetAllDomains converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllDomains(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllDomainsParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllDomains(ctx, params)
	return err
}

// CreateDomain converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDomain(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDomain(ctx)
	return err
}

// DeleteDomain converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteDomain(ctx, id)
	return err
}

// GetDomainById converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainById(ctx, id)
	return err
}

// UpdateDomain converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDomain(ctx, id)
	return err
}

// GetAllIncident converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllIncident(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllIncidentParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Optional query parameter "criticality" -------------

	err = runtime.BindQueryParameter("form", true, false, "criticality", ctx.QueryParams(), &params.Criticality)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter criticality: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", ctx.QueryParams(), &params.User)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user: %s", err))
	}

	// ------------- Optional query parameter "rule" -------------

	err = runtime.BindQueryParameter("form", true, false, "rule", ctx.QueryParams(), &params.Rule)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rule: %s", err))
	}

	// ------------- Optional query parameter "dataset" -------------

	err = runtime.BindQueryParameter("form", true, false, "dataset", ctx.QueryParams(), &params.Dataset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dataset: %s", err))
	}

	// ------------- Optional query parameter "domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain", ctx.QueryParams(), &params.Domain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllIncident(ctx, params)
	return err
}

// GetDownstreamImpactedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetDownstreamImpactedAssets(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDownstreamImpactedAssetsParams
	// ------------- Optional query parameter "issueNo" -------------

	err = runtime.BindQueryParameter("form", true, false, "issueNo", ctx.QueryParams(), &params.IssueNo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issueNo: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDownstreamImpactedAssets(ctx, params)
	return err
}

// GetIncidentByIssueNumber converts echo context to params.
func (w *ServerInterfaceWrapper) GetIncidentByIssueNumber(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "issueNo" -------------
	var issueNo int32

	err = runtime.BindStyledParameterWithLocation("simple", false, "issueNo", runtime.ParamLocationPath, ctx.Param("issueNo"), &issueNo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issueNo: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIncidentByIssueNumber(ctx, issueNo)
	return err
}

// GetIncidentEventsByIssueNumber converts echo context to params.
func (w *ServerInterfaceWrapper) GetIncidentEventsByIssueNumber(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "issueNo" -------------
	var issueNo int32

	err = runtime.BindStyledParameterWithLocation("simple", false, "issueNo", runtime.ParamLocationPath, ctx.Param("issueNo"), &issueNo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issueNo: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIncidentEventsByIssueNumber(ctx, issueNo)
	return err
}

// GetIncidentScopeByIssueNumber converts echo context to params.
func (w *ServerInterfaceWrapper) GetIncidentScopeByIssueNumber(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "issueNo" -------------
	var issueNo int32

	err = runtime.BindStyledParameterWithLocation("simple", false, "issueNo", runtime.ParamLocationPath, ctx.Param("issueNo"), &issueNo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issueNo: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIncidentScopeByIssueNumber(ctx, issueNo)
	return err
}

// GetLineageByUrn converts echo context to params.
func (w *ServerInterfaceWrapper) GetLineageByUrn(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "urn" -------------
	var urn string

	err = runtime.BindStyledParameterWithLocation("simple", false, "urn", runtime.ParamLocationPath, ctx.Param("urn"), &urn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urn: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLineageByUrn(ctx, urn)
	return err
}

// GetLineageDownstreamsByUrn converts echo context to params.
func (w *ServerInterfaceWrapper) GetLineageDownstreamsByUrn(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "urn" -------------
	var urn string

	err = runtime.BindStyledParameterWithLocation("simple", false, "urn", runtime.ParamLocationPath, ctx.Param("urn"), &urn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urn: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLineageDownstreamsByUrn(ctx, urn)
	return err
}

// GetLineageUpstreamsByUrn converts echo context to params.
func (w *ServerInterfaceWrapper) GetLineageUpstreamsByUrn(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "urn" -------------
	var urn string

	err = runtime.BindStyledParameterWithLocation("simple", false, "urn", runtime.ParamLocationPath, ctx.Param("urn"), &urn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urn: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLineageUpstreamsByUrn(ctx, urn)
	return err
}

// GetRuleTemplateLightList converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleTemplateLightList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRuleTemplateLightList(ctx)
	return err
}

// DeleteSiffletRuleById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSiffletRuleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSiffletRuleById(ctx, id)
	return err
}

// GetSiffletRuleById converts echo context to params.
func (w *ServerInterfaceWrapper) GetSiffletRuleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSiffletRuleById(ctx, id)
	return err
}

// SiffletRuleRunDebug converts echo context to params.
func (w *ServerInterfaceWrapper) SiffletRuleRunDebug(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "runId" -------------
	var runId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "runId", runtime.ParamLocationPath, ctx.Param("runId"), &runId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter runId: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiffletRuleRunDebug(ctx, id, runId)
	return err
}

// SiffletRuleRunDownloadByRun converts echo context to params.
func (w *ServerInterfaceWrapper) SiffletRuleRunDownloadByRun(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "runId" -------------
	var runId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "runId", runtime.ParamLocationPath, ctx.Param("runId"), &runId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter runId: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SiffletRuleRunDownloadByRunParams
	// ------------- Optional query parameter "exportFormat" -------------

	err = runtime.BindQueryParameter("form", true, false, "exportFormat", ctx.QueryParams(), &params.ExportFormat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exportFormat: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiffletRuleRunDownloadByRun(ctx, id, runId, params)
	return err
}

// GetSiffletRuleRunDetails converts echo context to params.
func (w *ServerInterfaceWrapper) GetSiffletRuleRunDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "runId" -------------
	var runId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "runId", runtime.ParamLocationPath, ctx.Param("runId"), &runId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter runId: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSiffletRuleRunDetailsParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSiffletRuleRunDetails(ctx, id, runId, params)
	return err
}

// DeleteSecret converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSecret(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSecretParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSecret(ctx, params)
	return err
}

// GetSecret converts echo context to params.
func (w *ServerInterfaceWrapper) GetSecret(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSecretParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSecret(ctx, params)
	return err
}

// GetAllSecrets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllSecrets(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllSecrets(ctx)
	return err
}

// GetDataStack converts echo context to params.
func (w *ServerInterfaceWrapper) GetDataStack(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDataStackParams
	// ------------- Optional query parameter "domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain", ctx.QueryParams(), &params.Domain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDataStack(ctx, params)
	return err
}

// GetIncidentsSummary converts echo context to params.
func (w *ServerInterfaceWrapper) GetIncidentsSummary(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIncidentsSummaryParams
	// ------------- Optional query parameter "domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain", ctx.QueryParams(), &params.Domain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIncidentsSummary(ctx, params)
	return err
}

// GetRulesSummary converts echo context to params.
func (w *ServerInterfaceWrapper) GetRulesSummary(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRulesSummaryParams
	// ------------- Optional query parameter "domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain", ctx.QueryParams(), &params.Domain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRulesSummary(ctx, params)
	return err
}

// GetAllTag converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllTag(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllTagParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllTag(ctx, params)
	return err
}

// CreateTag converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTag(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTag(ctx)
	return err
}

// DeleteTag converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTag(ctx, id)
	return err
}

// GetTagById converts echo context to params.
func (w *ServerInterfaceWrapper) GetTagById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTagById(ctx, id)
	return err
}

// UpdateTag converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTag(ctx, id)
	return err
}

// GetAllTerm converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllTerm(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllTermParams
	// ------------- Optional query parameter "textSearch" -------------

	err = runtime.BindQueryParameter("form", true, false, "textSearch", ctx.QueryParams(), &params.TextSearch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter textSearch: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "itemsPerPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemsPerPage", ctx.QueryParams(), &params.ItemsPerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemsPerPage: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllTerm(ctx, params)
	return err
}

// CreateTerm converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTerm(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTerm(ctx)
	return err
}

// DeleteTerm converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTerm(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTerm(ctx, id)
	return err
}

// GetTermById converts echo context to params.
func (w *ServerInterfaceWrapper) GetTermById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTermById(ctx, id)
	return err
}

// UpdateTerm converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTerm(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTerm(ctx, id)
	return err
}

// GetAssetUsage converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetId" -------------
	var assetId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetId", runtime.ParamLocationPath, ctx.Param("assetId"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetId: %s", err))
	}

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetUsage(ctx, assetId)
	return err
}

// ListWorkspaces converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkspaces(ctx echo.Context) error {
	var err error

	ctx.Set(JWTScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWorkspaces(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/ui/v1/assets", wrapper.GetAll)
	router.GET(baseURL+"/ui/v1/assets/_export-descriptions", wrapper.ExportAssetDescriptions)
	router.GET(baseURL+"/ui/v1/assets/_export-descriptions-template", wrapper.ExportAssetDescriptionsTemplate)
	router.GET(baseURL+"/ui/v1/assets/light", wrapper.GetAllLight)
	router.GET(baseURL+"/ui/v1/assets/:urn", wrapper.GetAssetByUrn)
	router.GET(baseURL+"/ui/v1/assets/:urn/overview", wrapper.GetAssetOverviewByUrn)
	router.GET(baseURL+"/ui/v1/assets/:urn/schema/:version", wrapper.GetAssetSchemaByUrnAndVersion)
	router.PATCH(baseURL+"/ui/v1/dataset-fields/:id", wrapper.UpdateDatasetField)
	router.GET(baseURL+"/ui/v1/datasets", wrapper.GetAllDataset)
	router.GET(baseURL+"/ui/v1/datasources", wrapper.GetAllDatasource)
	router.POST(baseURL+"/ui/v1/datasources", wrapper.CreateDatasource)
	router.POST(baseURL+"/ui/v1/datasources/_test", wrapper.TestDatasourceConnection)
	router.DELETE(baseURL+"/ui/v1/datasources/:id", wrapper.DeleteDatasourceById)
	router.GET(baseURL+"/ui/v1/datasources/:id", wrapper.GetDatasourceById)
	router.POST(baseURL+"/ui/v1/datasources/:id/_run", wrapper.DatasourceIngestionManualRun)
	router.GET(baseURL+"/ui/v1/datasources/:id/runs", wrapper.GetDatasourceIngestionRuns)
	router.GET(baseURL+"/ui/v1/domains", wrapper.GetAllDomains)
	router.POST(baseURL+"/ui/v1/domains", wrapper.CreateDomain)
	router.DELETE(baseURL+"/ui/v1/domains/:id", wrapper.DeleteDomain)
	router.GET(baseURL+"/ui/v1/domains/:id", wrapper.GetDomainById)
	router.PUT(baseURL+"/ui/v1/domains/:id", wrapper.UpdateDomain)
	router.GET(baseURL+"/ui/v1/incidents", wrapper.GetAllIncident)
	router.GET(baseURL+"/ui/v1/incidents/downstream-impacted-assets", wrapper.GetDownstreamImpactedAssets)
	router.GET(baseURL+"/ui/v1/incidents/:issueNo", wrapper.GetIncidentByIssueNumber)
	router.GET(baseURL+"/ui/v1/incidents/:issueNo/events", wrapper.GetIncidentEventsByIssueNumber)
	router.GET(baseURL+"/ui/v1/incidents/:issueNo/scope", wrapper.GetIncidentScopeByIssueNumber)
	router.GET(baseURL+"/ui/v1/lineages/:urn", wrapper.GetLineageByUrn)
	router.GET(baseURL+"/ui/v1/lineages/:urn/downstreams", wrapper.GetLineageDownstreamsByUrn)
	router.GET(baseURL+"/ui/v1/lineages/:urn/upstreams", wrapper.GetLineageUpstreamsByUrn)
	router.GET(baseURL+"/ui/v1/rule-templates/light-list", wrapper.GetRuleTemplateLightList)
	router.DELETE(baseURL+"/ui/v1/rules/:id", wrapper.DeleteSiffletRuleById)
	router.GET(baseURL+"/ui/v1/rules/:id", wrapper.GetSiffletRuleById)
	router.POST(baseURL+"/ui/v1/rules/:id/runs/:runId/_debug", wrapper.SiffletRuleRunDebug)
	router.POST(baseURL+"/ui/v1/rules/:id/runs/:runId/_download", wrapper.SiffletRuleRunDownloadByRun)
	router.GET(baseURL+"/ui/v1/rules/:id/runs/:runId/details", wrapper.GetSiffletRuleRunDetails)
	router.DELETE(baseURL+"/ui/v1/secret", wrapper.DeleteSecret)
	router.GET(baseURL+"/ui/v1/secret", wrapper.GetSecret)
	router.GET(baseURL+"/ui/v1/secrets", wrapper.GetAllSecrets)
	router.GET(baseURL+"/ui/v1/statistics/data-stack", wrapper.GetDataStack)
	router.GET(baseURL+"/ui/v1/statistics/incidents-summary", wrapper.GetIncidentsSummary)
	router.GET(baseURL+"/ui/v1/statistics/rules-summary", wrapper.GetRulesSummary)
	router.GET(baseURL+"/ui/v1/tags", wrapper.GetAllTag)
	router.POST(baseURL+"/ui/v1/tags", wrapper.CreateTag)
	router.DELETE(baseURL+"/ui/v1/tags/:id", wrapper.DeleteTag)
	router.GET(baseURL+"/ui/v1/tags/:id", wrapper.GetTagById)
	router.PUT(baseURL+"/ui/v1/tags/:id", wrapper.UpdateTag)
	router.GET(baseURL+"/ui/v1/terms", wrapper.GetAllTerm)
	router.POST(baseURL+"/ui/v1/terms", wrapper.CreateTerm)
	router.DELETE(baseURL+"/ui/v1/terms/:id", wrapper.DeleteTerm)
	router.GET(baseURL+"/ui/v1/terms/:id", wrapper.GetTermById)
	router.PUT(baseURL+"/ui/v1/terms/:id", wrapper.UpdateTerm)
	router.GET(baseURL+"/ui/v1/usages/:assetId", wrapper.GetAssetUsage)
	router.GET(baseURL+"/v1/workspaces", wrapper.ListWorkspaces)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9XXfbuBE3/lV4uP+L9vwVO7vb9jzNHS3RNhtZUkgq6Xabo4VESMKaIrQAaMfNk+/+",
	"HAAkRYpvoCzL9gY3iUXiZQBifjMYDGa+mgu82eIIRoya776adLGGGyD+tBBZhvh+AgjYiAcgDMdL892v",
	"X83/j8Cl+c784XxX+TypeT4ADFAckwVMan7rfTW3BG8hYQiKhtaYMv4/e9hC851JGUHRyvzWM7eYVL34",
	"1kuf4PnvcMHMb597JoF/xIjAwHz3q2wwqd4zGdrA/+EIckrMpOrnUhM90wo5SdHqGuPbAcO84yKdCwIB",
	"g8HFQyWxydsBYJC/X2KyAcx8ZwaAwTecBrNXrgS/MEgiEPI+K1tFQaGxOEZBVTshoOwGB2iJulKwSWrV",
	"jCoCG1j5Qj74asIo3vA594ZW/73ZM28sZ8j/82a+bd14uZnOfb78xxIDEt00fRvaxwH8hMkt3YIFrPw8",
	"AaQLgrYM4egxU3mLoiA/sKxTPiocIYZJxaAaZuoOEprQlHWOIvbzT7veUcTgCpKGuameFAoZX9UfYhAi",
	"9lA5KyhaoCBlZxAEiM8PCCeFQnm6/vG3Croqev9DduoxwGKan7C+6/hO3+KrwPJnruPxZXFtW0P/+hez",
	"Z05HN+OR449de2D2zNHYn3nTyWTs+vagcl5JHMIjE783y8WR1M80ZACFtHrtZSjnqK2yXYVR3brZFfH3",
	"eM3yr+2RZfbMC+fqw9R2+bReOq59MR76Zs907YF37VzyP73R+NPl0Hpvmz1zYPnWhev033v8ezgfbcGm",
	"3gfBrr/I/ydjz79ybV5i7Fr9IS9zzRfqcDx+b7tmz/Sti6FtTc2e+WHK23KurnlHluNeDsefeDcXvvy3",
	"PxxPB4Kyj7bvWiPR/CfbnV04Zs+cTUfvR+NPo1nlR2/j5RQ3B7tycrUzKIVTo0jaVeIfc7c+ACHggf9e",
	"Azoh8A7B+1zvc4xDCKIUbl24JJCu1ZE2gl+6V9qGgPGS1RgMVuqj9sGqZrQMks0x2okpWMG26oKVpryk",
	"aGWPFQt8VOKSEk8UvlQ9455ImJ8GBMpFEN2G4AEGaiVsASI5wd2/tm+sFB8sz06Z3OyZ9r992x1Zw1n6",
	"4KNjfxJC3rddxxo6/7EHs+RZBjUzz3dt60a06F1fjC2Xo8DNeGAPxbMrAS79a9vzXcsfuwIi7KEsJCSD",
	"kAsjQYhrjbzLsXtj+c54VAkVMGKIPexDJB+MN566/RT55I+ZM7qyPd7WzJ2O0le2v0ds/9py+bP+eDi0",
	"+6LrrOgsJVaOxJ0O7aQtZ9R3BvaIV5x6Aiytft/2vJk/fm/zAp5zeTm0/RmvI1ofXTpXYrr5v4PxjeXw",
	"YtbQdn1ndDW7Ho/fV485gb8hil6Z2ngqrSHPhy8eN0m1kDsCnuaVa95NLUYO0WrNnlG10WytzrW1zFW9",
	"kB4rYnNfoqe+oMZksYaUEcAwaVlXWgPuKX+z6o9U/xXuIEnV2P3dstjN8D9xBBUMOft7oG+9NsPPqlNp",
	"Bvba/6zOEbULv3pWivvHAPHtwAZFfKnmJupBrkvZBlfFC7X27R//Glz0MzVJ/CgpT+Jpoi2Jv3coJX5W",
	"aFD5YjPXvuQL2h+71pU9u5j239v+zPs5xwVZV9mDpLvsd4mo7E2VTpe9bCThqj/JPbwaj6+G9mzgSv6S",
	"bDNLmTT5mbSf/PI+7OhJuCurkP5OtdOs4ODCl38nRPHfiTQoUstf2JNr+8Z2rWHuGachX9cWqgX/M2HM",
	"5FequQrWvXAKne4QoEhLBjTJp+SwnxG+e7nriKPR7MYaWVf2ICspHn50XH9qDdMpE89KX1E8LQ5bPBL/",
	"TNwxl1fpM29iue/3H6ZYtPf4enDJhyC+7F7RdtRijdDkCc6vFA1LBMNAXbO65MU5s3IsrNSxapHAg4As",
	"1pcoZJDYIdzAKFWC1KzbF4DCmjbKdm5UsCvK9WKNMmabOBN76Izs0sZJ7okqp7tsB68eZ6YgluYa8NeK",
	"mt0ChIs4BMJw0mm3sMBxxFwIAkV7HYyCAXjoYCWBZMHVlLBI0zLEgO3KR/FmLtsXu5AlWoDUwJR+lOlo",
	"t63g8CQ2u/bAmd6I1X91XW2ihCDY11A4fjlCjeCf16vepDBAWKeBii3BBJLdqcqUQqLOKtPK+nU8k2fm",
	"dJ2UV0H+82afrvBN9ic8N2O5SagfXe2ypn3AQIhX1RYe+U4ypvoU7bN0zaaNiiKSirYmZXN9HIZwwSdA",
	"ANYQ3sFQvqnaue1Rv9dhzYygVTS+jyChE/AQYsluakBm38GIpbXK0BXBe9GwswfLrZCxP21bAu8Qjukx",
	"WlPEP7aGEXiCY0uug88Bbdu6VL4mcFVn2iY4hFaNRYD+PI7ZNmZDvIOu8nnTdjElYeWre0xuVwTH20NO",
	"VbPxFkaXjWVHeQWd1aeweYKqPl0VK5bZfI3CgMCosJLUtjQt0rt1N3Rg3WsIQraWJrADm5gkxwIHVvfB",
	"6sCaQoAcWjdGQV3VzxVY8UcMyYPS4bPlcb3X/2XClafJ0PIvx+5NZj+ceb7lT73MIuPb4uXU40qtilpV",
	"XolFXbG4IAmkccio6nlvuS+0+sBH/gSQNUdhiKLVhGDeWY11NJBb8Zq324a6ShCSqhG7htRdNHJTw8RZ",
	"MAx8MA9hcUOvNl37loDybG3TXuSU5d40gso+jcXaOzGfFZBLquqksXVC1WeqNIY2s0d+9H6lCaRUIseR",
	"zsi3r2x35lojsXP0nRu+c3T8WX88nN5Iu2pqs+UvhVV/NrFc3+HPnNFV+wazREDVTPTzipS6BGnecJaQ",
	"rwReKOh6MFINdlUI0cdRJDVJH9JqENpAmp4elLWIeLGAlKotuJ7ZF2ehfbzZ5FTEYymWC9msKpjUELeD",
	"vpqzXhzZX7YEUlqnNLU5HNR+t22G0opm1IIbXauakVde2wrvCY5Wk+uF3w9xHKgXVy3JFUWCFrdUscIl",
	"InCOQ6Zc/A4yAiLF4tfoDioWHWJ8C4li4RtK/whVyz6olx0TsAhVKZ5gylYEqrc+wfeQXCDF0h9itLj1",
	"0Gqt+m1cGNA1WqoW9yJ8vwzBrepwhbQHsWLpaXQb4fuorBh9Fhv4BanVckonxN22pj0zjtAfMXRkdUZi",
	"mNNam4VacriW4EqDMpRAH94AFNWb9tQNH8Vz4AqRdjBGEriCX4qEtG/tS8Yn2uQL2ad3fRyxOp18Id8p",
	"ytc9ZDymBg4WwlhWs+z49rpu7/47ng/gEkVC4XkK5XxH2o6Qw9T0nag45tQllNSeFjNAVvAgf/F8y1k7",
	"HYYLVqXD1g57kKxaecilfa48Y55JH4Xcr+TMZ+xfc53bvjz4tKB4atttIHvHvXtDAfT20D3x56d1EhwA",
	"up5jQIITfcXk1DN/yLM75dw9S88bXXsyFm4r6YN8odwBZM1ja2QNf/Ec7xFLIvMwd+MQevFmA0i1sznh",
	"7xlg9OKhTxBDC1GryXm7UZeIQ3hFcLzNdVkF1wwzECa7MTWP8G81w/QYWNzud1ka5R8xEC4xF5l70lFd",
	"0+spayIqKJB/8TAo+c4c8glqJ0Wd8sJO4KiiNOabI4YaTOHJIUrlu9pbR2vGthPA1o1XklpRrJfcnTpE",
	"HqVk99KbTBlJ2aWmpPEuQkqY3p4I4oIdRiipmXu3Vgqz1W52zzwHKkzB2g9H++FoPxxVuU4huyAILo/n",
	"ofncTq11OqCK42rZCfGICjBF/4PHvoPHwf8TigJ83+p9vivJ6xEQUdlhteh8Bh1cTv0Jr+o0n93ve4l2",
	"cJLdO1TqdFhUPtBqa8JO7oJ0rZeZ3jxGINjka35+xstMczZoMTO1maEChtua+B4vF6wBtfiOqvpGY81x",
	"1ekvCO3OUxTcxeXeoKRB1twGalsVL+xaUCtI11qUFYVm+WJHi2AUfmsTwKTHWucL+AysHu0/xif36G5j",
	"2QBf3C2ol3kjqIMutePQ0pSuAR0vl7Rgss0h0hpQv6DelItgUX0aoeqNvHz9EYQxVNyy7/QpsdSrV3Gx",
	"TO2n25UbAso6E1AzqtrFK75P4utw0lvPCofr+i7fE9zA5TU/QXgr/QihusThy9GJVpByoJa1ayTQoTI8",
	"gl+Y/QUuYrYf96TZi1+7UmhXCu1K8fpcKY6lOCv5R9ReR273mGhzE5PSM4ZBtbrxPMKzWOSxm2MtiusD",
	"f8Vz2Cc4+heeO/W74T3JebiwPf3WWotlLZa1WNYejkc1dp1OZmcw6sbRyc4JYiKsb07kwQWOAtWTGpjC",
	"rB117PEk+8Zy+KWJPRo4IymiRyP5lzftJ2eQl5YznLpcCnvvncnEHsxySoI1dG1r8Mssrfi5u8gicZT4",
	"lrStxPwiSKsIWylarQp3aOqjjTavsp2jyoFxQfL+GAqHcv/hZYuuDC1RFbo4fIgh7S4ZH+uOdOlOTe0F",
	"6R0VnW9J15u1FO9K5/uunKFiHMjO9uzvNjRReSZP54T+FCB/nMDBiFphKGeiPmroaTX+4zneiyHnR9jg",
	"i28LaT+VRw9VIVAUD2y+j/1pFT+JS3On0nEUv8l2d/NP2ReiFI+iTZ+tvGvYVslJQlxLrWa65aNVrVtZ",
	"hyvP23geIrqGJFnHjS4Y2YIX7JOELulYj5Vu0Mr1N+u7tiXj0fTHNzfFJ/Jm+2w6GSQPxp9GtuvNLM9z",
	"rkYyVqb9abbT30Zj37l0+iKc6szjy7vDisxd/nxc0DSVDmvcWo54v3uJwvqT17ApxEZ28VjyoSK4Vt0K",
	"O/yGtzh9PGloY+U4UUlphYPvp3YVCsJ+7QVjLviXIA53J8TdXY1kYGUdxPQ1hB6O4jDkYFKtnG0B4TI3",
	"5+iiuNgJ3AqGqm429fpUuS8Qzw8JfFelJ9fcPwUrzm/0kZD18hylar2gtlT4NmbOHI2mtKTweLmb1hYz",
	"Vi0s78X2qth2RwNsxQz38R0kxTgNucWjs0qcNqtEKZK+jpH/+mPkP1GKkB1UPybyXx7B1yIs2BPGxFeU",
	"zBvIAEeJ7glO6jBHmuM+QbRaKzvCvbIQ/Y8JINr5LksRp2ojtKuIp/pdhPYkODmm1DBQkxbS/KHzQZFL",
	"H7g1tZtSnJKG/WlboLyuIbI6BtYrEVtNZeFg/mTxQWG0QhHscjG5S3zOpHX128F7DgcnyO6omsRRdQRX",
	"iO3ColUcQ8RsvY9V174/mVlT/3rsOv+RFrFr2xoIBOFAMptYnvdpLJDJ86pDP88JiBbrGqnXcPweV0Z5",
	"2be+p0TnGpNVK2eA4HjrBBwelqgm1N0a0Gpib+FDp3OCnnkHwhg+5mxB0JL0nDVXNTCFeKmnCNh+VG1M",
	"7YpuzrHnqJETWAjoRUOsIVFgQlC0QFsQ1u4ja9Ht92BeG4P4lsz/3sfRsiaAUX2fXQAwJSDXXb5xdVhx",
	"NluwYDCov1Kh99yNe+6nvtfdcg2p8P1og0kmBJTJYyD1Dc9jYsCXFtb+0HMEKQR/T8/AWoPXcNIAQRRH",
	"w+QCiVrKhCScf7LdaS8vgvI4+eSzB0XlSVuov5nHB0TwBtH0IyvuMBfFAEUKNZJjjQ4a/16EhdowsQq+",
	"BTSGI6xI6OG29VpuxeIYt0OeiVq/IBKHcAjmsFo60JJn2nSUO8wcj67G0jmtPxx7NXaOxBnMRxvlkTct",
	"PW+BJWiXAWO8WMSEdJ5kwSTj5SVAYUyg6oIlyeXttpBZTlSgPP0MYB7CzktXOZtO1uUz+poV0KYTFu+D",
	"jKKD2a7DJkiucjE4Yl6OnS9nmWnDoOFtbRKcS+ffgtkuraFnzyZjz/GljmH/e2L3pWVLSnzbdR+RmSib",
	"oAZxBeT5iAvpFkcUuvuMVu+Ci7cw+7D0Ipdx9JA4aHXitYoViPRgOUjKHieUXZWTbGlmISGYdN2/lbvi",
	"gqkpM/qTXJoqSO6K/ZkwtMrzFNfy7cQS+wib+Knk76Fn28cTz0+ICseQ7mru3DW3rkqLk57aD55/d8rA",
	"ZttBMcmPNyE431Dl+FEEwQpajIHFGgbSz6xp66r3pbW+p6/97LfjPru4rU7SNNXtrpN1JtdXtfwWqSas",
	"mK0xQf+r85IBpYXaeIetcnVzwdA1kUeJ/qqo5wr2HXwfSecR2rXrKak7DPoez9eWcRjWzvIaUCeqioeU",
	"DxpzmjP0st0yycdVEwmGhbBj/Kbt0deTEg5kHFQVBii3yvfOnLPvVvpK2SdJDqaziUqnZYcx213jLXiT",
	"DLJa10Q4uoFsjQu2+wvLda3+dGDNhs7Itq5E6E7XyljA7g8t1+IKTVbAmjiH4+keJQ0jyt/HPaaNf5U/",
	"D1NfRsVjtIpldOhx3h49va7nezc4gOETRS/GuVz1SheU9pPb6zjEOg6xjkN8oBkoH2XgZP4XtdHfjxHg",
	"vWdSGh6Uzy93hJng4368d95yB9R8eElzu+HU+CH9CAndsy74Q2/2cfbjjM90+vfPlfJX+QMdMNn7BGbT",
	"rzrfhcgWf47FfIQ1qzp7YvSQQbFTFIFeKtW8LaapATetoK7gTMqVay1htRkZC8mDqqhJa1eOsjl379O4",
	"snTeGjcl6607xvx+r8BXfufqlVZaznd718+aEqqUguFojOmKMYXoQMecvkWIYG1mNwYjUPvyHpNbugXp",
	"NZ/O6WLSjnPdNCVcT7uqnB6C5yHcVLmDM4Cqz+xRRBmIFsVjjpig2mBiGWLXHcWVEx3sP6BK0dek6T/N",
	"Xtxuh2mmvoqOUvio0yULBPfUlan3K52lk2T8j0wEuOskn99fldn2YmVp7f642r0bh7WRLOEKk7oz11M5",
	"Pj0mmajqwWy0jeUF7mrg2AAUdog+E/I5jFbXGN/WxURuSKy9oX4nm61Cd/WXIeIQ+nCzDQGrP5jgHQVx",
	"DejRECxu+2sQRfC4U/Si7m5V31opzV4dewmHDxf+EdclWl/xAq1W1bJrfqU0qcp42OYSU3JzU3SJUc05",
	"hBkIOV2qFeIIiMAvMHi892eNO1v1QfaRAepxqRdU7x/xEbpxNIDzeFWdUhPf97k0Vpx9gu//RXHkMaIY",
	"ZyUjQLjwXDyI5VdzIXAer7w/wtYdduUuXlyv3sCoNs7xioBt6YrOYDoZOn3pwtMf30yGtm+PEl8M1/au",
	"k79H0xvbdfrWcLZ3IN4zB47nu87FNPnpjHzbHTqj9/ZgdmP7rtP30tP0KmPTwdyd3lZTdHJtdzsRxmjf",
	"7l+PxDiljw3fS3+YOq7tzX4ZT92Z5fv2qMYTYG9FypHVLckUG+vdrsNaF95HcsS+c2YxIlwl6x8vutxx",
	"/O8qIxkebRAK2PWEw1DLM9J9QNWBHk8/tNYoswcObb/d0w2tPjZjt6Fk7ZyMdKVYKp0GUdXisw2n4e79",
	"Y8ZUGxXoyQamdklOeUDlq1EnG0jrbaNuAyndKzjVQDpodV0GVNvsyQaWbPMeN4yGPeeRiF6QOkZoMXvU",
	"7vfvaoLUVfa/F3P+SWySqbrb/XZwg2XtHhC4xjGFj7JbZqT18ia3xqOCfNefm6a0lC31iAEpDwvfGt2B",
	"EAUuBLRmTW1w0HBroG6HUhcoT7yylkzWVLwoKyatPlUemId1RqzDA2TmjP/lXbWYrcma1K5RUbmfzNwB",
	"vgZp/y/t3pfa2WUxC8UJwoH0TIoYPEGcEB+sZJDh48LzvvvflT2yXacvTrIHA3sknLFm/aHleVn8XXFf",
	"wHMuhnbNW992b6qc9Qq3CbKHrVv+tog9dbL1GUKuwwCx+lidLzbE6GtYBfn0K01L4RkirRye5/alTrwS",
	"1K6kjDgmIKka24oZdnV+3ifJz5tP81Ka5VRuVV8DYYvSJ2hJC2Pma1V98rqUUY8Q8p8Py1CTLPvT5Q45",
	"WLofL49GLSdWhB8ur5U9lEtvbF1OR/16q3+5KwpWcALJ7kOm94ErgqvEEXMhCFQP/ygkIyVI2rWcq/W5",
	"jtpnDPt1YERPBeSvnXVV/QavUFepUCai3s/zJYp6lZmVsfdigtiDxymU/f7rk8//m0NAILlMu78QP41f",
	"Gb6F0WdzDyN4JQPEbA0jllyJN+4RWxuyFUPUOjN+lTsK4wHHxJA3XuUrg60Jjldrg62hMXU+/2XN2Ja+",
	"Oz8P8IKeUbRchpAFgIGzBd6Ih+crGEHCdVMQvQFb9Ea084NUsgvP/nqW2jSE1BUE7SaSd2R++ybsA0tc",
	"0iTMH34wrOHk2jI837qyjYHj9YeWc2O7/43+G/3www+Gs9liwkDEjBFmaAH58wu4xAQaMUXRSgzJkyMw",
	"rHC7BoY1cQwYBVuMIkZ7xjaEgEIjwgwabA2YgZiBqIEiAzGaVKEMrGDP2EAQ8TZliWUcLaRXoDGPmUEZ",
	"CkMjjgJIVlj0DCnj//83fvv2p38YAbyDId7yFXdmTCnkrYiPtAAiBZ8BosAgEASC5BBtEBNfkho4ZiGK",
	"YGDMYYjvz9KhD3kRGBgWpTEBkRx7OtQFiCLMjFUMCIgYTIYGwjBHNuJr3bjnZM+hsYzD8MHgLACSUWFi",
	"iOgbb5YEwjNjHPNZoILOebyixgY8GHixiElGksdIvGAxAWE66sQ2YPTXIFpBmiex/DUMmtRPeuETkeTz",
	"MRY4YjBiBl4aJHEpkRQsRMtiKnHM+HdEC3hm+GvxERdhHECaFOLL3Zi6Q9oziPSVSSZdtmdIbqc98fTa",
	"9yfGRlyMpNkAObVW4g1K+QS5cIPvQNgyMEnpHBogCGDQM9KNW483QXgTMMhGsCUIk2wcn9YohMY9NADa",
	"cAKNOVjc3gPCZ2SzBQzNUYjYQ48XIZBCcgfFvBGuYPDxbsAt3I2frwJOS4AoibfMgF+QXKVCOspPz4f7",
	"SXaY1sfLJVogEBoUb/gv0cVudCGifCUijiSIGgFexHKdO5FB4wVf4xT29iqlCy8d/5LgjSiS4zkxi/xr",
	"yCIMiwIZNWlHguzdR0qhzRinBQf5grzcOAofZGeFz7QbCMfI6n4MQCBfjhQFkHC6BePQeMuRCAaSufGS",
	"Q0FSjReCQK5rRA3AJATj+8ggiN6eGZ9qvl2AKF/3KIqhnNn81FQPfoSjNwNEFyGmMYGGtSJQSDn+3l9z",
	"VMy+X7Ze+aIWDe8mAlFjjuMom3Lh5ZZWrOsjB01ALksBxw+qUPyAYwPwxuQ6TcsiyrkhZVM0DwWnGiB6",
	"MAKw4ZjUM7h0MkJMqWApzNaQGCIaTm7NA4I4k/NlxjsWQdHPOtO34PuSEAYrKBYml6NbxuvSZJayWbiE",
	"MODcyn9/4jwcLjj3iG+/TN6JkaDNluA7eZpzZvzC3wuHUWMNwy01YmogeVjAxwABFZVgtOagzysJQpbo",
	"SzLihADDlXqsaJY/evNMGgDv+Qomi166/htcb3pnoGUypynDptMvBONvKRFgvgjgcp+M3wSgRIVm73Ec",
	"cjlp/Cbr/PbfKLvC/85MW78Ai1sYBeLz/kV86b+aPfMuve5n/nj29uztG8BfpP6IYIvMd+bPZ2/PfhT5",
	"gNlaaGvnMTq/+/F8twNcyU1wJkadwHxnXkFmhaFZvFbw676ucxXiOQgNBr8wQwZuM7laZL5LLmmlyqbJ",
	"S3hpgYbLKvsdSK3XwJGxQncwMmTIA0OeIUBa09s6F9a40F+2x3yiGBb7O9W24YiPYPBadUMRJWS1NF51",
	"/WjkxWhrlN0qnzgTe+iM7FJEHBns5hhDEJDUOASZyaGR8EN2gt1JZWBloKCOTAZW1UQq5tTsQAckmyZC",
	"oAjicQpKdpFIGujZFXoiqqSdKgEQGNSRkWZH7QAfEnL4eGVSmUTqwDAwgnyiieoe01CUwmxErSgYFOuU",
	"CMndV9mnhOsxiQIPA2PLeUbGJjwz/gMJfjMHNH2OogB+Mf7y9uxs9Ncayrb7HJXk2zPfve2pHKlWUSfJ",
	"4foSTLw0uHQTyi6LSSRUTK4/JlucFTwzJoBSAxjCgYJXfPNjT9R52PIXW7BCEcj2iUvIFmuxnZMrp3pk",
	"4t0EkkntCH/6+8FDTBOIpqsBR8b9Gi3WnGiw3SbqNcWE9ZKNlfHOSNNv9iyv/38HttevWy2FC0d5Bmkj",
	"pIEOY4nDEN/zjbR8GCCSRJDpmfAL2GyFlsBJ4PSZuamporuNNYW5Odmpcsp/evtW2irFRlaYrbbbMLHX",
	"nP+euEXshtxqQ6aJH6q8p7FvODa9WKhVcnuSLBipp3zrmX9rJGYrr1f+/92ISi9lVtByAYKUY2XvP56y",
	"92kEdpHdRPc/n7L7S0zmKAhgJPv+5yn77uNoGSJpQ/37ab+5E8ksRIbY2Ca2pILZUyjBwuD562fOLjQN",
	"Ass15kSEGUk6HQF7yaOlDHAsd4F8SZvpba5fTcEZ5mfeTUE5P5/BL3yD/ibYS4pUqbHboqz07CzKKa3C",
	"axVeq/BahdcqvFbhtQqvVfiDVfg+vevLdlT0d6m8JAKywKtamX9OZf5vp+zbTdkkwpwT4ijQOwrVHYVd",
	"y0AH7h3esOTycddNRHpp2Xz54GJkY9Qoo1FGo8zhKLPjJAW4CdMM5A2nicKB9MXZI2JSu3uISVStDnbe",
	"H+m9g947fN97h+bgI/osQJ8F6LOAJgH7NSbRt0YBy8tdPEyFzNoTsQKwtkAkCynItt29AUZi2CRHn/xo",
	"sCMMaBTQ6r2GIjUoAgZF0SqEHdHmHOfywTTCTpoB5uXCD46g0gW8VTmjTXMFup5jQIKu1USgsW6VKvL0",
	"fPvcATENvOtJQ6eGTg2dnaEzYyFjKy/oKkOpJPX8a+Kx3a7Jift1QACqFQW5tClHh9ZeZSt3WY+nA2n1",
	"oGzVAYnVoTDpUwOhBkINhIcA4S7kVy3+JaGj30hr2/lXFAjU2wK2WJdxLwlZIOvIGBQqYCfcVeoRqsWx",
	"JY2vACm7wMHD0Ta0+WFM+HizzW2R1G9PuKne4WR5MYzfN3759JsWvkbFp227PpTU/z5N/k/nEqUPE/Rh",
	"gj5MaAoDrqYKZiim1UCtBmo1sFUNvCxyTUlPKKsIYqqVtITUOfllKQovxd085+Td5Ka/K1Z/0UC7Lmht",
	"Q2sb3XdzYtS51AZqxqYwzPEuJ/unt/94AXRtAWEIhPkIRUUytTqk/StesCYygYSjhQFSlwqBaByNcpIy",
	"hap9RUU+/CxyVtIKrSQJYp3XSp7CRrTfjbKJ6McnABAV6JBxcjRQfPdA8bef/nHSWd+uCAhgGhsqeGVY",
	"lcSvAkbhEmYlIlXuns5nDEqYqoYrH1KWy/OFoyhTs57MtN0NsI54RyQbnZ9kDa1eqkkhEc8y8cDTYKW1",
	"mheOFHxNc5U8Xb0iolzJAFDyPNhxpJHj/jo0SY/hAhhCeRGsCCcD8XzX5sWDc7qTuAJs/O2Z9Bw5M1rP",
	"0fZhbR/uhF+DfcYx5g8JfkmWr96F1ZmGXwIGvX0mDModUGkI0hCkIegQT6VDN1xcRTqfkTiq33RVZB++",
	"AVEMQjeOnlFb2kuxgOcGI2i1giRlIo0gGkE0gjQhiGTj8CHlnOLZiLGBDIjA7Sjle+N3PD8AX0gcNR6M",
	"V+c3p6cAF30ErI+A9RFwu8NZiTsP0exzQGIIBtdyWstpLacVndFANSeROKIKMln4Xre6pyWlnts3TQth",
	"LYS1EC4I4Sy/aQdvrISbtZTVp4GvwJSVW7E5cSbvDLV6MKVXi57Qe6nIgSf0XFJm/cRrKZkMzfaa7V+L",
	"u1DKviW2L2mwqof6aYsvwzxdeeiu2VTvgTVWdDtwb8KKhuN1UeRPcbTedR+QzBffESF9MKbBRoON4n6k",
	"wDfVG5KY1cb2OK36cfw9T34Yz+D8rA5zsSBU73k0vml8U8Y3yd2KGy8ULUR+87bDAycp9+ynBy5kBME7",
	"aGSUy6zybA0TF03KAGFGIOP9V3XNy5uVMMwrvWFoA1WcCSooibfCbp0QAqOgiQyGDyKiqqkFQQwtQMjX",
	"RfNF/vSUYAO+oE28Md/93DM3KJJ/vy2fHnS/4t+SD5EqZEKcjizPc65GIgPfeHQ1dkZXZs/sD8fekZId",
	"xhSShoAI/PWJIiKQOJSxEGpI4e9PGZwBsrb0e5C9utx7+shRHzl+30eOqfxuDLAwRFSEUMiE/ZHjPCgR",
	"MUlCOoQVxGj1Xx95vHDLwk6h3und2RKu1LzPA3wfUUYg2LxBmy1YMBi8STLENPnVZrWcpJJMTN+moe/U",
	"1qRako3GIDAE/GdOg0U7rb9SXFAaw1GNGttVOGjprKXzdyudCxzcNQjSHiNrQakF5WtwCZJSJ1u884e8",
	"uFEUnV8TEdSYhiBt4+LBEaUFmKuZ7zMBp2DDr8XbJ0UOTuEAMoBCqo4YWqfWJnVtUu+YBk/exU2xR+AV",
	"Z75EOTwAs87hXZvlPW3KFiVfK4AppUMRQ1RMh7JvqDDk/Gg405rPa9B8dhtrI4GAA8CDLvAWqmCHxwv+",
	"KXWf/AA7aj6GnD4NGFr/0ah1kP4jGKirFhSiCIIVVMgCPJQlX2ce4IR4O2KIPdRsy/w1NJLp0DCk9ZZX",
	"gADJapX+NukRQWaulfyXcn/CAQ3Mnzv2oApAsDvuoC8XE5Q2OmVwaN/w5MDCyM2bAXkjCOqdj0aQ14Qg",
	"+SV8JDSJt+pYMt1qJOGfIZszjSMaR14jjuwW8KEoQuIQvmFwsw0Bg/Q8RKs1exMieRm9DkbcOIR+Ukek",
	"6hvyCqfg+FLPh+ePLjVliFFoANAA8DoCJgleNZL07gZeihVtpEta+A/mmL/wsgQBqjfPPbRchhIA/gzx",
	"5Pk4OkSSF77oGiC0yVSjlOqV9gQw5DWP6ijynAkbL7i/CNB5e3LQkWqKxhyNORpzDggan0eeMtpUqT8i",
	"lPP5VxJHTvDtfBbAebyqjxyfQyU3jgai8GliOlc0Kmh+iVft+fRcERxvXdl4Anzfnhhf0y9Sh7PJ2hBK",
	"MYkjQ3xrnWBMo61G2w4aHucZYOwz0/6m040jRcDF91GIQaCMuUn5i4cTJet4KuytudUOv2wxYZeycuV9",
	"F7PvfTR72b1x+avvfZxdjt2Z/e++PTR7pu99rLgz/soAP5vCOYqAmKTSJIqQCucLete1poJ4SFaasQQo",
	"RFEqKfRxgRYVWlSoiIoa/jHwskKAnBn+Ghp972MS8zUQ6e0Biqi45rZEhDLjp7dv3741CL6nBk3c0fnL",
	"AWBgDig8VAgF8ipJ0+nHvuIvK7xg8dMaHkKHvNc3XPUN15OGvC+ix8WDUJm6WQWTjauEH62IaEVEKyLK",
	"Z6epTpDxT4u6QOGCSHWg5XxUlqtWBvYgU/x3BJ+q4uyM3zdORTrKhNDGY5dnGMuRsJYTXgOmXednfw20",
	"BQr0klKn8IbJDbTdBeYRA2eAIcrQgorsh28oA4vbtpSHnijUEosliXgWc+1viYmInUcPj3v21GmfxZg8",
	"CSbdUsQZYs4MFC2xFtXaw+hVSMn9dZvDiAwQ6nAiu7D5Jmu1/aImTVjrT4Qa2RXNrqCxi6maTqCGDQ0b",
	"rwE2yiu3C3AIu5wKaHA1/U8IGFzN+BCLSMZ8hJ1xQ8yfxgyNGa8KM4qrthUv5OvGbZgPVm2osB/+mYGV",
	"CERdhwxJkOqGuN1X9sh2nb7ZM6+dwcAezQaWb836Q8vznEunb/nOeGT2zI+O51wM7Zq3vu3emD3zwrn6",
	"MLXdX2b2v33bHVlDs2d6o/Gny6H13t49PCQYuDb3a3O/Nvef1Nzvg1VLzGkOWFpca3H98j1shfTdyWi+",
	"cNsy2Epp/BTuRj5YJRlsT5+7tp6pqxLXagbXDP6KstZKli0yeVEDV7wyWKmJv6BMtZov9em5BoduaWqr",
	"wKH+INkHqz/DvT1FcS+3fhpVNKpoVFHeU/hgVUpGm20s6jPRnlK3eJK9S5KJ9vQ5aBXBLElAq9FM711e",
	"UeLXlr0LJJvW4wNINs+e6lWb0bUZXZvRO5rROeNqUaVF1Suwows5lJNTfOm2WtKlYPrOTemayTWTvyZb",
	"umTaPUbf00hVzemVmulLsqdr5tSmL40QHQ3qlQjRYFKHZPP92dQ1smhk0ciiblSHZFO2qme7jAaz+il1",
	"jO/arq4RTW9kXpNhvWUjE1OZkUTktnaCxgRnItf7lEqbbTvUJE2+WE1mNxx1hUaMyRCTplFA6zUaijpk",
	"zk/YZgdGEkokGt39eH6PyS3dggWsP+obIso+7YqdImKDRfs4gFmnxwndsJsdcQpynx9SOjtZl3yGRFt8",
	"6quONScEB7E4bTEYjEDEzJ4Zk9B8Z64Z29J35+df5fNvZ1RGQgsAA2cLvDkHW2T2zDtAEJiHchaTJgpB",
	"K7fxPESLAG6wuT9StDQecGwAAZUGw1lsuHvE1sZvKQVgvgjgcr//33oGW8OIt0AS2o17HIeBMYfGb7LO",
	"b2J+SxdE4V26GCkDhImDSwNFDIYh+r0wAe/Oz0O8AOEaU/bu/7z951tTtbkAL24hMcSqEAHq6hv9Ua1R",
	"MSlgiwwCF5gEIv1ofaP/NL99/vb/AgAA//9g5GmtvtwBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
